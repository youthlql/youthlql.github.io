<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo搭建博客-butterfly主题新版教程</title>
      <link href="post/bb283ed3.html"/>
      <url>post/bb283ed3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo搭建博客-butterfly主题"><a href="#Hexo搭建博客-butterfly主题" class="headerlink" title="Hexo搭建博客-butterfly主题"></a>Hexo搭建博客-butterfly主题</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>对于Github和Gitee的基本了解与使用。最关键的是你要知道github为什么访问的这么慢，如何魔法上网访问github。或者说不用魔法如何访问github(本文在<strong>可能遇到的问题</strong>说明了如何访问github)</li><li>Git的基本使用</li><li>yaml语法</li><li>nodejs的基本了解，npm，插件什么的（不是要会这个，大概知道这是个什么东西即可）</li><li>其它的编程基本知识：全局环境变量如何配置，nodejs的npm如何添加国内镜像加速，</li></ol><blockquote><p>建议小白先去了解一下一些编程的基本问题。比如文件名不能用空格，yml的语法，全局环境变量如何配置等等。没有一点基础直接硬上的话，效率很低，会报各种各样的错误，然后为了解决一个小问题会浪费很多时间。</p></blockquote><h2 id="博客环境说明"><a href="#博客环境说明" class="headerlink" title="博客环境说明"></a>博客环境说明</h2><ol><li>笔者环境：win10 64位；node.js：10.16.0；Git：2.22.0</li><li>写代码的环境vscode，建议编写yml配置文件时用vscode。其它的诸如NodePad++会出现各种不知名的问题。</li></ol><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p><a href="https://www.runoob.com/git/git-install-setup.html">https://www.runoob.com/git/git-install-setup.html</a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>首先选择一个磁盘作为你博客文件的存放位置，然后新建一个文件夹，比如名为 Hexo_blog 的文件夹（我后面的截图名字是Hexo_blog的是我之前的一个，名字为myhexo的文件夹是我现在正在用的）。创建完后，先不要点进去，在现在的目录鼠标右键，选择 Git Bash Here，然后依次输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo框架的安装</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等上一个命令完成后，在输入下面的命令</span></span><br><span class="line">hexo init &lt;新建文件夹的名称&gt;  <span class="comment">#初始化文件夹</span></span><br><span class="line"><span class="built_in">cd</span> &lt;新建文件夹的名称&gt;</span><br><span class="line"></span><br><span class="line">npm install  <span class="comment"># 安装博客所需要的依赖文件</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0001.png"><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ol><li>github被墙</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0002.png"/><ul><li>解决方法一：Github搜<code>Github520</code>项目，按照文档配置即可，5分钟即可解决。<ul><li>缺点：有时候可能不太好使</li></ul></li><li>解决方法二：翻过去，怎么翻不能教，因为wf。不会翻的话就老老实实用第一个，这也是没办法的事</li></ul><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><blockquote><p><font color="red">注意：后续的命令如无特殊说明均需要在站点目录下（即myhexo内）使用 Git Bash 运行。</font></p></blockquote><p>等待运行完成，此时文件夹中多了许多文件， 此时 Hexo 框架的本地搭建已经完成了。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0003.png"><p>我们来运行一下看看，命令行依次输入以下命令进行本地验证:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0004.png"><p>浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000</a> 或者 127.0.0.1:4000，可以看到一个网页，说明 Hexo 博客已经成功在本地运行。</p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol><li>hexo有各种各样风格的主题，笔者找了几十款，最终选的是<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a>这款主题。这款主题的文档写的是我见过的所有主题里最好的，风格也是我最喜欢的，并且作者更新频率也很高。</li><li>文档中已经有的部分我不再赘述，文档地址：<a href="https://butterfly.js.org/posts/21cfbf15/%E3%80%82**%E6%9C%AC%E7%AF%87%E6%96%87%E7%AB%A0%E5%8F%AA%E8%A1%A5%E5%85%85%E6%96%87%E6%A1%A3%E9%87%8C%E6%B2%A1%E6%9C%89%E8%AF%B4%E7%9A%84%E5%BE%88%E6%B8%85%E6%A5%9A%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%82">https://butterfly.js.org/posts/21cfbf15/。**本篇文章只补充文档里没有说的很清楚的地方。</a>**</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>对应:<a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a>   的<strong>安装</strong></p></blockquote><p>文档里说的是<code>在你的博客根目錄裏</code>，哪里是博客根目录呢？看图</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0005.png"/><p>在你的博客根目录，右键git bash here，输入文档中的命令即可。</p><p>运行完命令后，最终的效果是</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0006.png" /><p>你们这里可能有个landscape主题，是hexo的默认主题，就是你localhost:4000看到的那个风格，那个我已经删了，你想删就删不影响。</p><h3 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h3><blockquote><p>对应：<a href="https://butterfly.js.org/posts/4aa8abbe">https://butterfly.js.org/posts/4aa8abbe</a>   <strong>导航菜单</strong></p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line"><span class="attr">Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line"><span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line"><span class="string">List||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">  <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"><span class="attr">Link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line"><span class="attr">About:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>1、这里要强调的就是yaml的语法，空格缩进。以及这里的格式一定要严格按照文档的格式写，冒号，||这些不能错。</p><p>2、如果你想要导航栏是中文的，那就直接像我这样写成中文就行。后面的iconfont你不能按照我这样写，我的这里图标是自定义的，你没有自定义就会显示不出来效果。关于如何自定义图标在后面会讲</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-shouyex</span></span><br><span class="line">  <span class="string">找文章</span> <span class="string">||</span> <span class="attr">iconfont icon-zuixinwenzhang_huaban:</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-fenlei1</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-biaoqian1</span></span><br><span class="line">    <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-shijianzhou</span></span><br><span class="line">  <span class="string">生活</span> <span class="string">||</span> <span class="attr">iconfont icon-shenghuo:</span></span><br><span class="line">    <span class="string">留言板:</span> <span class="string">/messageboard/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-liaotian-04</span></span><br><span class="line">    <span class="string">友人帐:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-lianjie</span></span><br><span class="line">    <span class="string">分享:</span> <span class="string">/share/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-fenxiang</span></span><br><span class="line">    <span class="string">相册:</span> <span class="string">/gallery/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-xiangce</span></span><br><span class="line">    <span class="string">书籍:</span> <span class="string">/books/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-shuji</span></span><br><span class="line">    <span class="string">影视:</span> <span class="string">/FilmAndTV/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-yingshi1</span></span><br><span class="line">    <span class="string">导航站:</span> <span class="string">/daohang/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-daohang</span></span><br><span class="line">  <span class="string">关于笔者:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-gerenzhongxin</span></span><br></pre></td></tr></table></figure><p>最终的效果就是</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0007.jpg"><h3 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h3><blockquote><p>对应: <a href="https://butterfly.js.org/posts/ceeb73f">https://butterfly.js.org/posts/ceeb73f</a>   <strong>搜索系统</strong></p></blockquote><p>推荐本地搜索。本地搜索不仅要配置，还要安装<strong>插件</strong>，插件去这个插件的官网即可，文档给出了官网的地址。</p><h3 id="评论-twikoo"><a href="#评论-twikoo" class="headerlink" title="评论(twikoo)"></a>评论(twikoo)</h3><blockquote><p>官方文档写的也比较好，你可以对照着看，我的有部分和官方文档一样。我用的是<strong>手动部署</strong></p><p><a href="https://twikoo.js.org/quick-start.html">https://twikoo.js.org/quick-start.html</a></p></blockquote><p>1、进入<a href="https://curl.qcloud.com/KnnJtUom">云开发CloudBase </a>活动页面，滚动到“新用户专享”部分，选择适合的套餐（一般 0 元套餐即可），点击“立即购买”，按提示创建好环境。</p><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0008.png" alt="image-20210323145753348"></p><blockquote><p>提示</p><ul><li>推荐创建上海环境。如选择广州环境，需要在 <code>twikoo.init()</code> 时额外指定环境 <code>region: &quot;ap-guangzhou&quot;</code></li><li>环境名称自由填写</li><li>推荐选择计费方式<code>包年包月</code>，套餐版本<code>基础班 1</code>，超出免费额度不会收费</li><li>如果提示选择“应用模板”，请选择“空模板”</li></ul></blockquote><p>2、进入<a href="https://console.cloud.tencent.com/tcb/">云开发控制台</a>，可以看到下面的东西，这个就是你上一步创建的环境。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0009.png"/><p>3、进入<a href="https://console.cloud.tencent.com/tcb/env/login]">环境-登录授权</a>，启用“匿名登录”</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0010.png"/><p>4、点击安全配置，将网站域名添加到“WEB安全域名”</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0011.png"/><p>5、进入环境-云函数，点击“新建云函数”</p><p>6、函数名称请填写：<code>twikoo</code>，创建方式请选择：<code>空白函数</code>，运行环境请选择：<code>Nodejs 10.15</code>，函数内存请选择：<code>128MB</code>，点击“下一步”</p><p>7、清空输入框中的示例代码，复制以下代码、粘贴到“函数代码”输入框中，点击“确定”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.main = <span class="built_in">require</span>(<span class="string">&#x27;twikoo-func&#x27;</span>).main</span><br></pre></td></tr></table></figure><p>8、创建完成后，点击“twikoo”进入云函数详情页，进入“函数代码”标签，点击“文件 - 新建文件”，输入 <code>package.json</code>，回车</p><p>9、复制以下代码、粘贴到代码框中，点击“保存并安装依赖”</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;dependencies&quot;</span>: &#123; <span class="attr">&quot;twikoo-func&quot;</span>: <span class="string">&quot;1.3.0&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>10、最终效果</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0012.png" /><p>11、你只需要把获取到的 环境ID (envId) 填写到配置上去就行</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>12、开启评论</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Twikoo</span> </span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><p>13、本地部署看效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0013.png"/><h3 id="开启twikoo评论管理面板"><a href="#开启twikoo评论管理面板" class="headerlink" title="开启twikoo评论管理面板"></a>开启twikoo评论管理面板</h3><p>1、进入环境-登录授权 (opens new window)，点击“自定义登录”右边的“私钥下载”，下载私钥文件</p><p>2、用文本编辑器打开私钥文件，复制全部内容<br>3、点击评论窗口的“小齿轮”图标，粘贴私钥文件内容，并设置管理员密码</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0014.png"/><p>4、根据中文提示做一些设置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0015.png" /><h3 id="twikoo版本更新"><a href="#twikoo版本更新" class="headerlink" title="twikoo版本更新"></a>twikoo版本更新</h3><p>针对手动部署的更新方式</p><p>登录<a href="https://console.cloud.tencent.com/tcb/scf/index">环境-云函数 </a>，点击 twikoo，点击函数代码，打开 <code>package.json</code> 文件，将 <code>&quot;twikoo-func&quot;: &quot;x.x.x&quot;</code> 其中的版本号修改为最新版本号，点击“保存并安装依赖”即可。</p><h2 id="同时部署到Gitee和Github"><a href="#同时部署到Gitee和Github" class="headerlink" title="同时部署到Gitee和Github"></a>同时部署到Gitee和Github</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>安装发布的插件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="2"><li><p>分别在Gitee和Github创建对应的仓库，以笔者为例。</p><p>Gitee：笔者的用户名为youthlql，所以就创建一个<code>youthlql</code>同名仓库</p><p>Github: 笔者用户名为youthlql，创建仓库<code>youthlql.github.io</code></p></li><li><p>_config.yml</p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改的地方</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/youthlql/youthlql.git</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/youthlql/youthlql.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>_config.yml里还有个<code>url</code>需要修改，下面有说明怎么改。</p></li><li><p>博客根目录，Git bash运行以下命令</p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="Gitee避坑"><a href="#Gitee避坑" class="headerlink" title="Gitee避坑"></a>Gitee避坑</h3><p>这部分网上可以搜到一堆，就不细讲了。注意几个问题就行</p><p>1、如何创建一个首页访问地址不带二级目录的 pages，如ipvb.gitee.io？</p><p>答：如果你想你的 pages 首页访问地址不带二级目录，如ipvb.gitee.io，<strong>你需要建立一个与自己个性地址同名的仓库</strong>，如 <a href="https://gitee.com/ipvb">https://gitee.com/ipvb</a> 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以<code>ipvb.gitee.io</code>直接访问，那么他就可以创建一个名字为<code>ipvb</code>的仓库 <a href="https://gitee.com/ipvb/ipvb">https://gitee.com/ipvb/ipvb</a> 部署完成后，就可以以 <a href="https://ipvb.gitee.io/">https://ipvb.gitee.io</a> 进行访问了。</p><p>2、当要部署的项目与自己的个性地址不一致时，部署完成后存在一些资源访问404？</p><p>答：当需要部署的仓库和自己的个性地址不一致时，如：<a href="https://gitee.com/ipvb/blog">https://gitee.com/ipvb/blog</a> ，生成的pages url 为 <a href="https://ipvb.gitee.io/blog">https://ipvb.gitee.io/blog</a> ，而访问的资源404，如 <a href="https://ipvb.gitee.io/style.css">https://ipvb.gitee.io/style.css</a> 。这是因为相应配置文件的相对路径存在问题导致的，生成的资源 url 应该为 <a href="https://ipvb.gitee.io/blog/style.css">https://ipvb.gitee.io/blog/style.css</a> 才对。对于不同的静态资源生成器，配置如下：</p><ul><li>Hugo 配置文件<code>config.toml</code>的baseURL修改如下</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baseURL &#x3D; &quot;https:&#x2F;&#x2F;ipvb.gitee.io&#x2F;blog&quot;</span><br></pre></td></tr></table></figure><ul><li>Hexo 配置文件<code>_config.yml</code>的<code>url</code>和<code>root</code>修改如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;ipvb.gitee.io&#x2F;blog</span><br><span class="line">root: &#x2F;blog</span><br></pre></td></tr></table></figure><p>新版的hexo好像只需要写url了，_config.yml配置文件里注释说明</p><h3 id="开启Pages服务验证效果"><a href="#开启Pages服务验证效果" class="headerlink" title="开启Pages服务验证效果"></a>开启Pages服务验证效果</h3><p>1、gitee上传成功之后，需要手动点更新，然后访问<a href="https://youthlql.gitee.io/">https://youthlql.gitee.io</a>。你自己的地址是多少你就访问多少。</p><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0016.png" alt="image-20210323162200087"></p><p>gitee有时候点击更新会卡住很久，不要惊慌，这是gitee的服务器出了问题。</p><p>2、github</p><p>访问<code>youthlql.github.io</code>，注意种github.io地址有时候被dns污染，经常出现访问不了的情况。你可以选择自定义域名来访问，也可以选择只用gitee站点</p><h2 id="Github自定义域名"><a href="#Github自定义域名" class="headerlink" title="Github自定义域名"></a>Github自定义域名</h2><p>1、具体阿里云买域名解析啥的参考这篇文章：<a href="https://yafine-blog.cn/posts/4ab2.html%E3%80%82%E7%84%B6%E5%90%8E%E5%9C%A8%E4%BB%93%E5%BA%93%E7%9A%84settings">https://yafine-blog.cn/posts/4ab2.html。然后在仓库的settings</a> — 下方填入你的域名</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0017.png"/><p>2、为了避免每次部署完都需要重新绑定域名。解决方式很简单，在博客根目录的配置文件中找到 <code>skip_render</code> 字段，添加值<code>&#39;CNAME&#39;</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure><p>然后在 <code>/source</code> 的目录中创建一个文件，命名为 <code>CNAME</code>，里边的内容写你的域名。只写域名即可。例如 <code>imlql.cn</code>，不需要添加 <code>http(s)://</code></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0018.png"/><h2 id="推荐插件和配置"><a href="#推荐插件和配置" class="headerlink" title="推荐插件和配置"></a>推荐插件和配置</h2><h3 id="文章生成永久url连接"><a href="#文章生成永久url连接" class="headerlink" title="文章生成永久url连接"></a>文章生成永久url连接</h3><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><p>1、首先安装插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>2、然后改配置(_config.yml)</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改动的地方</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://youthlql.gitee.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure><h4 id="效果区别"><a href="#效果区别" class="headerlink" title="效果区别"></a>效果区别</h4><p>1、下面这个是默认的配置</p><p><code>permalink: :year/:month/:day/:title/</code>：(<a href="http://localhost:4000/2020/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/)%E3%80%82%E4%BD%86%E5%AE%9E%E9%99%85%E4%B8%8A%E4%BC%9A%E5%B0%86%E8%BF%99%E4%BA%9B%E4%B8%AD%E6%96%87%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5%E5%BE%88%E9%95%BF%E5%BE%88%E9%95%BF%E3%80%82%E5%B9%B6%E4%B8%94%E5%90%8E%E7%BB%AD%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9B%B4%E6%94%B9title%EF%BC%8C%E6%96%87%E7%AB%A0%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B0%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%EF%BC%8C%E5%90%84%E7%A7%8D%E6%96%87%E7%AB%A0%E7%9A%84%E9%98%85%E8%AF%BB%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%8C%E8%AF%84%E8%AE%BA%E7%BB%9F%E8%AE%A1%E5%85%A8%E9%83%BD%E4%BC%9A%E6%B6%88%E5%A4%B1%E3%80%82%E5%9B%A0%E4%B8%BA%E8%AF%84%E8%AE%BA%E5%92%8C%E9%98%85%E8%AF%BB%E6%95%B0%E7%BB%9F%E8%AE%A1%E5%A4%A7%E9%83%A8%E5%88%86%E9%83%BD%E6%98%AF%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84url%E9%93%BE%E6%8E%A5%E6%9D%A5%E7%BB%9F%E8%AE%A1%E7%9A%84">http://localhost:4000/2020/04/16/计算机网络-总结/)。但实际上会将这些中文进行编码，导致文章链接很长很长。并且后续如果你更改title，文章的链接就会发生变化，各种文章的阅读数统计，评论统计全都会消失。因为评论和阅读数统计大部分都是根据你的url链接来统计的</a></p><p>2、修改之后</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</span></span><br><span class="line">crc16 &amp; hex</span><br><span class="line">https://youthlql.gitee.io/posts/12e5.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://youthlql.gitee.io/posts/78585.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https://youthlql.gitee.io/posts/8df45468.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https://youthlql.gitee.io/posts/1258428496.html</span><br></pre></td></tr></table></figure><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p><strong>百度主动提交链接</strong></p><p>1、首先，在 Hexo 根目录下，安装本插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>2、然后在根目录下，把以下内容配置到<code>_config.yml</code> 文件中:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/youthlql/youthlql.git</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/youthlql/youthlql.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"><span class="comment"># 百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span>  <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span>  <span class="comment">## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>我把deploy配置也贴出来是因为有两个type，注意用<code>-</code>区分</p><p>百度其它的seo到他的官网看文档就行</p><h3 id="中文转拼音插件"><a href="#中文转拼音插件" class="headerlink" title="中文转拼音插件"></a>中文转拼音插件</h3><p>安装下面的插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure><p>站点根目录设置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span>   <span class="comment"># default: &#x27;-&#x27;链接符</span></span><br></pre></td></tr></table></figure><h2 id="又拍云CDN全站加速"><a href="#又拍云CDN全站加速" class="headerlink" title="又拍云CDN全站加速"></a>又拍云CDN全站加速</h2><p>笔者看的这个教程：<a href="https://www.heson10.com/posts/30982.html">https://www.heson10.com/posts/30982.html</a></p><h2 id="jsDelivr-Github做图床"><a href="#jsDelivr-Github做图床" class="headerlink" title="jsDelivr+Github做图床"></a>jsDelivr+Github做图床</h2><p><a href="https://www.heson10.com/posts/18256.html">https://www.heson10.com/posts/18256.html</a></p><p>关于格式的说明: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;GitHub用户名&#x2F;仓库名@release版本号&#x2F;文件</span><br><span class="line">或是</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;GitHub用户名&#x2F;仓库名&#x2F;文件</span><br><span class="line">或是</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;GitHub用户名&#x2F;仓库名@master&#x2F;文件</span><br></pre></td></tr></table></figure><p>jsd的官方文档说: 一个仓库或者一个release版本不能超过50MB</p><blockquote><p>Packages larger than 50 MB or single files larger than 20 MB (in case of GitHub) are not supported by default. We recommend removing files that are not needed from your package when possible. If you need to set a higher limit for your package, open an issue in this repo.</p></blockquote><p>如果超过50mb，访问图片会出现这样的错误<strong>Package size exceeded the configured limit of 50 MB.</strong></p><p>1、笔者推荐采用版本号的url链接，这种链接目前是最稳定的。另外两种有时候会404，虽然说过几天自己就好了，但是毕竟影响体验。</p><p>2、Github的图床仓库不要创建太多，创建太多会被Github检测到，后果就是你的图床仓库会被强制删除(虽然几率很小很小，但是butterfly群里有两个人遇到过)。所以我推荐版本号的原因也在这里，发布版本之后就可以把以前的图片删掉，永远保持图床仓库只有一个。</p><p>3、github不要注册小号，不要说你用小号做图床，注册小号过多的后果如下</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0019.png" /><p>简单来说就是账号被永封。</p><h2 id="Typora集成PicGo"><a href="#Typora集成PicGo" class="headerlink" title="Typora集成PicGo"></a>Typora集成PicGo</h2><h3 id="PicGo-设置"><a href="#PicGo-设置" class="headerlink" title="PicGo 设置"></a>PicGo 设置</h3><ol><li><p>PicGo 的版本必须是 2.2.0 及以上。</p></li><li><p>激活 PicGo-Server</p><p>打开 PicGo 详细页面，进入 PicGo 设置–设置 Server</p><p><strong>这里的监听地址就是默认的 127.0.0.1，端口修改为 36677</strong>，否则会上传失败。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0020.png"/></li></ol><h3 id="Typora-配置"><a href="#Typora-配置" class="headerlink" title="Typora 配置"></a>Typora 配置</h3><p>对于 Typora 也是有版本要求的，大家也看到了，这个功能是 0.9.84 才加入的，所以 Typora 的版本也得是 0.9.84 及以上。</p><ol><li>Typora 版本 0.9.84 及以上。</li><li>设置（左上角文件 -&gt; 偏好设置 -&gt; 图像）</li><li>然后左下角有一个验证上传，一般情况下这里就已经好了。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0021.png"/><h2 id="Diy美化部分"><a href="#Diy美化部分" class="headerlink" title="Diy美化部分"></a>Diy美化部分</h2><blockquote><p>1、笔者的diy美化全是采用外挂css，js的方式，不修改源码便于升级。</p><p>2、diy部分参考小康，乐特，aki大佬</p></blockquote><h3 id="页面简单美化"><a href="#页面简单美化" class="headerlink" title="页面简单美化"></a>页面简单美化</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.每一个不同地方的css会空两行</span></span><br><span class="line"><span class="comment">2.参考: https://www.antmoe.com/posts/a811d614/</span></span><br><span class="line"><span class="comment">  https://butterfly.lete114.top/article/Butterfly-config.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版权链接去掉下划线 */</span></span><br><span class="line"><span class="selector-class">.layout_post</span> <span class="selector-class">.post-copyright</span> <span class="selector-class">.post-copyright-info</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 博主昵称颜色 --也就是首页侧边栏头像下面那个昵称*/</span></span><br><span class="line"><span class="selector-class">.author-info__name</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#BA55D3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 页脚透明 */</span></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首页中间打字效果上方 */</span></span><br><span class="line"><span class="selector-id">#page-header</span> <span class="selector-id">#site_title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#80bdab</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顶部导航栏 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f9f2f4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*页脚自定义字段字体颜色,也就是配置文件里的footer_custom_text*/</span></span><br><span class="line"><span class="selector-class">.footer_custom_text</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#EEEEEE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标样式*/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur</span>),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur</span>),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚动条 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  width: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  background-color: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  background-color: <span class="number">#49b1f5</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">    transparent <span class="number">75%</span>,</span><br><span class="line">    transparent</span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">  background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">  color: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* a标签默认颜色 */</span></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标悬停时的颜色 */</span></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e58a8a</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*a标签颜色*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*文章顶部图透明*/</span></span><br><span class="line"><span class="selector-id">#page-header</span> &#123;</span><br><span class="line">     <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#page-header</span><span class="selector-class">.post-bg</span>:before &#123;</span><br><span class="line">     position: absolute;</span><br><span class="line">     <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">display</span>: block;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">background</span>: transparent <span class="meta">!important</span>; <span class="comment">/*这个rgba可以自己改*/</span></span><br><span class="line">     <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------下面是暂时用不到的css样式--------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义字体，暂时用不到先注释掉*/</span></span><br><span class="line"><span class="comment">/* @font-face &#123;</span></span><br><span class="line"><span class="comment">    font-family: &#x27;mycustom_font&#x27;;</span></span><br><span class="line"><span class="comment">    src: url(&#x27;https://cdn.jsdelivr.net/gh/youthlql/static/font/chun_feng_kai.ttf&#x27;);</span></span><br><span class="line"><span class="comment">font-size: 16px;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="页面随机全屏背景"><a href="#页面随机全屏背景" class="headerlink" title="页面随机全屏背景"></a>页面随机全屏背景</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随机背景图片数组,图片可以换成图床链接，注意最后一条后面不要有逗号</span></span><br><span class="line"><span class="keyword">var</span> backimg =[</span><br><span class="line">  <span class="string">&quot;url()&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url()&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url(https://gitee.com/youthlql/randombg/raw/master/bg/00184.webp)&quot;</span>  </span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">//获取背景图片总数，生成随机数</span></span><br><span class="line">  <span class="keyword">var</span> bgindex =<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * (backimg.length-<span class="number">1</span>));</span><br><span class="line">  <span class="comment">//重设背景图片</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;web_bg&quot;</span>).style.backgroundImage = backimg[bgindex];</span><br><span class="line">  <span class="comment">//重设banner图片</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;page-header&quot;</span>).style.backgroundImage = backimg[bgindex];</span><br></pre></td></tr></table></figure><p>url()内填写图片地址</p><h3 id="阿里自定义图标"><a href="#阿里自定义图标" class="headerlink" title="阿里自定义图标"></a>阿里自定义图标</h3><p>先看效果</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0007.jpg"/><p><a href="https://www.iconfont.cn/home/index">阿里图标库</a></p><p>1、搜索图标然后加入你的项目</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0022.png" /><p>2、访问你的那个链接，然后将代码复制到你自己的css文件里，然后像这样给其设置颜色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon-shuji</span>:before &#123;</span><br><span class="line">  content: <span class="string">&quot;\e609&quot;</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#59AAFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、font class和unicode只能设置单色，想设置多色图标很麻烦，需要修改源码。需要的请联系aki大佬，大佬此篇文章博客：<a href="https://akilar.top/posts/e2bf861f/%E3%80%82%E4%B8%8D%E8%BF%87%E6%AD%A4%E7%AF%87%E5%8D%9A%E5%AE%A2%E4%BE%9D%E7%84%B6%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%89%B2%E5%9B%BE%E6%A0%87%EF%BC%8C%E6%AD%A4%E7%AF%87%E5%8D%9A%E5%AE%A2%E5%8F%AA%E8%83%BD%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%89%B2%E5%9B%BE%E7%89%87%EF%BC%8C%E5%9B%BE%E7%89%87%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E7%94%A8svg%E5%8D%B3%E5%8F%AF%E3%80%82%E6%83%B3%E8%A6%81%E6%8A%98%E8%85%BE%E7%9A%84%E5%8A%A0%E5%A4%A7%E4%BD%ACqq%E7%BE%A4%EF%BC%9A674527148">https://akilar.top/posts/e2bf861f/。不过此篇博客依然无法设置多色图标，此篇博客只能设置多色图片，图片可以直接用svg即可。想要折腾的加大佬qq群：674527148</a></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0023.png"><p>4、最后把你的css和js引入到配置文件中，如何引入请看官方文档：<a href="https://butterfly.js.org/posts/ceeb73f/#Inject">https://butterfly.js.org/posts/ceeb73f/#Inject</a></p><h3 id="站长之家统计"><a href="#站长之家统计" class="headerlink" title="站长之家统计"></a>站长之家统计</h3><p><strong>效果</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0024.png"/><p><strong>步骤</strong></p><p>1、<a href="https://www.umeng.com/">https://www.umeng.com/</a> ，点击网站统计–立即使用</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Hexo/build/0025.png"/><p>2、点击统计代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;https://v1.cnzz.com/z_stat.php?xxxxxxxxxxxxxxx&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>将<strong>你自己的</strong>这份代码插入到配置文件中的inject位置(跟上面的阿里图标一样)</p><p>3、复制下方的<strong>横排数据显示</strong>代码到 <code>custom_text</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2020</span></span><br><span class="line">  <span class="attr">custom_text:</span> </span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apollo简单入门</title>
      <link href="post/10d32fba.html"/>
      <url>post/10d32fba.html</url>
      
        <content type="html"><![CDATA[<h1 id="Apollo简单入门"><a href="#Apollo简单入门" class="headerlink" title="Apollo简单入门"></a>Apollo简单入门</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>1）理解配置中心的概念以及使用场景</p><p>2）了解主流配置中心</p><p>3）理解Apollo的功能特性</p><p>4）掌握Apollo的快速入门方法</p><p>5） 理解Apollo的工作原理</p><p>6）能够安装Apollo</p><p>8）理解Apollo的核心概念</p><p>9）掌握Apollo的项目管理方法</p><p>9）掌握Apollo的配置管理方法</p><p>10）掌握Apollo集群管理方法</p><p>11）理解Apollo的配置发布原理</p><p>12）掌握SpringBoot 集成Apollo的使用方法</p><p>13）掌握Apollo生产环境的部署方法</p><p>14）掌握Apollo灰度发布的方法</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="什么是配置"><a href="#什么是配置" class="headerlink" title="什么是配置"></a>什么是配置</h3><p>应用程序在启动和运行的时候往往需要读取一些配置信息，配置基本上伴随着应用程序的整个生命周期，比如：数据库连接参数、启动参数等。</p><p>配置主要有以下几个特点：</p><ul><li><strong>配置是独立于程序的只读变量</strong><ul><li>  配置首先是独立于程序的，同一份程序在不同的配置下会有不同的行为</li><li>  其次，配置对于程序是只读的，程序通过读取配置来改变自己的行为，但是程序不应该去改变配置</li></ul></li><li><strong>配置伴随应用的整个生命周期</strong><ul><li>  配置贯穿于应用的整个生命周期，应用在启动时通过读取配置来初始化，在运行时根据配置调整行为。比如：启动时需要读取服务的端口号、系统在运行过程中需要读取定时策略执行定时任务等。</li></ul></li><li><strong>配置可以有多种加载方式</strong><ul><li>  常见的有程序内部硬编码，配置文件，环境变量，启动参数，基于数据库等</li></ul></li><li><strong>配置需要治理</strong><ul><li>  权限控制：由于配置能改变程序的行为，不正确的配置甚至能引起灾难，所以对配置的修改必须有比较完善的权限控制</li><li>  不同环境、集群配置管理：同一份程序在不同的环境（开发，测试，生产）、不同的集群（如不同的数据中心）经常需要有不同的配置，所以需要有完善的环境、集群配置管理</li></ul></li></ul><h3 id="什么是配置中心"><a href="#什么是配置中心" class="headerlink" title="什么是配置中心"></a>什么是配置中心</h3><p> 传统单体应用存在一些潜在缺陷，如随着规模的扩大，部署效率降低，团队协作效率差，系统可靠性变差，维护困难，新功能上线周期长等，所以迫切需要一种新的架构去解决这些问题，而微服务（ microservices ）架构正是当下一种流行的解法。</p><p> 不过，解决一个问题的同时，往往会诞生出很多新的问题，所以微服务化的过程中伴随着很多的挑战，其中一个挑战就是有关服务（应用）配置的。当系统从一个单体应用，被拆分成分布式系统上一个个服务节点后，配置文件也必须跟着迁移（分割），这样配置就分散了，不仅如此，分散中还包含着冗余，如下图：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0001.png"/><p>配置中心将配置从应用中剥离出来，统一管理，优雅的解决了配置的动态变更、持久化、运维成本等问题。</p><p>应用自身既不需要去添加管理配置接口，也不需要自己去实现配置的持久化，更不需要引入“定时任务”以便降低运维成本。</p><p> <strong>总得来说，配置中心就是一种统一管理各种应用配置的基础服务组件。</strong></p><p> 在系统架构中，配置中心是整个微服务基础架构体系中的一个组件，如下图，它的功能看上去并不起眼，无非就是配置的管理和存取，但它是整个微服务架构中不可或缺的一环。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0002.jpg"/><p> 集中管理配置，那么就要将应用的配置作为一个单独的服务抽离出来了，同理也需要解决新的问题，比如：版本管理（为了支持回滚），权限管理等。</p><p> 总结一下，在传统巨型单体应用纷纷转向细粒度微服务架构的历史进程中，配置中心是微服务化不可缺少的一个系统组件，在这种背景下中心化的配置服务即配置中心应运而生，一个合格的配置中心需要满足：</p><ul><li>配置项容易读取和修改</li><li>添加新配置简单直接</li><li>支持对配置的修改的检视以把控风险</li><li>可以查看配置修改的历史记录</li><li>不同部署环境支持隔离</li></ul><h2 id="Apollo简介"><a href="#Apollo简介" class="headerlink" title="Apollo简介"></a>Apollo简介</h2><h3 id="主流配置中心"><a href="#主流配置中心" class="headerlink" title="主流配置中心"></a>主流配置中心</h3><p>目前市面上用的比较多的配置中心有：（按开源时间排序）</p><ol><li><p>Disconf</p><p>2014年7月百度开源的配置管理中心，专注于各种「分布式系统配置管理」的「通用组件」和「通用平台」, 提供统一的「配置管理服务」。目前已经不再维护更新。</p><p><a href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a></p></li><li><p>Spring Cloud Config</p><p>2014年9月开源，Spring Cloud 生态组件，可以和Spring Cloud体系无缝整合。</p><p><a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a></p></li><li><p>Apollo</p><p>2016年5月，携程开源的配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p><p><a href="https://github.com/ctripcorp/apollo">https://github.com/ctripcorp/apollo</a></p></li><li><p>Nacos</p><p>2018年6月，阿里开源的配置中心，也可以做DNS和RPC的服务发现。</p><p><a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p></li></ol><h4 id="功能特性对比"><a href="#功能特性对比" class="headerlink" title="功能特性对比"></a>功能特性对比</h4><p>由于Disconf不再维护，下面主要对比一下Spring Cloud Config、Apollo和Nacos。</p><table><thead><tr><th>功能点</th><th>Spring Cloud Config</th><th>Apollo</th><th>Nacos</th></tr></thead><tbody><tr><td>配置实时推送</td><td>支持(Spring Cloud Bus)</td><td>支持(HTTP长轮询1s内)</td><td>支持(HTTP长轮询1s内)</td></tr><tr><td>版本管理</td><td>支持(Git)</td><td>支持</td><td>支持</td></tr><tr><td>配置回滚</td><td>支持(Git)</td><td>支持</td><td>支持</td></tr><tr><td>灰度发布</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>权限管理</td><td>支持(依赖Git)</td><td>支持</td><td>不支持</td></tr><tr><td>多集群</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>多环境</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>监听查询</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>多语言</td><td>只支持Java</td><td>主流语言，提供了Open API</td><td>主流语言，提供了Open API</td></tr><tr><td>配置格式校验</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>单机读(QPS)</td><td>7(限流所致)</td><td>9000</td><td>15000</td></tr><tr><td>单击写(QPS)</td><td>5(限流所致)</td><td>1100</td><td>1800</td></tr><tr><td>3节点读(QPS)</td><td>21(限流所致)</td><td>27000</td><td>45000</td></tr><tr><td>3节点写(QPS)</td><td>5限流所致()</td><td>3300</td><td>5600</td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来看，Apollo和Nacos相对于Spring Cloud Config的生态支持更广，在配置管理流程上做的更好。Apollo相对于Nacos在配置管理做的更加全面，Nacos则使用起来相对比较简洁，在对性能要求比较高的大规模场景更适合。但对于一个开源项目的选型，项目上的人力投入（迭代进度、文档的完整性）、社区的活跃度（issue的数量和解决速度、Contributor数量、社群的交流频次等），这些因素也比较关键，考虑到Nacos开源时间不长和社区活跃度，所以从目前来看Apollo应该是最合适的配置中心选型。</p><h3 id="Apollo简介-1"><a href="#Apollo简介-1" class="headerlink" title="Apollo简介"></a>Apollo简介</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0003.png"/><p><strong>Apollo - A reliable configuration management system</strong></p><p><a href="https://github.com/ctripcorp/apollo">https://github.com/ctripcorp/apollo</a></p><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用的不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p><p>Apollo包括服务端和客户端两部分：</p><p>服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。</p><p>Java客户端不依赖任何框架，能够运行于所有Java运行时环境，同时对Spring/Spring Boot环境也有较好的支持。</p><h3 id="Apollo特性"><a href="#Apollo特性" class="headerlink" title="Apollo特性"></a>Apollo特性</h3><p>基于配置的特殊性，所以Apollo从设计之初就立志于成为一个有治理能力的配置发布平台，目前提供了以下的特性：</p><ul><li><strong>统一管理不同环境、不同集群的配置</strong><ul><li>  Apollo提供了一个统一界面集中式管理不同环境（environment）、不同集群（cluster）、不同命名空间（namespace）的配置。</li><li>  同一份代码部署在不同的集群，可以有不同的配置，比如zookeeper的地址等</li><li>  通过命名空间（namespace）可以很方便地支持多个不同应用共享同一份配置，同时还允许应用对共享的配置进行覆盖</li></ul></li><li><strong>配置修改实时生效（热发布）</strong><ul><li>  用户在Apollo修改完配置并发布后，客户端能实时（1秒）接收到最新的配置，并通知到应用程序</li></ul></li><li><strong>版本发布管理</strong><ul><li>  所有的配置发布都有版本概念，从而可以方便地支持配置的回滚</li></ul></li><li><strong>灰度发布</strong><ul><li>  支持配置的灰度发布，比如点了发布后，只对部分应用实例生效，等观察一段时间没问题后再推给所有应用实例</li></ul></li><li><strong>权限管理、发布审核、操作审计</strong><ul><li>  应用和配置的管理都有完善的权限管理机制，对配置的管理还分为了编辑和发布两个环节，从而减少人为的错误。</li><li>  所有的操作都有审计日志，可以方便地追踪问题</li></ul></li><li><strong>客户端配置信息监控</strong><ul><li>  可以在界面上方便地看到配置在被哪些实例使用</li></ul></li><li><strong>提供Java和.Net原生客户端</strong><ul><li>  提供了Java和.Net的原生客户端，方便应用集成</li><li>  支持Spring Placeholder, Annotation和Spring Boot的ConfigurationProperties，方便应用使用（需要Spring 3.1.1+）</li><li>  同时提供了Http接口，非Java和.Net应用也可以方便地使用</li></ul></li><li><strong>提供开放平台API</strong><ul><li>  Apollo自身提供了比较完善的统一配置管理界面，支持多环境、多数据中心配置管理、权限、流程治理等特性。不过Apollo出于通用性考虑，不会对配置的修改做过多限制，只要符合基本的格式就能保存，不会针对不同的配置值进行针对性的校验，如数据库用户名、密码，Redis服务地址等</li><li>  对于这类应用配置，Apollo支持应用方通过开放平台API在Apollo进行配置的修改和发布，并且具备完善的授权和权限控制</li></ul></li></ul><h2 id="Apollo快速入门"><a href="#Apollo快速入门" class="headerlink" title="Apollo快速入门"></a>Apollo快速入门</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0004.png"/><p>操作流程如下：</p><p>1、在Apollo配置中心修改配置</p><p>2、应用程序通过Apollo客户端从配置中心拉取配置信息</p><p> 用户通过Apollo配置中心修改或发布配置后，会有两种机制来保证应用程序来获取最新配置：一种是Apollo配置中心会向客户端推送最新的配置；另外一种是Apollo客户端会定时从Apollo配置中心拉取最新的配置，通过以上两种机制共同来保证应用程序能及时获取到配置。</p><h3 id="安装Apollo"><a href="#安装Apollo" class="headerlink" title="安装Apollo"></a>安装Apollo</h3><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><p>Java</p><ul><li>  Apollo服务端：1.8+</li><li>  Apollo客户端：1.7+</li></ul><p>由于需要同时运行服务端和客户端，所以建议安装Java 1.8+。</p><p>MySQL</p><ul><li>  版本要求：5.6.5+</li></ul><p>Apollo的表结构对<code>timestamp</code>使用了多个default声明，所以需要5.6.5以上版本。</p><h4 id="下载配置"><a href="#下载配置" class="headerlink" title="下载配置"></a>下载配置</h4><ol><li><p>访问Apollo的官方主页获取安装包（我自己学习使用的是1.3版本）：</p><p><a href="https://github.com/ctripcorp/apollo/tags">https://github.com/ctripcorp/apollo/tags</a></p></li></ol><ol start="2"><li>打开1.3发布链接，下载必须的安装包：<a href="https://github.com/ctripcorp/apollo/releases/tag/v1.3.0">https://github.com/ctripcorp/apollo/releases/tag/v1.3.0</a>。三个都要下</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0005.png"/><p>解压安装包后将apollo-configservice-1.3.0.jar, apollo-adminservice-1.3.0.jar, apollo-portal-1.3.0.jar放置于apollo目录下</p><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>Apollo服务端共需要两个数据库：<code>ApolloPortalDB</code>和<code>ApolloConfigDB</code>，ApolloPortalDB只需要在生产环境部署一个即可，<strong>而ApolloConfigDB需要在每个环境部署一套。</strong></p><ol><li><p>创建ApolloPortalDB，sql脚本下载地址：<a href="https://github.com/ctripcorp/apollo/blob/v1.3.0/scripts/db/migration/configdb/V1.0.0__initialization.sql">https://github.com/ctripcorp/apollo/blob/v1.3.0/scripts/db/migration/configdb/V1.0.0__initialization.sql</a></p><p>以MySQL原生客户端为例：推荐用Navicat直接导入此sql即可</p><pre><code>source apollo/ApolloPortalDB__initialization.sql</code></pre></li><li><p>验证ApolloPortalDB</p><p>导入成功后，可以通过执行以下sql语句来验证：</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> `Id`, `Key`, `<span class="keyword">Value</span>`, `Comment` <span class="keyword">from</span> `ApolloPortalDB`.`ServerConfig` limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：ApolloPortalDB只需要在生产环境部署一个即可</p></blockquote><ol start="3"><li><p>创建ApolloConfigDB，sql脚本下载地址：<a href="https://github.com/ctripcorp/apollo/blob/v1.3.0/scripts/db/migration/configdb/V1.0.0__initialization.sql">https://github.com/ctripcorp/apollo/blob/v1.3.0/scripts/db/migration/configdb/V1.0.0__initialization.sql</a></p><p>以MySQL原生客户端为例：</p><pre><code>source apollo/ApolloConfigDB__initialization.sql</code></pre></li><li><p>验证ApolloConfigDB</p><p>导入成功后，可以通过执行以下sql语句来验证：</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> `Id`, `Key`, `<span class="keyword">Value</span>`, `Comment` <span class="keyword">from</span> `ApolloConfigDB`.`ServerConfig` limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="启动Apollo"><a href="#启动Apollo" class="headerlink" title="启动Apollo"></a>启动Apollo</h4><p><strong>方法一</strong></p><ol><li><p>确保端口未被占用</p><p><strong>Apollo默认会启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用</strong></p></li><li><p>启动apollo-configservice，在apollo目录下执行如下命令</p><p>可通过-Dserver.port=8080修改默认端口</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xms256m -Xmx256m -Dspring.datasource.url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=root -Dspring.datasource.password=pbteach0430 -jar apollo-configservice-1.3.0.jar</span><br></pre></td></tr></table></figure><ol start="3"><li><p>启动apollo-adminservice</p><p>可通过-Dserver.port=8090修改默认端口</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xms256m -Xmx256m -Dspring.datasource.url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=root -Dspring.datasource.password=pbteach0430 -jar apollo-adminservice-1.3.0.jar</span><br></pre></td></tr></table></figure><ol start="4"><li><p>启动apollo-portal</p><p>可通过-Dserver.port=8070修改默认端口</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xms256m -Xmx256m -Ddev_meta=http://localhost:8080/ -Dserver.port=8070 -Dspring.datasource.url=jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8 -Dspring.datasource.username=root -Dspring.datasource.password=pbteach0430 -jar apollo-portal-1.3.0.jar</span><br></pre></td></tr></table></figure><p><strong>方法2</strong></p><ol><li><p>也可以使用提供的runApollo.bat快速启动三个服务（修改数据库连接地址，数据库以及密码）</p><pre><code>&lt;img src=&quot;https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0006.png&quot;/&gt;</code></pre><p> 这里面是一个很简单的脚本</p> <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0007.png" /></li></ol><p>具体代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> url=<span class="string">&quot;localhost:3306&quot;</span></span><br><span class="line"><span class="built_in">set</span> username=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="built_in">set</span> password=<span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">start <span class="string">&quot;configService&quot;</span> java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\logs\apollo-configservice.log -jar .\apollo-configservice-1.3.0.jar</span><br><span class="line">start <span class="string">&quot;adminService&quot;</span> java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\logs\apollo-adminservice.log -jar .\apollo-adminservice-1.3.0.jar</span><br><span class="line">start <span class="string">&quot;ApolloPortal&quot;</span> java -Xms256m -Xmx256m -Dapollo_profile=github,auth -Ddev_meta=http://localhost:8080/ -Dserver.port=8070 -Dspring.datasource.url=jdbc:mysql://%url%/ApolloPortalDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\logs\apollo-portal.log -jar .\apollo-portal-1.3.0.jar</span><br></pre></td></tr></table></figure><ol><li> 运行runApollo.bat即可启动Apollo</li><li> 待启动成功后，访问<a href="http://localhost:8070/">管理页面</a>,初始用户名： apollo，初始密码：admin</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h4><ol><li> 打开<a href="http://localhost:8070/">apollo</a> ：新建项目apollo-quickstart</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0008.png" /><ol start="2"><li>新建配置项sms.enable</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0009.png" /><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0010.png" /><p>确认提交配置项</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0011.png"/><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0012.png" alt="image-20201228102339176"></p><ol start="3"><li>发布配置项</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0013.png" /><h4 id="应用读取配置"><a href="#应用读取配置" class="headerlink" title="应用读取配置"></a>应用读取配置</h4><p>1、新建Maven工程</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.pbteach&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apollo-quickstart&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;apollo-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.28&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>2、编写测试类GetConfigTest</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetConfigTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VM options:</span></span><br><span class="line"><span class="comment">// -Dapp.id=apollo-quickstart -Denv=DEV -Ddev_meta=http://localhost:8080</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Config config = ConfigService.getAppConfig();</span><br><span class="line">String someKey = <span class="string">&quot;sms.enable&quot;</span>;</span><br><span class="line">String value = config.getProperty(someKey, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sms.enable: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试</p><p>配置VM options，设置系统属性：</p><pre><code>-Dapp.id=apollo-quickstart -Denv=DEV -Ddev_meta=http://localhost:8080</code></pre><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0014.png" /><p>运行GetConfigTest，打开控制台，观察输出结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sma.enable: true</span><br></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><ol><li> 到管理页面修改sms.enable的值为false，再运行GetConfigTest，可以看到输出结果已为false</li></ol><h4 id="热发布"><a href="#热发布" class="headerlink" title="热发布"></a>热发布</h4><ol><li> 修改代码为每3秒获取一次</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetConfigTest</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           Config config = ConfigService.getAppConfig();</span><br><span class="line">           String someKey = <span class="string">&quot;sms.enable&quot;</span>;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               String value = config.getProperty(someKey, <span class="keyword">null</span>);</span><br><span class="line">               System.out.printf(<span class="string">&quot;now: %s, sms.enable: %s%n&quot;</span>, LocalDateTime.now().toString(), value);</span><br><span class="line">               Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>运行GetConfigTest观察输出结果</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0015.png"/><ol start="3"><li>在Apollo管理界面修改配置项</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0016.png"/><ol start="4"><li>发布配置</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0017.png"/><ol start="5"><li>在控制台查看详细情况：可以看到程序获取的sms.enable的值已由false变成了修改后的true</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0018.png" /><h2 id="Apollo应用"><a href="#Apollo应用" class="headerlink" title="Apollo应用"></a>Apollo应用</h2><h3 id="Apollo工作原理"><a href="#Apollo工作原理" class="headerlink" title="Apollo工作原理"></a>Apollo工作原理</h3><p>下图是Apollo架构模块的概览</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0019.png" /><h4 id="各模块职责"><a href="#各模块职责" class="headerlink" title="各模块职责"></a>各模块职责</h4><p>上图简要描述了Apollo的总体设计，我们可以从下往上看：</p><ul><li>  Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端</li><li>  Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）</li><li>  Eureka提供服务注册和发现，为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的</li><li>  Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳</li><li>  在Eureka之上架了一层Meta Server用于封装Eureka的服务发现接口</li><li>  Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试</li><li>  Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试</li><li>  为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</li></ul><h4 id="分步执行流程"><a href="#分步执行流程" class="headerlink" title="分步执行流程"></a>分步执行流程</h4><ol><li> Apollo启动后，Config/Admin Service会自动注册到Eureka服务注册中心，并定期发送保活心跳。</li><li> Apollo Client和Portal管理端通过配置的Meta Server的域名地址经由Software Load Balancer(软件负载均衡器)进行负载均衡后分配到某一个Meta Server</li><li> Meta Server从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client</li><li> Meta Server获取Config Service和Admin Service（IP+Port）失败后会进行重试</li><li> 获取到正确的Config Service和Admin Service的服务信息后，Apollo Client通过Config Service为应用提供配置获取、实时更新等功能；Apollo Portal管理端通过Admin Service提供配置新增、修改、发布等功能</li></ol><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol><li> <strong>application (应用)</strong></li></ol><p>这个很好理解，就是实际使用配置的应用，Apollo客户端在运行时需要知道当前应用是谁，从而可以去获取对应的配置</p><p><strong>关键字：appId</strong></p><ol start="2"><li><strong>environment (环境)</strong></li></ol><p>配置对应的环境，Apollo客户端在运行时需要知道当前应用处于哪个环境，从而可以去获取应用的配置</p><p><strong>关键字：env</strong></p><ol start="3"><li><strong>cluster (集群)</strong></li></ol><p>一个应用下不同实例的分组，比如典型的可以<strong>按照数据中心分</strong>，把上海机房的应用实例分为一个集群，把北京机房的应用实例分为另一个集群。</p><p><strong>关键字：cluster</strong></p><ol start="4"><li><strong>namespace (命名空间)</strong></li></ol><p>一个应用下不同配置的分组，可以简单地把namespace类比为文件，不同类型的配置存放在不同的文件中，如数据库配置文件，RPC配置文件，应用自身的配置文件等</p><p><strong>关键字：namespaces</strong></p><p>它们的关系如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0020.png"/><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><h4 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h4><ol><li> 部门管理</li></ol><p>apollo 默认部门有两个。要增加自己的部门，可在系统参数中修改：</p><ul><li>  进入系统参数设置</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0021.png"/><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0022.png" alt="image-20201228103939300"></p><ul><li>输入key查询已存在的部门设置：organizations  <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0023.png" />  </li><li>修改value值来添加新部门，下面添加一个微服务部门：  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">&quot;orgId&quot;</span>:<span class="string">&quot;TEST1&quot;</span>,<span class="attr">&quot;orgName&quot;</span>:<span class="string">&quot;样例部门1&quot;</span>&#125;,&#123;<span class="attr">&quot;orgId&quot;</span>:<span class="string">&quot;TEST2&quot;</span>,<span class="attr">&quot;orgName&quot;</span>:<span class="string">&quot;样例部门2&quot;</span>&#125;,&#123;<span class="attr">&quot;orgId&quot;</span>:<span class="string">&quot;micro_service&quot;</span>,<span class="attr">&quot;orgName&quot;</span>:<span class="string">&quot;微服务部门&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>添加用户</li></ol><p>apollo默认提供一个超级管理员: apollo，可以自行添加用户</p><ul><li>  新建用户张三</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0024.png"/><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0025.png" /><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ol><li>打开apollo-portal主页：<a href="http://localhost:8070/">http://localhost:8070/</a></li><li>点击“创建项目”：account-service</li></ol><ol start="3"><li>输入项目信息<ul><li>  部门：选择应用所在的部门</li><li>  应用AppId：用来标识应用身份的唯一id，格式为string，需要和项目配置文件applications.properties中配置的app.id对应</li><li>  应用名称：应用名，仅用于界面展示</li><li>  应用负责人：选择的人默认会成为该项目的管理员，具备项目权限管理、集群创建、Namespace创建等权限</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0026.png" /><ol start="4"><li>点击提交,创建成功后，会自动跳转到项目首页</li></ol><ol><li>赋予之前添加的用户张三管理account-service服务的权限<ul><li>  使用管理员apollo将指定项目授权给用户张三</li></ul> <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0027.png"/>  *   将修改和发布权限都授权给张三  *   使用zhangsan登录，查看项目配置  *   点击account-service即可管理配置</li></ol><h4 id="删除项目"><a href="#删除项目" class="headerlink" title="删除项目"></a>删除项目</h4><p>如果要删除整个项目，点击右上角的“管理员工具–》删除应用、集群…”</p><p>首先查询出要删除的项目，点击“删除应用”</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>下边在account-service项目中进行配置。</p><h4 id="添加发布配置项"><a href="#添加发布配置项" class="headerlink" title="添加发布配置项"></a>添加发布配置项</h4><ol><li><p> 通过表格模式添加配置，点击新增配置，输入配置项：sms.enable，点击提交即可。</p></li><li><p>通过文本模式编辑，Apollo除了支持表格模式，逐个添加、修改配置外，还提供文本模式批量添加、修改。 这个对于从已有的properties文件迁移尤其有用</p><ul><li>切换到文本编辑模式</li><li>输入配置项，并点击提交修改</li></ul></li><li><p>发布配置</p></li></ol><h4 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h4><ol><li> 找到对应的配置项，点击修改</li><li> 修改为需要的值，点击提交</li><li> 发布配置</li></ol><h4 id="删除配置"><a href="#删除配置" class="headerlink" title="删除配置"></a>删除配置</h4><ol><li> 找到需要删除的配置项，点击删除</li><li> 确认删除后，点击发布</li></ol><h4 id="添加Namespace"><a href="#添加Namespace" class="headerlink" title="添加Namespace"></a>添加Namespace</h4><p>Namespace作为配置的分类，可当成一个配置文件。</p><p>以添加rocketmq配置为例，添加“spring-rocketmq” Namespace配置rocketmq相关信息。</p><ol><li> 添加项目私有Namespace：spring-rocketmq</li></ol><p>进入项目首页，点击左下脚的“添加Namespace”，共包括两项：关联公共Namespace和创建Namespace，这里选择“创建Namespace”</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0028.png"/><ol start="2"><li>添加配置项</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">rocketmq.name-server</span> = <span class="string">127.0.0.1:9876</span></span><br><span class="line"><span class="meta">rocketmq.producer.group</span> = <span class="string">PID_ACCOUNT</span></span><br></pre></td></tr></table></figure><ol start="3"><li>发布配置</li></ol><h4 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h4><h5 id="添加公共Namespace"><a href="#添加公共Namespace" class="headerlink" title="添加公共Namespace"></a>添加公共Namespace</h5><p>在项目开发中，有一些配置可能是通用的，我们可以通过把这些通用的配置放到公共的Namespace中，这样其他项目要使用时可以直接添加需要的Namespace</p><ol><li> 新建common-template项目</li></ol><ol start="2"><li>添加公共Namespace：spring-boot-http</li></ol><p>进入common-template项目管理页面：<a href="http://localhost:8070/config.html#/appid=common-template">http://localhost:8070/config.html?#/appid=common-template</a></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0029.png" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0030.png" /><ol><li> 添加配置项并发布</li></ol>   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.http.encoding.enabled</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">spring.http.encoding.charset</span> = <span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">server.tomcat.remote_ip_header</span> = <span class="string">x-forwarded-for</span></span><br><span class="line"><span class="meta">server.tomcat.protocol_header</span> = <span class="string">x-forwarded-proto</span></span><br><span class="line"><span class="meta">server.use-forward-headers</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span> = <span class="string">/</span></span><br></pre></td></tr></table></figure><h5 id="关联公共Namespace"><a href="#关联公共Namespace" class="headerlink" title="关联公共Namespace"></a>关联公共Namespace</h5><ol><li> 打开之前创建的account-service项目</li><li> 点击左侧的添加Namespace</li><li> 添加Namespace</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0031.png"/><ol start="4"><li>根据需求可以覆盖引入公共Namespace中的配置，下面以覆盖server.servlet.context-path为例</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0032.png" /><ol start="5"><li>修改server.servlet.context-path为：/account-service</li><li>发布修改的配置项</li></ol><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>在有些情况下，应用有需求对不同的集群做不同的配置，比如部署在A机房的应用连接的RocketMQ服务器地址和部署在B机房的应用连接的RocketMQ服务器地址不一样。另外在项目开发过程中，也可为不同的开发人员创建不同的集群来满足开发人员的自定义配置。</p><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><ol><li> 点击页面左侧的“添加集群”按钮</li><li> 输入集群名称SHAJQ，选择环境并提交：添加上海金桥数据中心为例</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0033.png"  /><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0034.png" alt="image-20201228112150602"></p><ol start="3"><li>切换到对应的集群，修改配置并发布即可</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0035.png" /><h4 id="同步集群配置"><a href="#同步集群配置" class="headerlink" title="同步集群配置"></a>同步集群配置</h4><p>同步集群的配置是指在同一个应用中拷贝某个环境下的集群的配置到目标环境下的目标集群。</p><ol><li>从其他集群同步已有配置到新集群<ul><li>切换到原有集群</li><li>  展开要同步的Namespace，点击同步配置</li></ul> <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0036.png"  />    ![image-20201228112603903](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0037.png)  *   选择同步到的新集群，再选择要同步的配置  <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0038.png"/>  *   同步完成后，切换到SHAJQ集群，发布配置  <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0039.png" /></li></ol><h4 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h4><p>读取某个集群的配置，需要启动应用时指定具体的应用、环境和集群。</p><p>-Dapp.id=应用名称</p><p>-Denv=环境名称</p><p>-Dapollo.cluster=集群名称</p><p>-D环境_meta=meta地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dapp.id=account-service -Denv=DEV -Dapollo.cluster=SHAJQ -Ddev_meta=http://localhost:8080 </span><br></pre></td></tr></table></figure><h3 id="配置发布原理"><a href="#配置发布原理" class="headerlink" title="配置发布原理"></a>配置发布原理</h3><p>在配置中心中，一个重要的功能就是配置发布后实时推送到客户端。下面我们简要看一下这块是怎么设计实现的。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0040.png" /><p>上图简要描述了配置发布的主要过程：</p><ol><li> 用户在Portal操作配置发布</li><li> Portal调用Admin Service的接口操作发布</li><li> Admin Service发布配置后，发送ReleaseMessage给各个Config Service</li><li> Config Service收到ReleaseMessage后，通知对应的客户端</li></ol><h4 id="发送ReleaseMessage"><a href="#发送ReleaseMessage" class="headerlink" title="发送ReleaseMessage"></a>发送ReleaseMessage</h4><p>Admin Service在配置发布后，需要通知所有的Config Service有配置发布，从而Config Service可以通知对应的客户端来拉取最新的配置。</p><p>从概念上来看，这是一个典型的消息使用场景，Admin Service作为producer（生产者）发出消息，各个Config Service作为consumer（消费者）消费消息。通过一个消息队列组件（Message Queue）就能很好的实现Admin Service和Config Service的解耦。</p><p>在实现上，考虑到Apollo的实际使用场景，以及为了尽可能减少外部依赖，我们没有采用外部的消息中间件，而是通过数据库实现了一个简单的消息队列。</p><p>具体实现方式如下：</p><ol><li> Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace</li></ol>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ApolloConfigDB.ReleaseMessage</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0041.png" /><p>消息发送类：<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/DatabaseMessageSender.java">DatabaseMessageSende</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String channel)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Sending message &#123;&#125; to channel &#123;&#125;&quot;</span>, message, channel);</span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(channel, Topics.APOLLO_RELEASE_TOPIC)) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Channel &#123;&#125; not supported by DatabaseMessageSender!&quot;</span>, channel);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tracer.logEvent(<span class="string">&quot;Apollo.AdminService.ReleaseMessage&quot;</span>, message);</span><br><span class="line">    Transaction transaction = Tracer.newTransaction(<span class="string">&quot;Apollo.AdminService&quot;</span>, <span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里发送消息</span></span><br><span class="line">      ReleaseMessage newMessage = releaseMessageRepository.save(<span class="keyword">new</span> ReleaseMessage(message));</span><br><span class="line">      toClean.offer(newMessage.getId());</span><br><span class="line">      transaction.setStatus(Transaction.SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Sending message to database failed&quot;</span>, ex);</span><br><span class="line">      transaction.setStatus(ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      transaction.complete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Config Service有一个线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录</li></ol><p>消息扫描类：<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/message/ReleaseMessageScanner.java">ReleaseMessageScanner</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * scan messages and send</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> whether there are more messages</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">scanAndSendMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//current batch is 500</span></span><br><span class="line">   List&lt;ReleaseMessage&gt; releaseMessages =</span><br><span class="line">       releaseMessageRepository.findFirst500ByIdGreaterThanOrderByIdAsc(maxIdScanned);</span><br><span class="line">   <span class="keyword">if</span> (CollectionUtils.isEmpty(releaseMessages)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   fireMessageScanned(releaseMessages);</span><br><span class="line">   <span class="keyword">int</span> messageScanned = releaseMessages.size();</span><br><span class="line">   maxIdScanned = releaseMessages.get(messageScanned - <span class="number">1</span>).getId();</span><br><span class="line">   <span class="keyword">return</span> messageScanned == <span class="number">500</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Config Service如果发现有新的消息记录，那么就会通知到所有的消息监听器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Notify listeners with messages loaded</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> messages</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireMessageScanned</span><span class="params">(List&lt;ReleaseMessage&gt; messages)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (ReleaseMessage message : messages) &#123;</span><br><span class="line">     <span class="keyword">for</span> (ReleaseMessageListener listener : listeners) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         listener.handleMessage(message, Topics.APOLLO_RELEASE_TOPIC);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         Tracer.logError(ex);</span><br><span class="line">         logger.error(<span class="string">&quot;Failed to invoke message listener &#123;&#125;&quot;</span>, listener.getClass(), ex);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后调用消息监听类的handleMessage方法：<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-configservice/src/main/java/com/ctrip/framework/apollo/configservice/controller/NotificationControllerV2.java">NotificationControllerV2</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(ReleaseMessage message, String channel)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;message received - channel: &#123;&#125;, message: &#123;&#125;&quot;</span>, channel, message);</span><br><span class="line"></span><br><span class="line">    String content = message.getMessage();</span><br><span class="line">    Tracer.logEvent(<span class="string">&quot;Apollo.LongPoll.Messages&quot;</span>, content);</span><br><span class="line">    <span class="keyword">if</span> (!Topics.APOLLO_RELEASE_TOPIC.equals(channel) || Strings.isNullOrEmpty(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String changedNamespace = retrieveNamespaceFromReleaseMessage.apply(content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Strings.isNullOrEmpty(changedNamespace)) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;message format invalid - &#123;&#125;&quot;</span>, content);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!deferredResults.containsKey(content)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create a new list to avoid ConcurrentModificationException</span></span><br><span class="line">    List&lt;DeferredResultWrapper&gt; results = Lists.newArrayList(deferredResults.get(content));</span><br><span class="line"></span><br><span class="line">    ApolloConfigNotification configNotification = <span class="keyword">new</span> ApolloConfigNotification(changedNamespace, message.getId());</span><br><span class="line">    configNotification.addMessage(content, message.getId());</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ol start="4"><li>NotificationControllerV2得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0042.png"/><h4 id="Config-Service通知客户端"><a href="#Config-Service通知客户端" class="headerlink" title="Config Service通知客户端"></a>Config Service通知客户端</h4><p>上一节中简要描述了NotificationControllerV2是如何得知有配置发布的，那NotificationControllerV2在得知有配置发布后是如何通知到客户端的呢？</p><p>实现方式如下：</p><ol><li> 客户端会发起一个Http请求到Config Service的<code>notifications/v2</code>接口<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-configservice/src/main/java/com/ctrip/framework/apollo/configservice/controller/NotificationControllerV2.java">NotificationControllerV2</a></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jason Song(song_s@ctrip.com)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/notifications/v2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationControllerV2</span> <span class="keyword">implements</span> <span class="title">ReleaseMessageListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NotificationControllerV2.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Multimap&lt;String, DeferredResultWrapper&gt; deferredResults =</span><br><span class="line">      Multimaps.synchronizedSetMultimap(TreeMultimap.create(String.CASE_INSENSITIVE_ORDER, Ordering.natural()));</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Splitter STRING_SPLITTER =</span><br><span class="line">      Splitter.on(ConfigConsts.CLUSTER_NAMESPACE_SEPARATOR).omitEmptyStrings();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Type notificationsTypeReference =</span><br><span class="line">      <span class="keyword">new</span> TypeToken&lt;List&lt;ApolloConfigNotification&gt;&gt;() &#123;</span><br><span class="line">      &#125;.getType();</span><br></pre></td></tr></table></figure><p>客户端发送请求类：<a href="https://github.com/ctripcorp/apollo/blob/master/apollo-client/src/main/java/com/ctrip/framework/apollo/internals/RemoteConfigLongPollService.java">RemoteConfigLongPollService</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLongPollingRefresh</span><span class="params">(String appId, String cluster, String dataCenter, String secret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    ServiceDTO lastServiceDto = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!m_longPollingStopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!m_longPollRateLimiter.tryAcquire(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">//wait at most 5 seconds</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Transaction transaction = Tracer.newTransaction(<span class="string">&quot;Apollo.ConfigService&quot;</span>, <span class="string">&quot;pollNotification&quot;</span>);</span><br><span class="line">      String url = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastServiceDto == <span class="keyword">null</span>) &#123;</span><br><span class="line">          List&lt;ServiceDTO&gt; configServices = getConfigServices();</span><br><span class="line">          lastServiceDto = configServices.get(random.nextInt(configServices.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        url =</span><br><span class="line">            assembleLongPollRefreshUrl(lastServiceDto.getHomepageUrl(), appId, cluster, dataCenter,</span><br><span class="line">                m_notifications);</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;Long polling from &#123;&#125;&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">        HttpRequest request = <span class="keyword">new</span> HttpRequest(url);</span><br><span class="line">        request.setReadTimeout(LONG_POLLING_READ_TIMEOUT);</span><br></pre></td></tr></table></figure><ol start="2"><li>NotificationControllerV2不会立即返回结果，而是把请求挂起。考虑到会有数万客户端向服务端发起长连，因此在服务端使用了async servlet(<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">Spring DeferredResult</a>)来服务Http Long Polling请求。</li><li>如果在60秒内没有该客户端关心的配置发布，那么会返回Http状态码304给客户端。</li><li>如果有该客户端关心的配置发布，NotificationControllerV2会调用DeferredResult的<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html#setResult-T-">setResult</a>方法，传入有配置变化的namespace信息，同时该请求会立即返回。客户端从返回的结果中获取到配置变化的namespace后，会立即请求Config Service获取该namespace的最新配置。</li></ol><h4 id="客户端读取设计"><a href="#客户端读取设计" class="headerlink" title="客户端读取设计"></a>客户端读取设计</h4><p>除了之前介绍的客户端和服务端保持一个长连接，从而能第一时间获得配置更新的推送外，<strong>客户端还会定时从Apollo配置中心服务端拉取应用的最新配置</strong>。</p><ul><li>这是一个备用机制，为了防止推送机制失效导致配置不更新</li><li>客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified</li><li>定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: <code>apollo.refreshInterval</code>来覆盖，单位为分钟</li></ul><h2 id="Apollo应用于分布式系统"><a href="#Apollo应用于分布式系统" class="headerlink" title="Apollo应用于分布式系统"></a>Apollo应用于分布式系统</h2><p>在微服务架构模式下，项目往往会切分成多个微服务，下面将以一个金融P2P项目为例演示如何在项目中使用。</p><h3 id="项目场景介绍"><a href="#项目场景介绍" class="headerlink" title="项目场景介绍"></a>项目场景介绍</h3><h4 id="各微服务介绍"><a href="#各微服务介绍" class="headerlink" title="各微服务介绍"></a>各微服务介绍</h4><p>本章节仅仅是为了演示配置中心，所以摘取了部分微服务，如下：</p><p>用户中心服务(consumer-service)：为借款人和投资人提供用户账户管理服务，包括：注册、开户、充值、提现等</p><p>UAA认证服务(uaa-service)：为用户中心的用户提供认证服务</p><p>统一账户服务(account-service)：对借款人和投资人的登录平台账号进行管理，包括：注册账号、账号权限管理等</p><p>交易中心(transaction-service)：负责P2P平台用户发标和投标功能</p><h3 id="Spring-Boot应用集成"><a href="#Spring-Boot应用集成" class="headerlink" title="Spring Boot应用集成"></a>Spring Boot应用集成</h3><p>下面以集成统一账户服务(account-service)为例</p><h4 id="工程依赖"><a href="#工程依赖" class="headerlink" title="工程依赖"></a>工程依赖</h4><p>每个工程必须添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下边是account-service依赖，。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.pbteach<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    </p><h4 id="必选配置说明"><a href="#必选配置说明" class="headerlink" title="必选配置说明"></a>必选配置说明</h4><ol><li> <strong>AppId</strong>：在Spring Boot application.properties或application.yml中配置</li></ol><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">app.id</span>=<span class="string">account-service</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">id:</span> <span class="string">account-service</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>apollo.bootstrap</strong></li></ol><p>集成springboot，开启apollo.bootstrap，指定namespace</p><p>例子：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">apollo.bootstrap.enabled</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">apollo.bootstrap.namespaces</span> = <span class="string">application,micro_service.spring-boot-http,spring-rocketmq,micro_service.spring-boot-druid</span></span><br></pre></td></tr></table></figure><p>​    </p><ol start="3"><li><strong>Apollo Meta Server</strong></li></ol><p>Apollo支持应用在不同的环境有不同的配置，常用的指定方式有如下两种：</p><ul><li>第一种：通过Java System Property的apollo.meta：<code>-Dapollo.meta=http://localhost:8080</code></li><li>第二种：在resources目录下新建apollo-env.properties文件  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">dev.meta</span>=<span class="string">http://localhost:8080</span></span><br><span class="line"><span class="meta">pro.meta</span>=<span class="string">http://localhost:8081</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>本地缓存路径</strong></li></ol><p>Apollo客户端会把从服务端获取到的配置在本地文件系统缓存一份，用于在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置，不影响应用正常运行。本地配置文件会以下面的文件名格式放置于配置的本地缓存路径下：{appId}+{cluster}+{namespace}.properties</p><p>可以通过如下方式指定缓存路径，通过Java System Property的apollo.cacheDir：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dapollo.cacheDir=/opt/data/apollo-config</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Environment</strong></li></ol><p>通过Java System Property的env来指定环境：<code>-Denv=DEV</code></p><ol start="6"><li><strong>Cluster（集群）</strong></li></ol><p>通过Java System Property的apollo.cluste来指定集群：<code>-Dapollo.cluster=DEFAULT</code></p><p>也可以选择使用之前新建的SHAJQ集群：<code>-Dapollo.cluster=SHAJQ</code></p><p><strong>最终完整的VM Options如下</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Denv=DEV -Dapollo.cacheDir=/opt/data/apollo-config -Dapollo.cluster=DEFAULTbash</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0043.png"/><p><strong>完整的主配置文件为：</strong></p><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定读哪个应用的配置（必须写在配置文件里，无法写在apollo里，因为配置文件里如果没有写，都不知道读apollo里的哪个应用）</span></span><br><span class="line"><span class="meta">app.id</span>=<span class="string">account-service</span></span><br><span class="line"><span class="comment"># 下面这个配置是开启Apollo的客户端，使其生效</span></span><br><span class="line"><span class="meta">apollo.bootstrap.enabled</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># namespace以逗号分隔</span></span><br><span class="line"><span class="meta">apollo.bootstrap.namespaces</span> = <span class="string">application,micro_service.spring-boot-http,spring-rocketmq,micro_service.spring-boot-druid</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">63000</span></span><br></pre></td></tr></table></figure><h4 id="启用配置"><a href="#启用配置" class="headerlink" title="启用配置"></a>启用配置</h4><p>在咱们应用的启动类添加<code>@EnableApolloConfig</code>注解即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &quot;com.itcast.account&quot;)</span></span><br><span class="line"><span class="meta">@EnableApolloConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(AccountApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h4><ol><li><p>将local-config/account.properties中的配置添加到apollo中</p> <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">swagger.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">sms.enable</span>=<span class="string">true</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.http.encoding.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.use-forward-headers</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.tomcat.protocol_header</span>=<span class="string">x-forwarded-proto</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/account-service</span></span><br><span class="line"><span class="meta">server.tomcat.remote_ip_header</span>=<span class="string">x-forwarded-for</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.allow</span>=<span class="string">127.0.0.1,192.168.163.1</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.session-stat-enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-pool-prepared-statement-per-connection-size</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.reset-enable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.validation-query</span>=<span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.url-pattern</span>=<span class="string">/druid/*</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.deny</span>=<span class="string">192.168.1.73</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc\:mysql\://127.0.0.1\:3306/p2p_account?useUnicode\=true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.filters</span>=<span class="string">config,stat,wall,log4j2</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-return</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.profile-enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-wait</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.session-stat-max-count</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.pool-prepared-statements</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-while-idle</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">pbteach0430</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.login-password</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.login-username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.url-pattern</span>=<span class="string">/*</span></span><br><span class="line"><span class="meta">spring.datasource.druid.time-between-eviction-runs-millis</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-evictable-idle-time-millis</span>=<span class="string">300000</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.principal-session-name</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.datasource.druid.filter.stat.log-slow-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.principal-cookie-name</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.druid.aop-patterns</span>=<span class="string">com.pbteach.wanxinp2p.*.service.*</span></span><br><span class="line"><span class="meta">spring.datasource.druid.filter.stat.slow-sql-millis</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">spring.datasource.druid.web-stat-filter.exclusions</span>=<span class="string">*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span></span><br></pre></td></tr></table></figure></li><li><p>spring-http命名空间在之前已通过关联公共命名空间添加好了，现在来添加spring-boot-druid命名空间</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0044.png" /><ol start="3"><li>添加本地文件中的配置到对应的命名空间，然后发布配置</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0045.png" /><ol start="4"><li>在account-service/src/main/resources/application.properties中配置apollo.bootstrap.namespaces需要引入的命名空间(上面写过)</li></ol>  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定读哪个应用的配置（必须写在配置文件里，无法写在apollo里，因为配置文件里如果没有写，都不知道读apollo里的哪个应用）</span></span><br><span class="line"><span class="meta">app.id</span>=<span class="string">account-service</span></span><br><span class="line"><span class="comment"># 下面这个配置是开启Apollo的客户端，使其生效</span></span><br><span class="line"><span class="meta">apollo.bootstrap.enabled</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># namespace以逗号分隔</span></span><br><span class="line"><span class="meta">apollo.bootstrap.namespaces</span> = <span class="string">application,micro_service.spring-boot-http,spring-rocketmq,micro_service.spring-boot-druid</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">63000</span></span><br></pre></td></tr></table></figure><p>5.写一个测试Controller</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.itcast.account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;sms.enable&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Boolean smsEnable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hi&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSmsConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;smsEnable: &quot;</span> + smsEnable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;rocketmq.name-server&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String mqNameServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;rocketmq.producer.group&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String mqProducerGroup;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/mq&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRocketMQConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mqNameServer + <span class="string">&quot;: &quot;</span> + mqProducerGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;timeout&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long timeout;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/timeout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/db-url&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDBConfig</span><span class="params">(<span class="meta">@Value(&quot;$&#123;spring.datasource.url&#125;&quot;)</span> String url)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读取配置-1"><a href="#读取配置-1" class="headerlink" title="读取配置"></a>读取配置</h4><ol><li><p> 启动应用</p></li><li><p>访问：<a href="http://127.0.0.1:63000/account-service/hi">http://127.0.0.1:63000/account-service/hi</a>，确认Spring Boot中配置的context-path是否生效</p></li></ol><p>通过/account-service能正常访问，说明apollo的配置已生效</p><ol start="3"><li>确认spring-boot-druid配置</li></ol><ul><li><p>  为了快速确认可以在AccountController中通过@Value获取来验证</p></li><li><p>  访问<a href="http://127.0.0.1:63000/account-service/db-url">http://127.0.0.1:63000/account-service/db-url</a>，显示结果</p></li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0046.png"/><h4 id="创建其它项目"><a href="#创建其它项目" class="headerlink" title="创建其它项目"></a>创建其它项目</h4><p>参考account-service将其它项目也创建完成。</p><h3 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h3><p>当一个项目要上线部署到生产环境时，项目的配置比如数据库连接、RocketMQ地址等都会发生变化，这时候就需要通过Apollo为生产环境添加自己的配置。</p><h4 id="企业部署方案"><a href="#企业部署方案" class="headerlink" title="企业部署方案"></a>企业部署方案</h4><p>在企业中常用的部署方案为：Apollo-adminservice和Apollo-configservice两个服务分别在线上环境(pro)，仿真环境(uat)和开发环境(dev)各部署一套，Apollo-portal做为管理端只部署一套，统一管理上述三套环境。</p><p>具体如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0047.png" /><p>下面以添加生产环境部署为例</p><h4 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>创建生产环境的ApolloConfigDB：<strong>每添加一套环境就需要部署一套ApolloConfgService和ApolloAdminService</strong></p><p>source apollo/ApolloConfigDB_PRO__initialization.sql</p><h4 id="配置启动参数"><a href="#配置启动参数" class="headerlink" title="配置启动参数"></a>配置启动参数</h4><ol><li><p>设置生产环境数据库连接</p></li><li><p>设置ApolloConfigService端口为：8081，ApolloAdminService端口为8091</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> url=<span class="string">&quot;localhost:3306&quot;</span></span><br><span class="line"><span class="built_in">set</span> username=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="built_in">set</span> password=<span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">start <span class="string">&quot;configService-PRO&quot;</span> java -Dserver.port=8081 -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDBPRO?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\logs\apollo-configservice.log -jar .\apollo-configservice-1.3.0.jar</span><br><span class="line">start <span class="string">&quot;adminService-PRO&quot;</span> java -Dserver.port=8091 -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDBPRO?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\logs\apollo-adminservice.log -jar .\apollo-adminservice-1.3.0.jar</span><br></pre></td></tr></table></figure></li><li><p> 运行runApollo-PRO.bat【关于这个bat的说明在上面已经说过】</p></li></ol><h4 id="修改Eureka地址"><a href="#修改Eureka地址" class="headerlink" title="修改Eureka地址"></a>修改Eureka地址</h4><p>因为上一套<strong>ApolloConfgService和ApolloAdminService</strong>里的Eureka占用了8080端口，所以这里第二套需要改一下端口</p><p>更新生产环境Apollo的Eureka地址：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE ApolloConfigDBPRO;</span><br><span class="line"></span><br><span class="line">UPDATE ServerConfig <span class="keyword">SET</span> `<span class="keyword">Value</span>` <span class="operator">=</span> &quot;http://localhost:8081/eureka/&quot; <span class="keyword">WHERE</span> `key` <span class="operator">=</span> &quot;eureka.service.url&quot;;</span><br></pre></td></tr></table></figure><h4 id="调整ApolloPortal服务配置"><a href="#调整ApolloPortal服务配置" class="headerlink" title="调整ApolloPortal服务配置"></a>调整ApolloPortal服务配置</h4><p>服务配置项统一存储在ApolloPortalDB.ServerConfig表中，可以通过<code>管理员工具 - 系统参数</code>页面进行配置：apollo.portal.envs - 可支持的环境列表</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0048.png"  /><p>默认值是dev，如果portal需要管理多个环境的话，以逗号分隔即可（大小写不敏感），如：</p><pre><code>dev,pro</code></pre><h4 id="启动ApolloPortal"><a href="#启动ApolloPortal" class="headerlink" title="启动ApolloPortal"></a>启动ApolloPortal</h4><p>Apollo Portal需要在不同的环境访问不同的meta service(apollo-configservice)地址，所以我们需要在配置中提供这些信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Ddev_meta=http://localhost:8080/ -Dpro_meta=http://localhost:8081/</span><br></pre></td></tr></table></figure><ol><li><p>关闭之前启动的ApolloPortal服务，使用runApolloPortal.bat启动多环境配置</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> url=<span class="string">&quot;localhost:3306&quot;</span></span><br><span class="line"><span class="built_in">set</span> username=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="built_in">set</span> password=<span class="string">&quot;mysql&quot;</span></span><br><span class="line"></span><br><span class="line">start <span class="string">&quot;ApolloPortal&quot;</span> java -Xms256m -Xmx256m -Dapollo_profile=github,auth -Ddev_meta=http://localhost:8080/ -Dpro_meta=http://localhost:8081/ -Dserver.port=8070 -Dspring.datasource.url=jdbc:mysql://%url%/ApolloPortalDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\logs\apollo-portal.log -jar .\apollo-portal-1.3.0.jar</span><br></pre></td></tr></table></figure></li><li><p> 启动之后，点击account-service服务配置后会提示环境缺失，此时需要补全上边新增生产环境的配置</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0049.png" /><ol start="3"><li>点击左下方的补缺环境</li></ol><ol start="4"><li>补缺过生产环境后，切换到PRO环境后会提示有Namespace缺失，点击补缺</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0050.png" /><ol start="5"><li>从dev环境同步配置到pro</li></ol><h4 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h4><ol><li> 同步完成后，切换到pro环境，修改生产环境rocketmq地址后发布配置</li></ol><ol start="2"><li>配置项目使用pro环境，测试配置是否生效</li></ol><ul><li>在apollo-env.properties中增加pro.meta=<a href="http://localhost:8081/">http://localhost:8081</a></li><li>  修改account-service启动参数为：-Denv=pro</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Denv=pro -Dapollo.cacheDir=/opt/data/apollo-config -Dapollo.cluster=DEFAULT</span><br></pre></td></tr></table></figure><ul><li>  访问<a href="http://127.0.0.1:63000/account-service/mq">http://127.0.0.1:63000/account-service/mq</a> 验证RocketMQ地址是否为上边设置的PRO环境的值</li></ul><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p> 灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><h4 id="Apollo实现的功能"><a href="#Apollo实现的功能" class="headerlink" title="Apollo实现的功能"></a>Apollo实现的功能</h4><ol><li> 对于一些对程序有比较大影响的配置，可以先在一个或者多个实例生效，观察一段时间没问题后再全量发布配置。</li><li> 对于一些需要调优的配置参数，可以通过灰度发布功能来实现A/B测试。可以在不同的机器上应用不同的配置，不断调整、测评一段时间后找出较优的配置再全量发布配置。</li></ol><h4 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h4><p>apollo-quickstart项目有两个客户端：</p><ol><li> 172.16.0.160</li><li> 172.16.0.170</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0051.png"/><p><strong>灰度目标</strong></p><p>当前有一个配置timeout=2000，我们希望对172.16.0.160灰度发布timeout=3000，对172.16.0.170仍然是timeout=2000。</p><h4 id="创建灰度"><a href="#创建灰度" class="headerlink" title="创建灰度"></a>创建灰度</h4><ol><li> 点击application namespace右上角的<code>创建灰度</code>按钮</li></ol><ol start="2"><li>点击确定后，灰度版本就创建成功了，页面会自动切换到<code>灰度版本</code>Tab</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0052.png"/><h4 id="灰度配置"><a href="#灰度配置" class="headerlink" title="灰度配置"></a>灰度配置</h4><ol><li><p> 点击<code>主版本的配置</code>中，timeout配置最右侧的<code>对此配置灰度</code>按钮</p></li><li><p>在弹出框中填入要灰度的值：3000，点击提交</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0053.png"/><h4 id="配置灰度规则"><a href="#配置灰度规则" class="headerlink" title="配置灰度规则"></a>配置灰度规则</h4><ol><li> 切换到<code>灰度规则</code>Tab，点击<code>新增规则</code>按钮</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0054.png" /><ol start="2"><li>在弹出框中<code>灰度的IP</code>下拉框会默认展示当前使用配置的机器列表，选择我们要灰度的IP，点击完成</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0055.png"/><p>如果下拉框中没找到需要的IP，说明机器还没从Apollo取过配置，可以点击手动输入IP来输入，输入完后点击添加按钮</p><h4 id="灰度发布-1"><a href="#灰度发布-1" class="headerlink" title="灰度发布"></a>灰度发布</h4><ol><li> 启动apollo-quickstart项目的GrayTest类输出timeout的值</li></ol><p>vm options: <code>-Dapp.id=apollo-quickstart -Denv=DEV -Ddev_meta=http://localhost:8080</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VM options:</span></span><br><span class="line"><span class="comment">// -Dapp.id=apollo-quickstart -Denv=DEV -Ddev_meta=http://localhost:8080</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Config config = ConfigService.getAppConfig();</span><br><span class="line">String someKey = <span class="string">&quot;timeout&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">String value = config.getProperty(someKey, <span class="keyword">null</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;now: %s, timeout: %s%n&quot;</span>, LocalDateTime.now().toString(), value);</span><br><span class="line">Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0056.png"/><ol start="2"><li>切换到<code>配置</code>Tab，再次检查灰度的配置部分，如果没有问题，点击<code>灰度发布</code></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0057.png" /><ol start="3"><li>在弹出框中可以看到主版本的值是2000，灰度版本即将发布的值是3000。填入其它信息后，点击发布</li></ol><ol start="4"><li>发布后，切换到<code>灰度实例列表</code>Tab，就能看到172.16.0.160已经使用了灰度发布的值</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0058.png"/><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/Apollo/Simple_Introduction/0059.png" /><h4 id="全量发布"><a href="#全量发布" class="headerlink" title="全量发布"></a>全量发布</h4><p>如果灰度的配置测试下来比较理想，符合预期，那么就可以操作<code>全量发布</code>。</p><p>全量发布的效果是：</p><ol><li> 灰度版本的配置会合并回主版本，在这个例子中，就是主版本的timeout会被更新成3000</li><li> 主版本的配置会自动进行一次发布</li><li> 在全量发布页面，可以选择是否保留当前灰度版本，默认为不保留。</li></ol><h4 id="放弃灰度"><a href="#放弃灰度" class="headerlink" title="放弃灰度"></a>放弃灰度</h4><p>如果灰度版本不理想或者不需要了，可以点击<code>放弃灰度</code></p><h4 id="发布历史"><a href="#发布历史" class="headerlink" title="发布历史"></a>发布历史</h4><p>点击主版本的<code>发布历史</code>按钮，可以看到当前namespace的主版本以及灰度版本的发布历史</p>]]></content>
      
      
      <categories>
          
          <category> 分布式配置中心 </category>
          
          <category> Apollo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apollo </tag>
            
            <tag> 分布式配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第12章-垃圾回收器</title>
      <link href="post/7706d61d.html"/>
      <url>post/7706d61d.html</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h2><h3 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h3><ol><li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li><li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li><li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li></ol><p><strong>Java不同版本新特性</strong></p><ol><li> 语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型</li><li> API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li> 底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等</li></ol><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0001.png"><ol><li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ol><li> 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li> 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li></ol></li><li> 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</li></ol><p><strong>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</strong></p><ol><li> 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li> 独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0002.png"><p><strong>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</strong></p><ol><li> 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞</li><li> 非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表</li></ol><p><strong>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</strong></p><h3 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h3><p><strong>指标</strong></p><ol><li> 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li> 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li> 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li> 收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li> 内存占用：Java堆区所占的内存大小。</li><li> 快速：一个对象从诞生到被回收所经历的时间。</li></ol><ol><li> 吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li><li> 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li><li>简单来说，主要抓住两点：<ul><li>  吞吐量</li><li>暂停时间</li></ul></li></ol><p><strong>吞吐量（throughput）</strong></p><ol><li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）<ul><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li></ul></li><li> 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li><li> 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0003.png"><p><strong>暂停时间（pause time）</strong></p><ol><li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。<ul><li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li></ul></li><li> 暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5，但是总的GC时间可能会长</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0004.png"><p><strong>吞吐量 vs 暂停时间</strong></p><ol><li><strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li><li>低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。</li><li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。<ul><li>  因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>  相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul></li><li>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</li><li>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></li></ol><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><ol><li> 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li><li> 那么，Java常见的垃圾收集器有哪些？</li></ol><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ol><li> 1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li> 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li> Parallel GC在JDK6之后成为HotSpot默认GC。</li><li> 2012年，在JDK1.7u4版本中，G1可用。</li><li> 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li> 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li> 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li> 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li><li> 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li><li> 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li></ol><h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ol><li> 串行回收器：Serial、Serial old</li><li> 并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li> 并发回收器：CMS、G1</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0005.png"><p><strong>官方文档</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0006.jpg"><p><strong>7款经典回收器与垃圾分代之间的关系</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0007.png"><ol><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial old、Parallel old、CMS；</li><li>整堆收集器：G1；</li></ol><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0008.png"><ol><li>两个收集器间有连线，表明它们可以搭配使用：<ul><li>  Serial/Serial old</li><li>  Serial/CMS    （JDK9废弃）</li><li>  ParNew/Serial Old （JDK9废弃）</li><li>  ParNew/CMS</li><li>  Parallel Scavenge/Serial Old  （预计废弃）</li><li>  Parallel Scavenge/Parallel Old</li><li>  G1</li></ul></li><li> 其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</li><li> （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li> （绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）</li><li> （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</li></ol><ol><li> 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</li><li> 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</li></ol><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ol><li> -XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li><li> 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li></ol><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><p><strong>在 JDK 8 下，设置 JVM 参数</strong></p><p>-XX:+PrintCommandLineFlags</p><p>程序打印输出：-XX:+UseParallelGC 表示使用使用 ParallelGC ，ParallelGC 默认和 Parallel Old 绑定使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">266620736</span> -XX:MaxHeapSize=<span class="number">4265931776</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC </span><br></pre></td></tr></table></figure><p><strong>通过命令行指令查看</strong></p><p>命令行命令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jps</span><br><span class="line">jinfo -flag UseParallelGC 进程id</span><br><span class="line">jinfo -flag UseParallelOldGC 进程id</span><br></pre></td></tr></table></figure><p>JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0009.png"><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0010.png"><h2 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h2><p><strong>Serial 回收器：串行回收</strong></p><ol><li>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li><li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li><li>Serial收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。</li><li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</li><li> Serial Old是运行在Client模式下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用②作为老年代CMS收集器的后备垃圾收集方案</li></ol><p>这个收集器是一个单线程的收集器，“单线程”的意义：它只会使用一个CPU（串行）或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0011.png"><p><strong>Serial 回收器的优势</strong></p><ol><li> 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</li><li> 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li><li>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。<ul><li>等价于新生代用Serial GC，且老年代用Serial Old GC</li></ul></li></ol><p><strong>总结</strong></p><ol><li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</li><li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</li></ol><h2 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h2><ol><li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。<ul><li>Par是Parallel的缩写，New：只能处理新生代</li></ul></li><li> ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</li><li> ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0012.png"><ol><li> 对于新生代，回收次数频繁，使用并行方式高效。</li><li> 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ol><p><strong>ParNew 回收器与 Serial 回收器比较</strong></p><p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p><p>A：<strong>不能</strong></p><ol><li> ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li> 但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li><li> 除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li></ol><p><strong>设置 ParNew 垃圾回收器</strong></p><ol><li>在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</li><li>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</li></ol><h2 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h2><p><strong>Parallel Scavenge 回收器：吞吐量优先</strong></p><ol><li>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</li><li>那么Parallel收集器的出现是否多此一举？<ul><li>  和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>  自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟）</li></ul></li><li>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</li><li>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</li><li>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0013.png"><ol><li> 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。</li><li> <strong>在Java8中，默认是此垃圾收集器。</strong></li></ol><p><strong>Parallel Scavenge 回收器参数设置</strong></p><ol><li><p>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p></li><li><p>-XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。</p><ul><li><p>分别适用于新生代和老年代</p></li><li><p>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</p></li></ul></li><li><p>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><ol><li>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</li><li>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8]</li></ol></li><li><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</p><ol><li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li><li>该参数使用需谨慎。</li></ol></li><li><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 / (N+1) ，用于衡量吞吐量的大小。</p><ol><li><p>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。</p></li><li><p>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。</p></li></ol></li></ol><ol start="6"><li><p>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p><ol><li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p></li></ol></li></ol><h2 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a>CMS 回收器：低延迟</h2><h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><ol><li> 在JDK1.5时期，Hotspot推出了一款在<strong>强交互应用中（就是和用户打交道的引用）</strong>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li><li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li></ul></li><li> CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</li><li> 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</li><li> 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</li></ol><h3 id="CMS-工作原理（过程）"><a href="#CMS-工作原理（过程）" class="headerlink" title="CMS 工作原理（过程）"></a>CMS 工作原理（过程）</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0014.png"><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ol><li> 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，<strong>这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li><li> 并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，<strong>可以与垃圾收集线程一起并发运行</strong>。</li><li> 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。</li><li> 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></li></ol><h3 id="CMS分析"><a href="#CMS分析" class="headerlink" title="CMS分析"></a>CMS分析</h3><ol><li> 尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li><li> <strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</li><li> 另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<strong>而是当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<strong>“Concurrent Mode Failure”</strong> 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li><li> CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<strong>不可避免地将会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0015.png"><p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用</p><h3 id="CMS-的优点与弊端"><a href="#CMS-的优点与弊端" class="headerlink" title="CMS 的优点与弊端"></a>CMS 的优点与弊端</h3><p><strong>优点</strong></p><ol><li> 并发收集</li><li> 低延迟</li></ol><p><strong>弊端</strong></p><ol><li> <strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li><li> <strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li> <strong>CMS收集器无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，</strong>从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ol><h3 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h3><ul><li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。</p><p>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</p></li></ul><ul><li>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li></ul><ol><li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li></ol><ul><li>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li></ul><ul><li>-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。</li></ul><ul><li>-XX:ParallelCMSThreads：设置CMS的线程数量。</li></ul><ol><li> CMS默认启动的线程数是 (ParallelGCThreads + 3) / 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p><ol><li> 如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li> 如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li> 如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ol><h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><ol><li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul><li>  如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul></li><li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，<ul><li>  如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul></li></ol><h2 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h2><h3 id="为什么还需要G1"><a href="#为什么还需要G1" class="headerlink" title="为什么还需要G1"></a>为什么还需要G1</h3><p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p><ol><li> 原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li><li> G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li><li> 与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</li><li> 官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</li></ol><h3 id="为什么名字叫Garbage-First-G1-呢？"><a href="#为什么名字叫Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫Garbage First(G1)呢？"></a>为什么名字叫Garbage First(G1)呢？</h3><ol><li> 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li> G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region。</strong></li><li> 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li><li> G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li> 在JDK1.7版本正式启用，移除了Experimental的标识，<strong>是JDK9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong>。</li><li> 与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。<strong>G1在JDK8中还不是默认的垃圾回收器</strong>，需要使用-XX:+UseG1GC来启用。</li></ol><h3 id="G1-回收器的优势"><a href="#G1-回收器的优势" class="headerlink" title="G1 回收器的优势"></a>G1 回收器的优势</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><ol><li><strong>并行与并发兼备</strong><ul><li>  并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>  并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li><strong>分代收集</strong><ul><li>  从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>  将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>  和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul></li></ol><p>G1的分代，已经不是下面这样的了</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0016.png"><p>G1的分区是这样的一个区域</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0017.png"><p><strong>空间整合</strong></p><ol><li> CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li> G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ol><h3 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h3><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ol><li> 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li> G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li> 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ol><h3 id="G1-回收器的缺点"><a href="#G1-回收器的缺点" class="headerlink" title="G1 回收器的缺点"></a>G1 回收器的缺点</h3><ol><li> 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li><li> 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ol><h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul><li><p>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</p></li><li><p>-XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p></li><li><p>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms</p></li><li><p>-XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8</p></li><li><p>-XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</p></li><li><p>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li></ul><h3 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li> 第一步：开启G1垃圾收集器</li><li> 第二步：设置堆的最大内存</li><li> 第三步：设置最大的停顿时间</li></ol><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p><h3 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h3><ol><li> 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li><li> 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li><li> 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li><li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul><li>  超过50%的Java堆被活动数据占用；</li><li>  对象分配频率或年代提升频率变化很大；</li><li>  GC停顿时间过长（长于0.5至1秒）</li></ul></li><li> HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ol><h3 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区 Region"></a>分区 Region</h3><p><strong>分区 Region：化整为零</strong></p><ol><li>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</li><li>XX:G1HeapRegionSize设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变。</strong></li><li>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</li><li>一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li><li> G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</li></ol><blockquote><p>纠错：尚硅谷视频里这里写的是超过1.5个region。根据<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">官方文档</a>:  <strong>The G1 Garbage Collector Step by Step</strong></p><p>As shown regions can be allocated into Eden, survivor, and old generation regions. In addition, there is a fourth type of object known as Humongous regions. These regions are designed to hold objects that are 50% the size of a standard region or larger. They are stored as a set of contiguous regions. Finally the last type of regions would be the unused areas of the heap.</p><p>翻译：</p><p>如图所示，可以将区域分配到Eden，幸存者和旧时代区域。 此外，还有第四种类型的物体被称为巨大区域。 这些区域旨在容纳标准区域大小的50％或更大的对象。 它们存储为一组连续区域。 最后，最后一种区域类型是堆的未使用区域。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0018.png"><p><strong>设置 H 的原因</strong></p><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果<strong>它是一个短期存在的大对象</strong>就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如<strong>果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p><strong>Regio的细节</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0019.png"><ol><li> 每个Region都是通过指针碰撞来分配空间</li><li> G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li> TLAB还是用来保证并发性</li></ol><h3 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>  年轻代GC（Young GC）</li><li>  老年代并发标记过程（Concurrent Marking）</li><li>  混合回收（Mixed GC）</li><li>  （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0020.png"><p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收</p><p><strong>回收流程</strong></p><ol><li> 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</li><li> 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li><li> 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</li><li> 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li></ol><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><blockquote><p>之前讲过</p></blockquote><ol><li>一个对象被不同区域引用的问题</li><li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</li><li>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</li></ol><p><strong>解决方法：</strong></p><ol><li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描；</li><li>每个Region都有一个对应的Remembered Set</li><li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</li><li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li><li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li><li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0021.png"><ol><li> 在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li><li> Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li><li> 这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li><li> Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li></ol><h3 id="G1回收过程一：年轻代-GC"><a href="#G1回收过程一：年轻代-GC" class="headerlink" title="G1回收过程一：年轻代 GC"></a>G1回收过程一：年轻代 GC</h3><ol><li> JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li><li> 年轻代回收只回收Eden区和Survivor区</li><li> YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0022.png"><p>图的大致意思就是：</p><p>1、回收完E和S区，剩余存活的对象会复制到新的S区</p><p>2、S区达到一定的阈值可以晋升为O区</p><p><strong>细致过程：</strong></p><p><strong>然后开始如下回收过程：</strong></p><ol><li><p>第一阶段，扫描根</p><p> 根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p></li><li><p>第二阶段，更新RSet</p></li><li><p>第三阶段，处理RSet</p><p> 识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p></li><li><p>第四阶段，复制对象。</p><ul><li>  此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li><li>  如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li><li>  如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li></ul></li><li><p>第五阶段，处理引用</p><p> 处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ol><p><strong>备注：</strong></p><ol><li> 对于应用程序的引用赋值语句 oldObject.field（这个是老年代）=object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li><li> 那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li></ol><h3 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h3><ol><li> 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li><li> 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li><li>并发标记（Concurrent Marking）：<ol><li> 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li><li> <strong>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</strong></li><li> 同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li></ol></li><li> 再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li><li> 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li> 并发清理阶段：识别并清理完全空闲的区域。</li></ol><h3 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h3><p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0023.png"><p><strong>混合回收的细节</strong></p><ol><li> 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】</li><li> 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li> 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li> 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ol><h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><ol><li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li><li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li></ol><p>导致G1 Full GC的原因可能有两个：</p><ol><li> EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li> 并发处理过程完成之前空间耗尽。</li></ol><h3 id="G1补充"><a href="#G1补充" class="headerlink" title="G1补充"></a>G1补充</h3><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。</strong>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p><strong>G1 回收器的优化建议</strong></p><ol><li>年轻代大小<ul><li>  避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>  G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>  评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ol><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><h3 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h3><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0034.jpg"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0024.png"><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ol><li> 优先调整堆的大小让JVM自适应完成。</li><li> 如果内存小于100M，使用串行收集器</li><li> 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li> 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li> 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li> 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ol><p>最后需要明确一个观点：</p><ol><li> 没有最好的收集器，更没有万能的收集算法</li><li> 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><ol><li> 对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li><li>这里较通用、基础性的部分如下：<ul><li>  垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>  垃圾收集器工作的基本流程。</li></ul></li><li> 另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ol><h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><h3 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h3><blockquote><p><strong>GC 日志参数设置</strong></p></blockquote><p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p><p>内存分配与垃圾回收的参数列表</p><ol><li> -XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li><li> -XX:+PrintGCDetails ：输出GC的详细日志</li><li> -XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li><li> -XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li><li> -XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li><li> -Xloggc:…/logs/gc.log ：日志文件的输出路径</li></ol><blockquote><p><strong>verbose:gc</strong></p></blockquote><p>1、JVM 参数</p><p><code>-verbose:gc</code></p><p>2、这个只会显示总的GC堆的变化，如下：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0025.png"><p>3、参数解析</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0026.png"><blockquote><p><strong>PrintGCDetails</strong></p></blockquote><p>1、JVM 参数</p><p><code>-XX:+PrintGCDetails</code></p><p>2、输入信息如下</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0027.png"><p>3、参数解析</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0028.png"><blockquote><p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p></blockquote><p>1、JVM 参数</p><p><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></p><p>2、输出信息如下</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0029.png"><p>3、说明：日志带上了日期和时间</p><h3 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h3><ol><li>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li><li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li><li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li><li>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li><li>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li><li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul><li>  中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>  括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</li></ol><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0030.png"><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0031.png"><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在jdk7 和 jdk8中分别执行</span></span><br><span class="line"><span class="comment"> * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCLogTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK7 中的情况</strong></p><p>1、首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0032.png"><p>2、然后我们将4M对象存入到Eden区中</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0033.png"><p>老年代图画的有问题，free应该是4M</p><p><strong>JDK8 中的情况</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.java.GCLogTest1</span><br><span class="line">[GC (Allocation Failure) [DefNew: 6322K-&gt;668K(9216K), <span class="number">0.0034812</span> secs] 6322K-&gt;4764K(19456K), <span class="number">0.0035169</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> generation   total 9216K, used 7050K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">77</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff23b668</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">65</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff5a71d8</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">40</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffa00020</span>, <span class="number">0x00000000ffa00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 381<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0035.jpg"><p>与 JDK7 不同的是，JDK8 直接判定 4M 的数组为大对象，直接怼到老年区去了</p><h3 id="常用日志分析工具"><a href="#常用日志分析工具" class="headerlink" title="常用日志分析工具"></a>常用日志分析工具</h3><p><strong>保存日志文件</strong></p><p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>，  ./ 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p><p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p><p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>推荐：GCeasy</strong></p><p>在线分析网址：gceasy.io</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0036.jpg"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0037.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0038.png"><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><ol><li> GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</li><li> 即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</li><li> 比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</li><li> 现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</li></ol><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p><ol><li>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</li><li>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</li><li>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</li></ol><p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p><ol><li> 停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li> 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0039.png"><p>总结</p><ol><li> Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li><li> Shenandoah GC的强项：低延迟时间。</li></ol><h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><ol><li>官方文档：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></li><li>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</li><li>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</li><li>ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。</li><li>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</li></ol><p><strong>吞吐量</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0040.png"><p>max-JOPS：以低延迟为首要前提下的数据</p><p>critical-JOPS：不考虑低延迟下的数据</p><p><strong>低延迟</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0041.png"><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0042.png"><ol><li><p>JDK14之前，ZGC仅Linux才支持。</p></li><li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p></li><li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p><p> -XX:+UnlockExperimentalVMOptions-XX：+UseZGC</p></li></ol><h3 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/JVM/chapter_012/0043.png">]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第11章-垃圾回收相关概念</title>
      <link href="post/4d401a8b.html"/>
      <url>post/4d401a8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><ol><li>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li><li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</li><li>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了。</strong>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</li></ol><p><strong>代码示例：手动执行 GC 操作</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果发生了GC，这个finalize()一定会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SystemGCTest 重写了finalize()</span><br><span class="line">或</span><br><span class="line">空</span><br></pre></td></tr></table></figure><h3 id="手动-GC-理解不可达对象的回收行为"><a href="#手动-GC-理解不可达对象的回收行为" class="headerlink" title="手动 GC 理解不可达对象的回收行为"></a>手动 GC 理解不可达对象的回收行为</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上参数：  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGC local = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        <span class="comment">//通过在main方法调用这几个方法进行测试</span></span><br><span class="line">        local.localvarGC1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JVM参数：</p><p><code>-Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</code></p><p>1、第四个参数是设置大对象直接进入老年代的阈值，由于我的电脑8G和视频里老师的电脑16G不太一样。我测试的时候10M的数组都是直接进入到了老年代，为了保持一样的效果，我同时设置了堆内存和大对象阈值，尽量和宋红康老师保持一致</p><p>2、我也查过了大对象阈值的默认值</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0001.png"><p>我不太懂这个默认值为啥是0，我猜测可能是代表什么比例，目前也没有搜到相关的东西。这个不太重要，暂时就没有太深究，希望读者有知道的可以告知我一声。</p><blockquote><p>看不懂GC日志请看笔者的  <strong>堆</strong>那篇文章</p></blockquote><p><strong>1、调用 localvarGC1() 方法</strong></p><p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;10728K(76288K)] 15492K-&gt;11000K(251392K), <span class="number">0.0066473</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0<span class="title">K</span><span class="params">(76288K)</span>] [ParOldGen: 272K-&gt;10911<span class="title">K</span><span class="params">(175104K)</span>] 11000K-&gt;10911<span class="title">K</span><span class="params">(251392K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0097940 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faba3ee8</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 10911K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">6</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f0aa7d08</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 387<span class="title">K</span>, <span class="title">capacity</span> 390<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p><strong>2、调用 localvarGC2() 方法</strong></p><p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;808K(76288K)] 15492K-&gt;816K(251392K), <span class="number">0.0294475</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.04</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0<span class="title">K</span><span class="params">(76288K)</span>] [ParOldGen: 8K-&gt;640<span class="title">K</span><span class="params">(175104K)</span>] 816K-&gt;640<span class="title">K</span><span class="params">(251392K)</span>, [Metaspace: 3385K-&gt;3385<span class="title">K</span><span class="params">(1056768K)</span>], 0.0054210 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">3</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faceb9e0</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 640K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f00a01a8</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3392K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 379<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p><strong>3、调用 localvarGC3() 方法</strong></p><p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="number">0.0070281</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0<span class="title">K</span><span class="params">(76288K)</span>] [ParOldGen: 10248K-&gt;10900<span class="title">K</span><span class="params">(175104K)</span>] 11088K-&gt;10900<span class="title">K</span><span class="params">(251392K)</span>, [Metaspace: 3386K-&gt;3386<span class="title">K</span><span class="params">(1056768K)</span>], 0.0084464 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">3</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faceb9e0</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 10900K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">6</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f0aa52e8</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3393K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 379<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>1、来看看字节码：实例方法局部变量表第一个变量肯定是 this</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0002.png"><p>2、你有没有看到，局部变量表的大小是 2。但是局部变量表里只有一个索引为0的啊？那索引为1的是哪个局部变量呢？实际上索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0003.png"><p>3、那么这种代码块的情况，什么时候会被GC呢？我们来看第四个方法</p><p><strong>4、调用 localvarGC4() 方法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;776K(76288K)] 15492K-&gt;784K(251392K), 0.0009430 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;646K(175104K)] 784K-&gt;646K(251392K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0065829 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 65536K, 3% used [0x00000000fab00000,0x00000000faceb9f8,0x00000000feb00000)</span><br><span class="line">  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)</span><br><span class="line">  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 175104K, used 646K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000000f0000000,0x00000000f00a1b88,0x00000000fab00000)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p><p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p><blockquote><p>这点看不懂的可以看我前面的文章：虚拟机栈 –&gt; Slot的重复利用</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0004.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0005.png"><p><strong>调用 localvarGC5() 方法</strong></p><p>局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="number">0.0070281</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0<span class="title">K</span><span class="params">(76288K)</span>] [ParOldGen: 10248K-&gt;10911<span class="title">K</span><span class="params">(175104K)</span>] 11088K-&gt;10911<span class="title">K</span><span class="params">(251392K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0082011 secs] [Times: user</span>=<span class="number">0.03</span> sys=<span class="number">0.03</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10911K-&gt;10911K(251392K), <span class="number">0.0004440</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(76288K)</span>] [ParOldGen: 10911K-&gt;671<span class="title">K</span><span class="params">(175104K)</span>] 10911K-&gt;671<span class="title">K</span><span class="params">(251392K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0108555 secs] [Times: user</span>=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faba3ee8</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 671K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f00a7cf8</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3499K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 387<span class="title">K</span>, <span class="title">capacity</span> 390<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ol><li> 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li> 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li><li> 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li> Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ol><p><strong>内存溢出（OOM）原因分析</strong></p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li>Java虚拟机的堆内存设置不够。<ul><li>  比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li></ul></li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<ul><li>  对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li><li>  随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li></ul></li></ol><ol><li>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。<ul><li>  例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li><li>  在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li></ul></li><li>当然，也不是在任何情况下垃圾收集器都会被触发的<ul><li>  比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li></ul></li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol><li>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></li><li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</li><li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</li><li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li></ol><p><strong>内存泄露官方例子</strong></p><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p><p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0006.png"><p><strong>常见例子</strong></p><ol><li>单例模式<ul><li>  单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li></ul></li><li>一些提供close()的资源未关闭导致内存泄漏<ul><li>  数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li></ul></li></ol><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h2><ol><li>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</li><li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul></li><li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li></ol><ol><li>STW事件和采用哪款GC无关，所有的GC都有这个事件。</li><li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</li><li>STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li><li>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</li></ol><h3 id="代码感受-Stop-the-World"><a href="#代码感受-Stop-the-World" class="headerlink" title="代码感受 Stop the World"></a>代码感受 Stop the World</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopTheWorldDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(list.size() &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span></span><br><span class="line">                     </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="keyword">long</span> t = System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkThread w = <span class="keyword">new</span> WorkThread();</span><br><span class="line">        PrintThread p = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">2.2</span></span><br><span class="line"><span class="number">3.2</span></span><br><span class="line"><span class="number">4.3</span></span><br><span class="line"><span class="number">5.3</span></span><br><span class="line"><span class="number">6.3</span></span><br><span class="line"><span class="number">7.3</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.3s ，可以明显感受到 Stop the World 的存在</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="number">2.7</span></span><br><span class="line"><span class="number">3.8</span></span><br><span class="line"><span class="number">4.12</span></span><br><span class="line"><span class="number">5.13</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><ol><li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li><li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0007.png"><h3 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h3><ol><li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</li><li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0008.png"><blockquote><p><strong>并发与并行的对比</strong></p></blockquote><ol><li> 并发，指的是多个事情，在同一时间段内同时发生了。</li><li> 并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。</li><li> 并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li><li> 只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ol><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><ol><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>  如ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行（Serial）<ul><li>  相较于并行的概念，单线程执行。</li><li>  如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0009.png"><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ol><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li></ul></li><li> 典型垃圾回收器：CMS、G1</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0010.png"><h2 id="HotSpot的算法实现细节"><a href="#HotSpot的算法实现细节" class="headerlink" title="HotSpot的算法实现细节"></a>HotSpot的算法实现细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>1、固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。 </p><p>2、迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p><p>3、由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</p><p>4、Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative/Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</p><blockquote><p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p></blockquote><h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点（Safepoint）</strong></p><ol><li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</li><li>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</li></ol><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ol><li> 抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li> 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ol><p><strong>安全区域（Safe Region）</strong></p><ol><li> Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li><li> 例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li><li> <strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li></ol><p><strong>安全区域的执行流程</strong></p><ol><li> 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li> 当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ol><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h4><p>1、一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0011.png"><p>2、如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</p><p>3、所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</p><p>4、因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></p><h4 id="记忆集与卡表-1"><a href="#记忆集与卡表-1" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>1、为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p><p>2、记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p><blockquote><p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p></blockquote><p>3、这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 </li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 </li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>4、其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p><blockquote><p>读者只需要知道有这个东西，面试的时候能说出来，再细致一点的就需要看周志明老师的第三版书了</p></blockquote><h2 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h2><ol><li>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</li><li>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</li><li>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：<ul><li>  强引用（Strong Reference）</li><li>  软引用（Soft Reference）</li><li>  弱引用（Weak Reference）</li><li>  虚引用（Phantom Reference）</li></ul></li><li>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0012.png" ><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ol><li> 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</li><li> 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li> 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li> 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><ol><li>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</li><li>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li><li><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</li><li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li><li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li></ol><p><strong>强引用代码举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">&quot;Hello,尚硅谷&quot;</span>);</span><br><span class="line">        StringBuffer str1 = str;</span><br><span class="line"></span><br><span class="line">        str = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello,尚硅谷</span><br></pre></td></tr></table></figure><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_011/0013.png"><p><strong>总结</strong></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ol><li> 强引用可以直接访问目标对象。</li><li> 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li> 强引用可能导致内存泄漏。</li></ol><h2 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h2><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ol><li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</li><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li><li>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</li></ol><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><p><strong>软引用代码举例</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line"><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> SoftReference&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="keyword">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---目前内存还不紧张---&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line"><span class="comment">//        //垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---下面开始内存紧张了---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024 * 1024 * 7];</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">635</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JVM参数</p><p><code>-Xms10m -Xmx10m</code></p><p>在 JVM 内存不足时，会清理软引用对象</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">---目前内存还不紧张---</span><br><span class="line">After GC:</span><br><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">---下面开始内存紧张了---</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java1.SoftReferenceTest.main(SoftReferenceTest.java:<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote><p><strong>弱引用（Weak Reference）发现即回收</strong></p></blockquote><ol><li><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</p></li><li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p></li><li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p></li><li><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p></li></ol><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p><strong>面试题：你开发中使用过WeakHashMap吗？</strong></p><p><strong>弱引用代码举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行垃圾回收后，软引用对象必定被清除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">After GC:</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ol><li>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></li><li><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ol><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>; </span><br></pre></td></tr></table></figure><p><strong>虚引用代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">System.out.println(<span class="string">&quot;第 1 次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p><p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">第 <span class="number">1</span> 次 gc</span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 <span class="number">2</span> 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：终结器引用（了解）"><a href="#再谈引用：终结器引用（了解）" class="headerlink" title="再谈引用：终结器引用（了解）"></a>再谈引用：终结器引用（了解）</h2><ol><li>它用于实现对象的finalize() 方法，也可以称为终结器引用</li><li>无需手动编码，其内部配合引用队列使用</li><li> 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第10章-垃圾回收概述和相关算法</title>
      <link href="post/d54daa0f.html"/>
      <url>post/d54daa0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0001.png"><ol><li>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</li><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li><li>关于垃圾收集有三个经典问题：<ul><li>  哪些内存需要回收？</li><li>  什么时候回收？</li><li>  如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li></ol><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><ol><li> 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li><li> JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li><li> G1回收器讲下回收过程GC是什么？为什么要有GC？</li><li> GC的两种判定方法？CMS收集器与G1收集器的特点</li></ol><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ol><li> 说一下GC算法，分代回收说下</li><li> 垃圾收集策略和算法</li></ol><h3 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h3><ol><li> JVM GC原理，JVM怎么回收内存</li><li> CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ol><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ol><li> Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li></ol><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ol><li> 你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li><li> 包括原理，流程，优缺点。垃圾回收算法的实现原理</li></ol><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ol><li> 讲一讲垃圾回收算法。</li><li> 什么情况下触发垃圾回收？</li><li> 如何选择合适的垃圾收集算法？</li><li> JVM有哪三种垃圾回收器？</li></ol><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ol><li> 常见的垃圾回收器算法有哪些，各有什么优劣？</li><li> System.gc()和Runtime.gc()会做什么事情？</li><li> Java GC机制？GC Roots有哪些？</li><li> Java对象的回收方式，回收算法。</li><li> CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li> CMS回收停顿了几次，为什么要停顿两次?</li></ol><h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><ol><li> 垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li> 外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li><li> 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ol><p><strong>十几年前磁盘碎片整理的日子</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0002.jpg"><h2 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><ol><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li><li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li></ol><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ol><li> 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li></ol>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line"><span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure><ol start="2"><li>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</li><li> 有了垃圾回收机制后，上述代码极有可能变成这样</li></ol>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> cmBaseGroupBridge(); </span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure><ol start="4"><li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li></ol><h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><blockquote><p><strong>官网介绍</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></blockquote><p><strong>自动内存管理的优点</strong></p><ol><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</li><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ol><p><strong>关于自动内存管理的担忧</strong></p><ol><li> 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li> 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li> 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ol><h3 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0003.png"><ol><li><p> 垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p></li><li><p> 其中，<strong>Java堆是垃圾收集器的工作重点</strong></p></li><li><p>从次数上讲：</p><ol><li> 频繁收集Young区</li><li> 较少收集Old区</li><li> 基本不收集Perm区（元空间）</li></ol></li></ol><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><ol><li> 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li><li> 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li> 判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li></ol><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ol><li> 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li><li> 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li><li> 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ol><li> 它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li> 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li> 引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ol></li></ol><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0004.png"><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p><h3 id="证明：java使用的不是引用计数算法"><a href="#证明：java使用的不是引用计数算法" class="headerlink" title="证明：java使用的不是引用计数算法"></a>证明：java使用的不是引用计数算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0005.png"><ul><li>如果不小心直接把<code>obj1.reference</code>和<code>obj2.reference</code>置为null。则在Java堆中的两块内存依然保持着互相引用，无法被回收</li></ul><p><strong>没有进行GC时</strong></p><p>把下面的几行代码注释掉，让它来不及</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();<span class="comment">//把这行代码注释掉</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 14234K [0x00000000d5f80000, 0x00000000d8a00000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 42% used [0x00000000d5f80000,0x00000000d6d66be8,0x00000000d8000000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8500000,0x00000000d8500000,0x00000000d8a00000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8000000,0x00000000d8000000,0x00000000d8500000)</span><br><span class="line"> ParOldGen       total 87552K, used 0K [0x0000000081e00000, 0x0000000087380000, 0x00000000d5f80000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081e00000,0x0000000081e00000,0x0000000087380000)</span><br><span class="line"> Metaspace       used 3496K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>进行GC</strong></p><p>打开那行代码的注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 13569K-&gt;808K(38400K)] 13569K-&gt;816K(125952K), <span class="number">0.0012717</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0<span class="title">K</span><span class="params">(38400K)</span>] [ParOldGen: 8K-&gt;670<span class="title">K</span><span class="params">(87552K)</span>] 816K-&gt;670<span class="title">K</span><span class="params">(125952K)</span>, [Metaspace: 3491K-&gt;3491<span class="title">K</span><span class="params">(1056768K)</span>], 0.0051769 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [<span class="number">0x00000000d5f80000</span>, <span class="number">0x00000000d8a00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 33280K, <span class="number">1</span>% used [<span class="number">0x00000000d5f80000</span>,<span class="number">0x00000000d5fd34a8</span>,<span class="number">0x00000000d8000000</span>)</span><br><span class="line">  from space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8500000</span>)</span><br><span class="line">  to   space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8a00000</span>)</span><br><span class="line"> ParOldGen       total 87552K, used 670K [<span class="number">0x0000000081e00000</span>, <span class="number">0x0000000087380000</span>, <span class="number">0x00000000d5f80000</span>)</span><br><span class="line">  object space 87552K, <span class="number">0</span>% used [<span class="number">0x0000000081e00000</span>,<span class="number">0x0000000081ea7990</span>,<span class="number">0x0000000087380000</span>)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 387<span class="title">K</span>, <span class="title">capacity</span> 390<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">finished</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">code</span> 0</span></span><br></pre></td></tr></table></figure><p>1、从打印日志就可以明显看出来，已经进行了GC</p><p>2、如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li> 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li> 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li> Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>Python如何解决循环引用？<ul><li>  手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>  使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul></li></ol><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ol><li> 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li> 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ol><h3 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h3><ul><li><p>所谓”GCRoots”根集合就是一组必须活跃的引用</p></li><li><p>其基本思路如下：</p></li></ul><ol><li> 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li> 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li> 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li> 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0006.png"><h3 id="GC-Roots可以是哪些元素？"><a href="#GC-Roots可以是哪些元素？" class="headerlink" title="GC Roots可以是哪些元素？"></a>GC Roots可以是哪些元素？</h3><ol><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li> 本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（StringTable）里的引用</li></ul></li><li> 所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ul></li><li> 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0007.png"><ol><li> 总结一句话就是，除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</li><li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。<ul><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul></li></ol><p><strong>小技巧</strong></p><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li> 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li> 这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ol><h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><h3 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p><ol><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li></ol><p>Object 类中 finalize() 源码</p><pre><code>// 等待被重写protected void finalize() throws Throwable &#123; &#125;</code></pre><ol><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ol><li> 在finalize()时可能会导致对象复活。</li><li> finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li> 一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ol></li><li> 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li><li> finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ol><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ol><li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ol><li> 可触及的：从根节点开始，可以到达这个对象。</li><li> 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li> 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ol></li><li> 以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li> 如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ol><li> 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li> 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li> finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li></ol></li></ol><p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0008.png"><h3 id="代码演示-finalize-方法可复活对象"><a href="#代码演示-finalize-方法可复活对象" class="headerlink" title="代码演示 finalize() 方法可复活对象"></a>代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanReliveObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> CanReliveObj();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如果注释掉finalize()方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此方法只能被调用一次</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.finalize();</span><br><span class="line">       System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">       obj = <span class="keyword">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure><p><strong>放开finalize()方法</strong></p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT-介绍"><a href="#MAT-介绍" class="headerlink" title="MAT 介绍"></a>MAT 介绍</h3><ol><li> MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li><li> MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li><li> 大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></li></ol><blockquote><p>1、虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些</p><p>2、此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件</p></blockquote><h3 id="获取-dump-文件方式"><a href="#获取-dump-文件方式" class="headerlink" title="获取 dump 文件方式"></a>获取 dump 文件方式</h3><p><strong>方式一：命令行使用 jmap</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0009.png"><p><strong>方式二：使用JVisualVM</strong></p><ol><li> 捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</li><li> 操作步骤下面演示</li></ol><h3 id="捕捉-dump-示例"><a href="#捕捉-dump-示例" class="headerlink" title="捕捉 dump 示例"></a>捕捉 dump 示例</h3><h4 id="使用JVisualVM捕捉-heap-dump"><a href="#使用JVisualVM捕捉-heap-dump" class="headerlink" title="使用JVisualVM捕捉 heap dump"></a>使用JVisualVM捕捉 heap dump</h4><p>代码：</p><ul><li>  numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots</li><li>  之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        numList = <span class="keyword">null</span>;</span><br><span class="line">        birth = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如何捕捉堆内存快照</strong></p><p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0010.png"><p>2、 点击【堆 Dump】</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0011.png"><p>3、右键 –&gt; 另存为即可</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0012.jpg"><p>4、输入命令，继续执行程序</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0013.png"><p>5、我们接着捕获第二张堆内存快照</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0014.jpg"><h4 id="使用-MAT-查看堆内存快照"><a href="#使用-MAT-查看堆内存快照" class="headerlink" title="使用 MAT 查看堆内存快照"></a>使用 MAT 查看堆内存快照</h4><p>1、打开 MAT ，选择File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p><blockquote><p>点击Open Heap Dump也行</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0015.png"><p>2、选择Java Basics –&gt; GC Roots</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0016.png"><p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0017.jpg"><p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries = 19 也可以看出（少了两个 GC Roots）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0018.jpg"><h3 id="JProfiler-GC-Roots-溯源"><a href="#JProfiler-GC-Roots-溯源" class="headerlink" title="JProfiler GC Roots 溯源"></a>JProfiler GC Roots 溯源</h3><p>1、在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></p><p>2、下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p><p>依然用下面这个代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Date birth = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        numList = <span class="keyword">null</span>;</span><br><span class="line">        birth = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0019.jpg"><p>2、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0020.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0021.jpg"><p>可以发现颜色变绿了，可以动态的看变化</p><p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0022.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0023.png"><p>4、选择Incoming References，表示追寻 GC Roots 的源头</p><p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0024.jpg"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0025.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0026.png"><h3 id="JProfiler-分析-OOM"><a href="#JProfiler-分析-OOM" class="headerlink" title="JProfiler 分析 OOM"></a>JProfiler 分析 OOM</h3><blockquote><p>这里是简单的讲一下，后面篇章会详解</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m </span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> HeapOOM());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出日志</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.java.HeapOOM</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid14608.hprof ...</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:<span class="number">12</span>)</span><br><span class="line">at com.atguigu.java.HeapOOM.main(HeapOOM.java:<span class="number">20</span>)</span><br><span class="line">Heap dump file created [<span class="number">7797849</span> bytes in <span class="number">0.010</span> secs]</span><br><span class="line">count = <span class="number">6</span></span><br></pre></td></tr></table></figure><p>打开这个dump文件</p><p>1、看这个超大对象</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0027.png"><p>2、揪出 main() 线程中出问题的代码</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0028.png"><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p><strong>垃圾清除阶段</strong></p><ul><li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</li></ul><ol><li> 标记-清除算法（Mark-Sweep）</li><li> 复制算法（Copying）</li><li> 标记-压缩算法（Mark-Compact）</li></ol><p><strong>背景</strong></p><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><p><strong>执行过程</strong></p><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ol><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul><li>  注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li> 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0029.png"><p><strong>标记-清除算法的缺点</strong></p><ol><li> 标记清除算法的效率不算高</li><li> 在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li> 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ol><p><strong>注意：何为清除？</strong></p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p><p>关于空闲列表是在为对象分配内存的时候提过：</p><ol><li>如果内存规整<ul><li>  采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>  虚拟机需要维护一个空闲列表</li><li>  采用空闲列表分配内存</li></ul></li></ol><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p><strong>背景</strong></p><ol><li> 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li></ol><p><strong>核心思想</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0030.png"><p>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</p><p><strong>复制算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li> 没有标记和清除过程，实现简单，运行高效</li><li> 复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ol><p><strong>缺点</strong></p><ol><li> 此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li> 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ol><p><strong>复制算法的应用场景</strong></p><ol><li> 如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li><li> 老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li><li> 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0031.png"><h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p><p><strong>背景</strong></p><ol><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></li><li>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</li><li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li></ol><p><strong>执行过程</strong></p><ol><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0032.png"><p><strong>标记-压缩算法与标记-清除算法的比较</strong></p><ol><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li><li>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ol><p><strong>标记-压缩算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li> 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li> 消除了复制算法当中，内存减半的高额代价。</li></ol><p><strong>缺点</strong></p><ol><li> 从效率上来说，标记-整理算法要低于复制算法。</li><li> 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li> 移动过程中，需要全程暂停用户应用程序。即：STW</li></ol><h2 id="垃圾回收算法小结"><a href="#垃圾回收算法小结" class="headerlink" title="垃圾回收算法小结"></a>垃圾回收算法小结</h2><blockquote><p><strong>对比三种清除阶段的算法</strong></p></blockquote><ol><li><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p></li><li><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p></li></ol><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>Q：难道就没有一种最优的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><p><strong>为什么要使用分代收集算法</strong></p><ol><li>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li><li>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li><li>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:<ul><li>  比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>  但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ol><p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ol><li>年轻代（Young Gen）<ul><li>  年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>  这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li>老年代（Tenured Gen）<ul><li>  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li><li>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</li><li>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</li></ol><h2 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p><strong>增量收集算法基本思想</strong></p><ol><li> 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></li><li> 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></li></ol><p><strong>增量收集算法的缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><blockquote><p>主要针对G1收集器来说的</p></blockquote><ol><li> 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li> 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_010/0033.png"><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第9章-StringTable(字符串常量池)</title>
      <link href="post/ee2ba71e.html"/>
      <url>post/ee2ba71e.html</url>
      
        <content type="html"><![CDATA[<h1 id="StringTable（字符串常量池）"><a href="#StringTable（字符串常量池）" class="headerlink" title="StringTable（字符串常量池）"></a>StringTable（字符串常量池）</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ol><li> String：字符串，使用一对 “” 引起来表示</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;atguigu&quot;</span> ;   <span class="comment">// 字面量的定义方式</span></span><br><span class="line">String s2 =  <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure><ol start="2"><li>String被声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</li><li>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code></li></ol><h2 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h2><blockquote><p> <strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><ol><li> String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li><li> 从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li><li> 之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</li><li> 结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li><li> 同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value</span><br></pre></td></tr></table></figure><h3 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h3><ul><li>String：代表不可变的字符序列。简称：不可变性。</li></ul><ol><li> 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li> 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li> 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ol><ul><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul><p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">       String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span></span><br><span class="line"></span><br><span class="line">       System.out.println(s1);<span class="comment">//</span></span><br><span class="line">       System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><ul><li>  取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>  取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul><p><strong>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">       System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">       System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一道笔试题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p><h3 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><ol><li> String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li><li> 使用-XX:StringTablesize可设置StringTable的长度</li><li> 在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li> 在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li> 在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0001.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0002.png"><p><strong>测试不同 StringTable 长度下，程序的性能</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw =  <span class="keyword">new</span> FileWriter(<span class="string">&quot;words.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1 - 10</span></span><br><span class="line">           <span class="keyword">int</span> length = (<span class="keyword">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//65 - 90, 97-122</span></span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="keyword">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;</span><br><span class="line">            str += (<span class="keyword">char</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;words.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:143ms  100009:47ms</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>-XX:StringTableSize=1009 ：程序耗时 143ms</li><li>-XX:StringTableSize=100009 ：程序耗时 47ms</li></ul><h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><ol><li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li><li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。<ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈</li></ul></li></ol><ol><li> Java 6及以前，字符串常量池存放在永久代</li><li>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<ul><li>  所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>  字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li> Java8元空间，字符串常量在堆</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0003.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0004.png"><h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><blockquote><p><strong>官方文档</strong>:<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p></blockquote><ol><li>为什么要调整位置？<ul><li>  永久代的默认空间大小比较小</li><li>  永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>  堆中空间足够大，字符串可被及时回收</li></ul></li><li> 在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li> 此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：我真没骗你，字符串真的在堆中（JDK8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.HashMap.resize(HashMap.java:<span class="number">703</span>)</span><br><span class="line">at java.util.HashMap.putVal(HashMap.java:<span class="number">662</span>)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:<span class="number">611</span>)</span><br><span class="line">at java.util.HashSet.add(HashSet.java:<span class="number">219</span>)</span><br><span class="line">at com.atguigu.java.StringTest3.main(StringTest3.java:<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();<span class="comment">//2293</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2294</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2303</span></span><br><span class="line">        <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析字符串常量池的变化</p><p>1、程序启动时已经加载了 2293 个字符串常量</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0005.png"><p>2、加载了一个换行符（println），所以多了一个</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0006.jpg"><p>3、加载了字符串常量 “1”~“9”</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0007.jpg"><p>4、加载字符串常量 “10”</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0008.jpg"><p>5、之后的字符串”1” 到 “10”不会再次加载</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0009.png"><h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方示例代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">        String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0010.png"><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><ol><li> 常量与常量的拼接结果在常量池，原理是编译期优化</li><li> 常量池中不会存在相同内容的变量</li><li> 拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：<ul><li>  如果存在，则返回字符串在常量池中的地址</li><li>  如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ol><p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">9</span> aload_1</span><br><span class="line"><span class="number">10</span> aload_2</span><br><span class="line"><span class="number">11</span> if_acmpne <span class="number">18</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> goto <span class="number">19</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span> iconst_0</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">22 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">25</span> aload_1</span><br><span class="line"><span class="number">26</span> aload_2</span><br><span class="line">27 invokevirtual #5 &lt;java/lang/String.equals&gt;</span><br><span class="line">30 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">33</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>IDEA 反编译 class 文件后，来看这个问题</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0011.png"><p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中</strong></p><p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">        String s8 = s6.intern();</span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #6 &lt;javaEE&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #7 &lt;hadoop&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 ldc #8 &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line">9 ldc #8 &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line">13 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">16</span> dup</span><br><span class="line">17 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">20</span> aload_1</span><br><span class="line">21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">24 ldc #7 &lt;hadoop&gt;</span><br><span class="line">26 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">29 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">32</span> astore <span class="number">5</span></span><br><span class="line">34 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">37</span> dup</span><br><span class="line">38 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">41 ldc #6 &lt;javaEE&gt;</span><br><span class="line">43 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">46</span> aload_2</span><br><span class="line">47 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">50 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">53</span> astore <span class="number">6</span></span><br><span class="line">55 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">58</span> dup</span><br><span class="line">59 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">62</span> aload_1</span><br><span class="line">63 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">66</span> aload_2</span><br><span class="line">67 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">70 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">73</span> astore <span class="number">7</span></span><br><span class="line">75 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">78</span> aload_3</span><br><span class="line"><span class="number">79</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">81</span> if_acmpne <span class="number">88</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">84</span> iconst_1</span><br><span class="line"><span class="number">85</span> goto <span class="number">89</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">88</span> iconst_0</span><br><span class="line">89 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">92 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">95</span> aload_3</span><br><span class="line"><span class="number">96</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">98</span> if_acmpne <span class="number">105</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">101</span> iconst_1</span><br><span class="line"><span class="number">102</span> goto <span class="number">106</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">105</span> iconst_0</span><br><span class="line">106 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">109 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">112</span> aload_3</span><br><span class="line"><span class="number">113</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">115</span> if_acmpne <span class="number">122</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">118</span> iconst_1</span><br><span class="line"><span class="number">119</span> goto <span class="number">123</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">122</span> iconst_0</span><br><span class="line">123 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">126 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">129</span> aload_3</span><br><span class="line"><span class="number">130</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">132</span> if_acmpne <span class="number">139</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">135</span> iconst_1</span><br><span class="line"><span class="number">136</span> goto <span class="number">140</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">139</span> iconst_0</span><br><span class="line">140 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">143 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">146</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">148</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">150</span> if_acmpne <span class="number">157</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">153</span> iconst_1</span><br><span class="line"><span class="number">154</span> goto <span class="number">158</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">157</span> iconst_0</span><br><span class="line">158 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">161 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">164</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">166</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">168</span> if_acmpne <span class="number">175</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">171</span> iconst_1</span><br><span class="line"><span class="number">172</span> goto <span class="number">176</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">175</span> iconst_0</span><br><span class="line">176 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">179 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">182</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">184</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">186</span> if_acmpne <span class="number">193</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">189</span> iconst_1</span><br><span class="line"><span class="number">190</span> goto <span class="number">194</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">193</span> iconst_0</span><br><span class="line">194 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">197</span> aload <span class="number">6</span></span><br><span class="line">199 invokevirtual #13 &lt;java/lang/String.intern&gt;</span><br><span class="line"><span class="number">202</span> astore <span class="number">8</span></span><br><span class="line">204 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">207</span> aload_3</span><br><span class="line"><span class="number">208</span> aload <span class="number">8</span></span><br><span class="line"><span class="number">210</span> if_acmpne <span class="number">217</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">213</span> iconst_1</span><br><span class="line"><span class="number">214</span> goto <span class="number">218</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">217</span> iconst_0</span><br><span class="line">218 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">221</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h3><p><strong>举例1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String s4 = s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #14 &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #15 &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 ldc #16 &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line">9 new #9 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line">13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">16</span> aload_1</span><br><span class="line">17 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">20</span> aload_2</span><br><span class="line">21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">24 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span></span><br><span class="line">29 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">32</span> aload_3</span><br><span class="line"><span class="number">33</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">35</span> if_acmpne <span class="number">42</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">38</span> iconst_1</span><br><span class="line"><span class="number">39</span> goto <span class="number">43</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">42</span> iconst_0</span><br><span class="line">43 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">46</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>举例2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 ldc #14 &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line">3 ldc #15 &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line">6 ldc #16 &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line">9 ldc #16 &lt;ab&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line">13 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> aload_3</span><br><span class="line"><span class="number">17</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">19</span> if_acmpne <span class="number">26</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">22</span> iconst_1</span><br><span class="line"><span class="number">23</span> goto <span class="number">27</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">26</span> iconst_0</span><br><span class="line">27 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>拼接操作与 append 操作的效率对比</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</li><li>原因：<ol><li>StringBuilder的append()的方式：<ul><li>  自始至终中只创建过一个StringBuilder的对象</li></ul></li><li>使用String的字符串拼接方式：<ul><li>  创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li><li>  如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ol></li><li>改进的空间：<ul><li>  在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</li><li>  <code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li><li>  这样可以避免频繁扩容</li></ul></li></ol><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h2><h3 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol><li>intern是一个native方法，调用的是底层C的方法</li><li>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：<pre><code> String myInfo = new string(&quot;I love atguigu&quot;).intern();</code></pre></li><li>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true<pre><code> (&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></pre></li><li>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</li></ol><h3 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h3><h4 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</p><p><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</p><h4 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象？"></a>new String(“a”) + new String(“b”) 会创建几个对象？</h4><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line">4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">7 new #4 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">10</span> dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">22</span> dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">34</span> astore_1</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>答案是4个或5个或6个</strong></p><p>字节码指令分析：</p><ol><li> <code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 StringBuilder 对象</li><li> <code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li><li> <code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li><li> <code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li><li> <code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li><li> <code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0012.png"><h3 id="有点难的面试题"><a href="#有点难的面试题" class="headerlink" title="有点难的面试题"></a>有点难的面试题</h3><blockquote><p><strong>有点难的面试题</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span><br><span class="line"> * 有两种方式：</span><br><span class="line"> * 方式一： String s = <span class="string">&quot;shkstart&quot;</span>;<span class="comment">//字面量定义的方式</span></span><br><span class="line"> * 方式二： 调用intern()</span><br><span class="line"> *         String s = <span class="keyword">new</span> String(<span class="string">&quot;shkstart&quot;</span>).intern();</span><br><span class="line"> *         String s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;shkstart&quot;</span>).toString().intern();</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"><span class="comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span></span><br><span class="line"><span class="comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span></span><br><span class="line"><span class="comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了</span></span><br><span class="line"><span class="comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span></span><br><span class="line"><span class="comment">           中存的是new String（&quot;11&quot;）在堆中的地址</span></span><br><span class="line"><span class="comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//pos_1</span></span><br><span class="line">    s3.intern();</span><br><span class="line">        </span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释的已经比较清楚了，下面看一下内存图</p><p><strong>内存分析</strong></p><p>JDK6 ：正常眼光判断即可</p><ul><li>  new String() 即在堆中</li><li>  str.intern() 则把字符串放入常量池中</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0013.png"><p>JDK7及后续版本，<strong>注意大坑</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0014.png"><h4 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringIntern.java中练习的拓展：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        String s5 = s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="intern-方法的练习"><a href="#intern-方法的练习" class="headerlink" title="intern() 方法的练习"></a>intern() 方法的练习</h3><p><strong>练习 1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span></span><br><span class="line"><span class="comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，  将此引用返回</span></span><br><span class="line"><span class="comment">        3、详解看上面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK6</strong></p><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0015.png" alt="image-20201116113423492"></p><p><strong>JDK7/8</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0016.png"><p><strong>练习2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加一行这个</span></span><br><span class="line">        String x = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line"></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0017.png"><p><strong>练习3</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象内存地址可以使用System.identityHashCode(object)方法获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        s1.intern();</span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(System.identityHashCode(s2));</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern() 的效率测试（空间角度）"></a>intern() 的效率测试（空间角度）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用intern()测试执行效率：空间使用上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line"><span class="comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length]));</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0018.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0019.png"><p>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span></span><br><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0020.png" ><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0021.png"><p><strong>结论</strong>：</p><ol><li> 对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li><li> 大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li></ol><h2 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><ul><li>  在 PSYoungGen 区发生了垃圾回收</li><li>  Number of entries 和 Number of literals 明显没有 100000</li><li>  以上两点均说明 StringTable 区发生了垃圾回收</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0022.jpg"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_009/0023.jpg"/><h2 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h2><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p></blockquote><p>暂时了解一下，后面会详解垃圾回收器</p><p><strong>String去重操作的背景</strong></p><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ol><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>  堆存活数据集合里面String对象占了25%</li><li>  堆存活数据集合里面重复的String对象有13.5%</li><li>  String对象的平均长度是45</li></ul></li><li> 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ol><p><strong>String 去重的的实现</strong></p><ol><li> 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li> 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li> 使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li> 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li> 如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><ol><li> UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li> PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li> stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第8章-执行引擎</title>
      <link href="post/408712f4.html"/>
      <url>post/408712f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0001.png"><h3 id="执行引擎概述-1"><a href="#执行引擎概述-1" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h3><ol><li> 执行引擎是Java虚拟机核心的组成部分之一。</li><li> “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li><li> JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li> 那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0002.png"><p>1、前端编译：从Java程序员-字节码文件的这个过程叫前端编译</p><p>2、执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p><h3 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h3><blockquote><p><strong>执行引擎工作过程</strong></p></blockquote><ol><li> 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li> 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li> 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li> 从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0003.png"><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><h3 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h3><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><ol><li>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</li><li>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0004.png">    <ol start="3"><li><p>javac编译器（前端编译器）流程图如下所示：</p> <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0005.png"></li><li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p> <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0006.png"></li></ol><h3 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h3><ol><li> 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li> JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ol><p><strong>为什么Java是半编译半解释型语言？</strong></p><ol><li> JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li> 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li> JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ol><p><strong>用图总结一下</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0007.png"><h2 id="机器码-指令-汇编语言"><a href="#机器码-指令-汇编语言" class="headerlink" title="机器码 指令 汇编语言"></a>机器码 指令 汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ol><li> 各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li> 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li> 用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li> 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ol><h3 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h3><p><strong>指令</strong></p><ol><li>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li><li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li></ol><p><strong>指令集</strong></p><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p><ol><li> x86指令集，对应的是x86架构的平台</li><li> ARM指令集，对应的是ARM架构的平台</li></ol><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ol><li> 由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li> 在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li> 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li><li> 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li></ol><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ol><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0008.png"><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ol><li><p> 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p></li><li><p> 字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p></li><li><p> 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p></li><li><p> 字节码典型的应用为：Java bytecode</p></li></ol><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ol><li>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li><li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0009.png"><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h3><ol><li>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</li><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0010.png"><h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ol><li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul><li>  字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>  而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>  Interpreter模块：实现了解释器的核心功能</li><li>  Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ol><h3 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h3><ol><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ol><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h3><ol><li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</li></ol><ol><li> HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li><li> 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</li></ol><h3 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h3><ol><li>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</li><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ol><p><strong>首先明确两点：</strong></p><ol><li> 当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li> 编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li> 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li> 在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li> 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li></ul><ol><li>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</li><li>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0011.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JITTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;让天下没有难学的技术&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JVisualVM 查看 JIT 编译器执行的编译次数</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0012.png"><h3 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h3><ol><li> Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li> 也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li> 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ol><p><strong>典型的编译器：</strong></p><ol><li> 前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li> JIT编译器：HotSpot VM的C1、C2编译器。</li><li> AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ol><h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><ol><li> 当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li> 关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li> 一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li> 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li> <strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li> 方法调用计数器用于统计方法的调用次数</li><li> 回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ol><li>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li><li>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</li><li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本<ul><li>  如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>  如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>  如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0013.png"><h4 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h4><ol><li> 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li> 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li> 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ol><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0014.png"><h3 id="HotSpotVM可以设置程序执行方法"><a href="#HotSpotVM可以设置程序执行方法" class="headerlink" title="HotSpotVM可以设置程序执行方法"></a>HotSpotVM可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ol><li> -Xint：完全采用解释器模式执行程序；</li><li> -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li> -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_008/0015.png"><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 6520ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 950ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 936ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntCompTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPrimeNumber</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(j);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论：只用解释器执行是真的慢</p><h3 id="HotSpotVM-JIT-分类"><a href="#HotSpotVM-JIT-分类" class="headerlink" title="HotSpotVM JIT 分类"></a>HotSpotVM JIT 分类</h3><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ol><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>  C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul><li>  C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ol><h3 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h3><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul><li>  方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>  去虚拟化：对唯一的实现樊进行内联</li><li>  冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>  标量替换：用标量值代替聚合对象的属性值</li><li>  栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>  同步消除：清除同步操作，通常指synchronized</li></ul></li></ol><blockquote><p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p></blockquote><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><ol><li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li><li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</li></ol><ol><li> 一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li><li> C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ol><h4 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h4><ul><li><p>  自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p></li><li><p>  编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p></li><li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p><p>  -XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</p></li></ul><h4 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h4><ol><li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><p> .java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p></li></ol><p><strong>AOT编译器编译器的优缺点</strong></p><p><strong>最大的好处：</strong></p><ol><li> Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li> 不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ol><p><strong>缺点：</strong></p><ol><li> 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li> 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li> 还需要继续优化中，最初只支持Linux X64 java base</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第7章-对象的实例化内存布局与访问定位</title>
      <link href="post/debff71a.html"/>
      <url>post/debff71a.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象的实例化内存布局与访问定位"><a href="#对象的实例化内存布局与访问定位" class="headerlink" title="对象的实例化内存布局与访问定位"></a>对象的实例化内存布局与访问定位</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><p><strong>大厂面试题</strong></p><p>美团：</p><ol><li> 对象在<code>JVM</code>中是怎么存储的？</li><li> 对象头信息里面有哪些东西？</li></ol><p>蚂蚁金服：</p><p>二面：<code>java</code>对象头里有什么</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_007/0001.png"><h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><ol><li> new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li> Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</li><li> Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li><li> 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</li><li> 使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li><li> 第三方库 Objenesis</li></ol><h3 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h3><blockquote><p><strong>从字节码看待对象的创建过程</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">         3: dup           </span><br><span class="line">         4: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            8       1     1   obj   Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><ol><li> 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li><li> 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li></ol><p><strong>2、为对象分配内存</strong></p><ol><li> 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用指针碰撞分配内存<ul><li>  如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>  意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>  如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>  标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li>如果内存不规整<ul><li>  如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>  意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li><li>  选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>  标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ol><p><strong>3、处理并发问题</strong></p><ol><li> 采用CAS+失败重试保证更新的原子性</li><li> 每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li><li> 在Eden区给每个线程分配一块区域</li></ol><p><strong>4、初始化分配到的空间</strong></p><ul><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li><li><p>给对象属性赋值的顺序：</p></li></ul><ol><li> 属性的默认值初始化</li><li> 显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li> 构造器初始化</li></ol><p><strong>5、设置对象的对象头</strong></p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p><strong>6、执行init方法进行初始化</strong></p><ol><li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</li><li>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</li></ol><blockquote><p><strong>从字节码角度看 init 方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试对象实例化的过程</span></span><br><span class="line"><span class="comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span></span><br><span class="line"><span class="comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  给对象的属性赋值的操作：</span></span><br><span class="line"><span class="comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Customer类的字节码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0</span><br><span class="line"> 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">4</span> aload_0</span><br><span class="line"> <span class="number">5</span> sipush <span class="number">1001</span></span><br><span class="line"> 8 putfield #2 &lt;com/atguigu/java/Customer.id&gt;</span><br><span class="line"><span class="number">11</span> aload_0</span><br><span class="line">12 ldc #3 &lt;匿名客户&gt;</span><br><span class="line">14 putfield #4 &lt;com/atguigu/java/Customer.name&gt;</span><br><span class="line"><span class="number">17</span> aload_0</span><br><span class="line">18 new #5 &lt;com/atguigu/java/Account&gt;</span><br><span class="line"><span class="number">21</span> dup</span><br><span class="line">22 invokespecial #6 &lt;com/atguigu/java/Account.&lt;init&gt;&gt;</span><br><span class="line">25 putfield #7 &lt;com/atguigu/java/Customer.acct&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>init() 方法的字节码指令：<ul><li>  属性的默认值初始化：<code>id = 1001;</code></li><li>  显示初始化/代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li><li>构造器初始化：<code>acct = new Account();</code></li></ul></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_007/0002.png"><blockquote><p><strong>内存布局总结</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust = <span class="keyword">new</span> Customer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解内存布局</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_007/0003.png"><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_007/0004.png"><p>定位，通过栈上reference访问</p><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><p><strong>1、句柄访问</strong></p><ol><li> 缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li> 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_007/0005.png"><p><strong>2、直接指针（HotSpot采用）</strong></p><ol><li> 优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li><li> 缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_007/0006.png">]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第6章-方法区</title>
      <link href="post/136cd965.html"/>
      <url>post/136cd965.html</url>
      
        <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>从线程共享与否的角度来看</strong></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0001.png"><p><strong>栈、堆、方法区的交互关系</strong></p><p><strong>下面涉及了对象的访问定位</strong></p><ol><li> Person 类的 .class 信息存放在方法区中</li><li> person 变量存放在 Java 栈的局部变量表中</li><li> 真正的 person 对象存放在 Java 堆中</li><li> 在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0002.png"><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><h3 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h3><ol><li> 《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li> 所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0003.png"><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p><ol><li> 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li> 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li> 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li> 关闭JVM就会释放这个区域的内存。</li></ol><p><strong>代码举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的程序，加载了1600多个类</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0004.png"><h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h3><ol><li> 在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li><li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）</li></ul></li><li> 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li><li> 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li><li> 永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li> 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0005.png"><h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h3><ol><li> 通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li> -XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li> 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0006.png"><h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><blockquote><p><strong>JDK8 版本设置元空间大小</strong></p></blockquote><ol><li>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</li><li>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</li><li> -XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</li></ol><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>举例：</p><p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OOMTest test = <span class="keyword">new</span> OOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>不设置元空间的上限</strong></p><p>使用默认的 JVM 参数，元空间不设置上限</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p><strong>设置元空间的上限</strong></p><p>JVM 参数</p><p>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8531</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br></pre></td></tr></table></figure><h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ol><li> 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li> <strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li><li> 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li> 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0007.png"><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0008.png"><p><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li> 这个类型的完整有效名称（全名=包名.类名）</li><li> 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li> 这个类型的修饰符（public，abstract，final的某个子集）</li><li> 这个类型直接接口的一个有序列表</li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p></blockquote><ol><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li> 域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li> 方法名称</li><li> 方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li> 方法参数的数量和类型（按顺序）</li><li> 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li> 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li> 异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 测试方法区的内部构成</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p><ul><li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li></ul><p>字节码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter09/com/atguigu/java/MethodInnerStrucTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">13</span>; size <span class="number">1626</span> bytes</span><br><span class="line">  MD5 checksum 0d0fcb54854d4ce183063df985141ad0</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #18.#52        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #17.#53        // com/atguigu/java/MethodInnerStrucTest.num:I</span><br><span class="line">   #3 = Fieldref           #54.#55        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Class              #56            // java/lang/StringBuilder</span><br><span class="line">   #5 = Methodref          #4.#52         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 = String             #57            // count =</span><br><span class="line">   #7 = Methodref          #4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">   #8 = Methodref          #4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">   #9 = Methodref          #4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #10 = Methodref          #61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #11 = Class              #63            // java/lang/Exception</span><br><span class="line">  #12 = Methodref          #11.#64        // java/lang/Exception.printStackTrace:()V</span><br><span class="line">  #13 = Class              #65            // java/lang/String</span><br><span class="line">  #14 = Methodref          #17.#66        // com/atguigu/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span><br><span class="line">  #15 = String             #67            // 测试方法的内部结构</span><br><span class="line">  #16 = Fieldref           #17.#68        // com/atguigu/java/MethodInnerStrucTest.str:Ljava/lang/String;</span><br><span class="line">  #17 = Class              #69            // com/atguigu/java/MethodInnerStrucTest</span><br><span class="line">  #18 = Class              #70            // java/lang/Object</span><br><span class="line">  #19 = Class              #71            // java/lang/Comparable</span><br><span class="line">  #20 = Class              #72            // java/io/Serializable</span><br><span class="line">  #21 = Utf8               num</span><br><span class="line">  #22 = Utf8               I</span><br><span class="line">  #23 = Utf8               str</span><br><span class="line">  #24 = Utf8               Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               &lt;init&gt;</span><br><span class="line">  #26 = Utf8               ()V</span><br><span class="line">  #27 = Utf8               Code</span><br><span class="line">  #28 = Utf8               LineNumberTable</span><br><span class="line">  #29 = Utf8               LocalVariableTable</span><br><span class="line">  #30 = Utf8               this</span><br><span class="line">  #31 = Utf8               Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">  #32 = Utf8               test1</span><br><span class="line">  #33 = Utf8               count</span><br><span class="line">  #34 = Utf8               test2</span><br><span class="line">  #35 = Utf8               (I)I</span><br><span class="line">  #36 = Utf8               value</span><br><span class="line">  #37 = Utf8               e</span><br><span class="line">  #38 = Utf8               Ljava/lang/Exception;</span><br><span class="line">  #39 = Utf8               cal</span><br><span class="line">  #40 = Utf8               result</span><br><span class="line">  #41 = Utf8               StackMapTable</span><br><span class="line">  #42 = Class              #63            // java/lang/Exception</span><br><span class="line">  #43 = Utf8               compareTo</span><br><span class="line">  #44 = Utf8               (Ljava/lang/String;)I</span><br><span class="line">  #45 = Utf8               o</span><br><span class="line">  #46 = Utf8               (Ljava/lang/Object;)I</span><br><span class="line">  #47 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #48 = Utf8               Signature</span><br><span class="line">  #49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">  #50 = Utf8               SourceFile</span><br><span class="line">  #51 = Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #52 = NameAndType        #25:#26        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #53 = NameAndType        #21:#22        // num:I</span><br><span class="line">  #54 = Class              #73            // java/lang/System</span><br><span class="line">  #55 = NameAndType        #74:#75        // out:Ljava/io/PrintStream;</span><br><span class="line">  #56 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #57 = Utf8               count =</span><br><span class="line">  #58 = NameAndType        #76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #59 = NameAndType        #76:#78        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #60 = NameAndType        #79:#80        // toString:()Ljava/lang/String;</span><br><span class="line">  #61 = Class              #81            // java/io/PrintStream</span><br><span class="line">  #62 = NameAndType        #82:#83        // println:(Ljava/lang/String;)V</span><br><span class="line">  #63 = Utf8               java/lang/Exception</span><br><span class="line">  #64 = NameAndType        #84:#26        // printStackTrace:()V</span><br><span class="line">  #65 = Utf8               java/lang/String</span><br><span class="line">  #66 = NameAndType        #43:#44        // compareTo:(Ljava/lang/String;)I</span><br><span class="line">  #67 = Utf8               测试方法的内部结构</span><br><span class="line">  #68 = NameAndType        #23:#24        // str:Ljava/lang/String;</span><br><span class="line">  #69 = Utf8               com/atguigu/java/MethodInnerStrucTest</span><br><span class="line">  #70 = Utf8               java/lang/Object</span><br><span class="line">  #71 = Utf8               java/lang/Comparable</span><br><span class="line">  #72 = Utf8               java/io/Serializable</span><br><span class="line">  #73 = Utf8               java/lang/System</span><br><span class="line">  #74 = Utf8               out</span><br><span class="line">  #75 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #76 = Utf8               append</span><br><span class="line">  #77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #78 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #79 = Utf8               toString</span><br><span class="line">  #80 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #81 = Utf8               java/io/PrintStream</span><br><span class="line">  #82 = Utf8               println</span><br><span class="line">  #83 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #84 = Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法信息</span></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">4</span>: istore_2</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: idiv</span><br><span class="line">         <span class="number">8</span>: istore_1</span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        14: invokevirtual #12                 // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">27</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">26</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>       <span class="number">4</span>     <span class="number">2</span> value   I</span><br><span class="line">           <span class="number">13</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>   cal   I</span><br><span class="line">            <span class="number">2</span>      <span class="number">17</span>     <span class="number">1</span> result   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">12</span></span><br><span class="line">          locals = [ <span class="keyword">int</span>, <span class="keyword">int</span> ]</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">1</span>     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         2: checkcast     #13                 // class java/lang/String</span><br><span class="line">         5: invokevirtual #14                 // Method compareTo:(Ljava/lang/String;)I</span><br><span class="line">         <span class="number">8</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: ldc           #15                 // String 测试方法的内部结构</span><br><span class="line">         2: putstatic     #16                 // Field str:Ljava/lang/String;</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #49                          // Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>类型信息</strong></p><p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><strong>域信息</strong></p><ol><li> descriptor: I 表示字段类型为 Integer</li><li> flags: ACC_PUBLIC 表示字段权限修饰符为 public</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure><p><strong>方法信息</strong></p><ol><li> descriptor: ()V 表示方法返回值类型为 void</li><li> flags: ACC_PUBLIC 表示方法权限修饰符为 public</li><li> stack=3 表示操作数栈深度为 3</li><li> locals=2 表示局部变量个数为 2 个（实力方法包含 this）</li><li> test1() 方法虽然没有参数，但是其 args_size=1 ，这时因为将 this 作为了参数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h3><ol><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ol><p><strong>举例</strong></p><ol><li> 如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li><li> 这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h4><ol><li>全局常量就是使用 static final 进行修饰</li><li>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li></ol><p>查看上面代码，这部分的字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h4 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h4><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p>后面会细讲常量池，这里为了讲清楚方法区，简单带一下。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0009.png"><ol><li> 方法区，内部包含了运行时常量池</li><li> 字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li> 要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li> 要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ol><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ol><li> 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li><li> 字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0010.png"><p><strong>为什么需要常量池？</strong></p><ol><li> 一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍</li></ol><p>比如：如下的代码：</p><pre><code>public class SimpleClass &#123;    public void sayHello() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><ol><li> 虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li> 比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li> 这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0011.png"><p><strong>常量池中有啥？</strong></p><ol><li> 数量值</li><li> 字符串值</li><li> 类引用</li><li> 字段引用</li><li> 方法引用</li></ol><p>MethodInnerStrucTest 的 test1方法的字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> 3 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"> 6 new #4 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line">10 invokespecial #5 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">13 ldc #6 &lt;count = &gt;</span><br><span class="line">15 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line">19 invokevirtual #8 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">22 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">25 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>1、#3，#5等等这些带# 的，都是引用了常量池。</p><p><strong>常量池总结</strong></p><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol><li> 运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li> 常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li><li> 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li> JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li> 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</li></ol><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</li></ul><ol start="6"><li> 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li> 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ol><h2 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">MethodAreaDemo</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #27.#28        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #29            // com/atguigu/java1/MethodAreaDemo</span><br><span class="line">   #5 = Class              #30            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               LocalVariableTable</span><br><span class="line">  #11 = Utf8               this</span><br><span class="line">  #12 = Utf8               Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line">  #13 = Utf8               main</span><br><span class="line">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #15 = Utf8               args</span><br><span class="line">  #16 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #17 = Utf8               x</span><br><span class="line">  #18 = Utf8               I</span><br><span class="line">  #19 = Utf8               y</span><br><span class="line">  #20 = Utf8               a</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               SourceFile</span><br><span class="line">  #23 = Utf8               MethodAreaDemo.java</span><br><span class="line">  #24 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #25 = Class              #31            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #28 = NameAndType        #35:#36        // println:(I)V</span><br><span class="line">  #29 = Utf8               com/atguigu/java1/MethodAreaDemo</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h4><p>1、初始状态</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0012.png"><p>2、首先将操作数500压入操作数栈中</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0013.png"><p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0014.png"><p>4、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0015.png"><p>5、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0016.png"><p>6、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0017.png"><p>7、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0018.png"><p>8、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0019.png"><p>9、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0020.png"><p>10、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0021.png"><p>11、图片写错了是#25和#26（获得System类）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0022.png"><p>12、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0023.png"><p>13、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0024.png"><p>15、执行加法运算后，将计算结果放在操作数栈顶</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0025.png"><p>16、就是真正的打印</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0026.png"><p>17、</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0027.png"><p><strong>符号引用 –&gt; 直接饮用</strong></p><ol><li> 上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li> 如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ol><h2 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h2><h3 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h3><ol><li><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p></li><li><p>Hotspot中方法区的变化：</p></li></ol><table><thead><tr><th>JDK1.6及以前</th><th>有永久代（permanent generation），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><strong>JDK6</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0028.png"><p><strong>JDK7</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0029.png"><p><strong>JDK8</strong></p><p>方法区由元空间实现，使用物理机本地内存</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0030.png"><h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ol><li> 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li><li> 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ol><li> 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ol><li> 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li> 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ol></li></ol></li></ol><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p></li><li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p></li></ul><h3 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h3><h4 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span></span><br><span class="line"><span class="comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK6环境下</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0031.png" alt="image-20201113224231761" /><p>JDK7环境下</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0032.png"><p>JDK8环境</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0033.png"><h4 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h4><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>JDK6环境下</strong></p><p>1、staticObj随着Test的类型信息存放在方法区</p><p>2、instanceObj随着Test的对象实例存放在Java堆</p><p>3、localObject则是存放在foo()方法栈帧的局部变量表中。</p><p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0034.png"><blockquote><p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p><p>2、可以发现三个变量都在这个范围内</p><p>3、所以可以得到上面结论</p></blockquote><p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0035.png"><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ol><li>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li><li>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</li></ol><ol><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>  类和接口的全限定名</li><li>  字段的名称和描述符</li><li>  方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ol><p>下面也称作<strong>类卸载</strong></p><p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h2 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0036.png"><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ol><li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li><li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于Java堆。即读写性能高。</li><li> 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer</span></span><br><span class="line"><span class="comment"> *  Stream              Channel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接占用了 1G 的本地内存</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0037.jpg"><h3 id="BIO-与-NIO"><a href="#BIO-与-NIO" class="headerlink" title="BIO 与 NIO"></a>BIO 与 NIO</h3><p><strong>非直接缓存区（BIO）</strong></p><p>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0038.png"><p><strong>直接缓冲区（NIO）</strong></p><p>NIO 直接操作物理磁盘，省去了中间过程</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0039.png"><h3 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h3><ol><li>直接内存也可能导致OutofMemoryError异常</li><li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li><li>直接内存的缺点为：<ul><li>  分配回收成本较高</li><li>  不受JVM内存回收管理</li></ul></li><li>直接内存大小可以通过MaxDirectMemorySize设置</li><li>如果不指定，默认与堆的最大值-Xmx参数值一致</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BufferTest2 &#123;</span><br><span class="line">    private static final int BUFFER &#x3D; 1024 * 1024 * 20;&#x2F;&#x2F;20MB</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;ByteBuffer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                count++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:<span class="number">694</span>)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.1.0/JVM/chapter_006/0040.jpg"><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li>百度<ul><li>  三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li></ul></li><li>蚂蚁金服：<ul><li>  Java8的内存分代改进</li><li>  JVM内存分哪几个区，每个区的作用是什么？</li><li>  一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li><li>  二面：Eden和survior的比例分配</li></ul></li><li>小米：<ul><li>  jvm内存分区，为什么要有新生代和老年代</li></ul></li><li>字节跳动：<ul><li>  二面：Java的内存分区</li><li>  二面：讲讲vm运行时数据库区</li><li>  什么时候对象会进入老年代？</li></ul></li><li>京东：<ul><li>  JVM的内存结构，Eden和Survivor比例。</li><li>  JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li></ul></li><li>天猫：<ul><li>  一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li><li>  一面：JVM的内存模型，Java8做了什么改</li></ul></li><li>拼多多：<ul><li>  JVM内存分哪几个区，每个区的作用是什么？</li></ul></li><li>美团：<ul><li>  java内存分配</li><li>  jvm的永久代中会发生垃圾回收吗？</li><li>  一面：jvm内存分区，为什么要有新生代和老年代？</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第5章-堆</title>
      <link href="post/50ac3a1c.html"/>
      <url>post/50ac3a1c.html</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><h3 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h3><ol><li> 堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li> 但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0001.png"><ol><li><p> 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p></li><li><p> Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</p></li><li><p> 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p> 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p></li><li><p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><ul><li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li></ul></li><li><p> 数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>  也就是触发了GC的时候，才会进行回收</li><li>  如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li><p> 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ol><blockquote><p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHeap sl = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0002.png"><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ol><li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul><li>Young Generation Space    新生区      Young/New<ul><li>  又被划分为Eden区和Survivor区</li></ul></li><li>  Old generation space    养老区           Old/Tenure</li><li>  Permanent Space   永久区                   Perm</li></ul></li><li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul><li>  Young Generation Space 新生区，又被划分为Eden区和Survivor区</li><li>  Old generation space 养老区</li><li>  Meta Space 元空间 Meta</li></ul></li></ol><p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0003.png"><ol start="2"><li> 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0004.png"><h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><p>运行下面代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、双击jdk目录下的这个文件</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0005.png"><p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0006.png"><p>3、运行上面的代码</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0007.png"><h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h3><ol><li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。<ul><li>  <strong>-Xms</strong>用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**</li><li>  <strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li></ul></li><li> 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</li><li> 通常会将-Xms和-Xmx两个参数配置相同的值</li></ol><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul><ol start="4"><li><p>默认情况下:</p><ul><li>  初始内存大小：物理电脑内存大小/64</li><li>  最大内存大小：物理电脑内存大小/4</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms : 123M</span><br><span class="line">-Xmx : 1794M</span><br><span class="line">系统内存大小为：<span class="number">7.</span>6875G</span><br><span class="line">系统内存大小为：<span class="number">7.</span>0078125G</span><br></pre></td></tr></table></figure><p>1、笔者电脑内存大小是8G，不足8G的原因是操作系统自身还占据了一些。</p><p>2、两个不一样的原因待会再说</p><p>设置下参数再看</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0008.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms : 575M</span><br><span class="line">-Xmx : 575M</span><br></pre></td></tr></table></figure><p>为什么会少25M</p><p><strong>方式一： jps   /  jstat -gc 进程id</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0009.png"><blockquote><p>jps：查看java进程</p><p>jstat：查看某进程内存使用情况</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure><p>1、</p><p>25600+25600+153600+409600 = 614400K</p><p>614400 /1024 = 600M</p><p>2、</p><p>25600+153600+409600 = 588800K</p><p>588800 /1024 = 575M</p><p>3、</p><p>并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）</p><p> <strong>方式二：-XX:+PrintGCDetails</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0010.png"><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、设置虚拟机参数</p><p><code>-Xms600m -Xmx600m</code></p><p>最终输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="number">29</span>)</span><br><span class="line">at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>2、堆内存变化图</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0011.png"><p>3、原因：大对象导致堆内存溢出</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0012.png"><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>1、存储在JVM中的Java对象可以被划分为两类：</p><pre><code>- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</code></pre><p>2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>3、其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0013.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0014.png"><ul><li><p>配置新生代与老年代在堆结构的占比</p><ul><li><p>默认**-XX:NewRatio**=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></li><li><p>可以修改**-XX:NewRatio**=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></li></ul></li></ul><ol><li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</p></li><li><p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio=8</p></li><li><p>几乎所有的Java对象都是在Eden区被new出来的。</p></li><li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p></li><li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0015.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenSurvivorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p><strong>具体过程</strong></p><ol><li> new的对象先放伊甸园区。此区有大小限制。</li><li> 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li><li> 然后将伊甸园中的剩余对象移动到幸存者0区。</li><li> 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li> 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li> 啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N 进行设置</li><li> 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li> 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ol><h3 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h3><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC / Minor GC操作</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0016.png"><p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p><p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p><blockquote><p>下一次再进行GC的时候，</p><p>1、这一次的s0区为空，所以成为下一次GC的S1区</p><p>2、这一次的s1区则成为下一次GC的S0区</p><p>3、也就是说s0区和s1区在互相转换。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0017.png"><p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0018.png"><p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p><h3 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h3><p><strong>对象分配的特殊情况</strong></p><ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>  如果 Eden 放得下，则直接放到 Eden 区</li><li>  如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>  如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>  那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM </li></ul></li><li> 如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0019.png"><h3 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h3><ol><li> JDK命令行</li><li> Eclipse：Memory Analyzer Tool</li><li> Jconsole</li><li> Visual VM（实时监控，推荐）</li><li> Jprofiler（IDEA插件）</li><li> Java Flight Recorder（实时监控）</li><li> GCViewer</li><li> GCEasy</li></ol><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ol><li>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></li><li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</li></ol><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC/Old GC）：只是老年代的圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><blockquote><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p></blockquote><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><strong>年轻代 GC（Minor GC）触发机制</strong></p><ol><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</li><li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li><li>Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0020.png"><h3 id="Major-Full-GC"><a href="#Major-Full-GC" class="headerlink" title="Major/Full GC"></a>Major/Full GC</h3><blockquote><p>Full GC有争议，后续详解两者区别，暂时先看着</p></blockquote><p><strong>老年代GC（MajorGC）触发机制</strong></p><ol><li><p> 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p></li><li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>  也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li></ul></li><li><p> Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p></li><li><p> 如果Major GC后，内存还不足，就报OOM了</p></li></ol><p><strong>Full GC 触发机制（后面细讲）</strong></p><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li> 调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li> 老年代空间不足</li><li> 方法区空间不足</li><li> 通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li> 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="number">0.0009094</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="number">0.0009568</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="number">0.0005594</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="number">0.0005890</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 5946K-&gt;4944<span class="title">K</span><span class="params">(7168K)</span>] 6418K-&gt;4944<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0045270 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="number">0.0004954</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="function">at java.util.Arrays.<span class="title">copyOf</span><span class="params">(Arrays.java:<span class="number">3332</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.AbstractStringBuilder.<span class="title">ensureCapacityInternal</span><span class="params">(AbstractStringBuilder.java:<span class="number">124</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.AbstractStringBuilder.<span class="title">append</span><span class="params">(AbstractStringBuilder.java:<span class="number">448</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.StringBuilder.<span class="title">append</span><span class="params">(StringBuilder.java:<span class="number">136</span>)</span></span></span><br><span class="line"><span class="function">at com.atguigu.java1.GCTest.<span class="title">main</span><span class="params">(GCTest.java:<span class="number">20</span>)</span></span></span><br><span class="line"><span class="function">[PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 4944K-&gt;4877<span class="title">K</span><span class="params">(7168K)</span>] 4944K-&gt;4877<span class="title">K</span><span class="params">(8704K)</span>, [Metaspace: 3492K-&gt;3492<span class="title">K</span><span class="params">(1056768K)</span>], 0.0076061 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">遍历次数为：<span class="number">16</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1536K, used 60K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 1024K, <span class="number">5</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f058</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 4877K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">68</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffac3408</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 391<span class="title">K</span>, <span class="title">capacity</span> 394<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p></li><li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p></li></ul><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>  新生代：有Eden、两块大小相同的survivor（又称为from/to或s0/s1）构成，to总为空。</li><li>  老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0021.png"><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p><ul><li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li></ul><ul><li>  而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0022.png"><h2 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h2><ol><li> 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li> 对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li> 对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li></ol><p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p><ol><li> <strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li> <strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li> <strong>长期存活的对象分配到老年代</strong></li><li> <strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li> <strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li></ol><blockquote><p>一些细节放在后面说</p></blockquote><h2 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h2><h3 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h3><ol start="2"><li> 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li> 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li> 为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li></ol><h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><p>TLAB（Thread Local Allocation Buffer）</p><ol><li> 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li><li> 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li> 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0023.png"><p>1、每个线程都有一个TLAB空间</p><p>2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</p><h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ol><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p></li><li><p>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p></li><li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p></li></ol><blockquote><p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   —-这是《深入理解JVM》–第三版里说的</p><p>2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</p></blockquote><p><strong>TLAB 分配过程</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_005/0024.png"><h2 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h2><h3 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h3><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>我们只说常用的</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试堆空间常用的jvm参数：</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line"><span class="comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span></span><br><span class="line"><span class="comment"> *                             jinfo -flag SurvivorRatio 进程id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span></span><br><span class="line"><span class="comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line"><span class="comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span></span><br><span class="line"><span class="comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span></span><br><span class="line"><span class="comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>1、在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>  如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul><li>  如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>  如果小于，则进行一次Full GC。</li></ul></li><li>如果HandlePromotionFailure=false，则进行一次Full GC。</li></ul></li></ul><p><strong>历史版本</strong></p><ol><li> 在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li><li> JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure=true</li></ol><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ol><li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ol><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ol><li> 如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li> 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li> 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>  当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>  当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol><p><strong>逃逸分析举例</strong></p><p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>逃逸分析参数设置</strong></p><ol><li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</li><li>如果使用的是较早的版本，开发人员则可以通过：<ul><li>  选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>  通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ol><p><strong>总结</strong></p><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li> <strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li> <strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li> <strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ol><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ol><li> JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li><li> 常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ol><p><strong>栈上分配举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0483350 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.06 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0008411 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;792K(38400K)] 34096K-&gt;800K(125952K), 0.0008427 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34072K-&gt;808K(38400K)] 34080K-&gt;816K(125952K), 0.0012223 secs] [Times: user&#x3D;0.08 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">花费的时间为： 114 ms</span><br></pre></td></tr></table></figure><p>1、JVM 参数设置</p><p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：发生了 GC ，耗时 114ms</p><p><strong>开启逃逸分析的情况</strong></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为： 5 ms</span><br></pre></td></tr></table></figure><p>1、参数设置</p><p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：并没有发生 GC ，耗时5ms 。</p><h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li><li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</li><li>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</li></ol><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节码分析</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public void f() &#123;</span><br><span class="line">        Object hollis &#x3D; new Object();</span><br><span class="line">        synchronized(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> aload_1</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line">12 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line">16 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> goto <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p><ol><li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</li></ol><p><strong>标量替换举例</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li> 可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li> 那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li> 标量替换为栈上分配提供了很好的基础。</li></ol><p><strong>标量替换参数设置</strong></p><p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>未开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p><p>2、日志</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="number">0.0012658</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="number">0.0012124</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="number">0.0009719</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="number">0.0009071</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="number">0.0010643</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="number">0.0012354</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="number">0.0011291</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="number">0.0006368</span> secs]</span><br><span class="line">花费的时间为： <span class="number">99</span> ms</span><br></pre></td></tr></table></figure><p><strong>开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p><p>2、日志：时间减少很多，且无GC</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">花费的时间为： 6 ms</span><br></pre></td></tr></table></figure><p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p><p>这里设置参数如下：</p><ol><li> 参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li> 参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li><li> 参数 -Xmx10m：指定了堆空间最大为10MB</li><li> 参数 -XX:+PrintGC：将打印GC日志。</li><li> 参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ol><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol><li> 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li> 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li> 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li> 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li> 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li> 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol><blockquote><p><strong>堆是分配对象的唯一选择么？</strong></p></blockquote><p>综上：<strong>对象实例都是分配在堆上</strong>。What the fuck？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li><li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</li><li>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</li><li>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</li><li>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li><li>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</li><li>当GC发生在老年代时则被称为Major GC或者Full GC。</li><li> 一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第4章-虚拟机栈</title>
      <link href="post/5b1b6560.html"/>
      <url>post/5b1b6560.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h3><ol><li> 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li> 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0001.png"><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul><li><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackTest test = <span class="keyword">new</span> StackTest();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0002.png"><ul><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0003.png"><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>多去官方文档看看：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p><p>地址经常变</p></blockquote><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux/x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris/x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11404</span></span><br><span class="line"><span class="number">11405</span></span><br><span class="line"><span class="number">11406</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0004.png"><p>部分输出结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure><p>说明参数起作用了</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol><li> 每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li> 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p> 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0005.png"><ol><li> <strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li> 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）（或表达式栈）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0006.png"><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0007.png"><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><h3 id="认识局部变量表"><a href="#认识局部变量表" class="headerlink" title="认识局部变量表"></a>认识局部变量表</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol><li> 局部变量表也被称之为局部变量数组或本地变量表</li><li> <strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li> 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li> <strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>  对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>  进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>  在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>  当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVariablesTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String name1 = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">        dateP = <span class="keyword">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0008.png"><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p><p>1、0-15  也就是有16行字节码</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0009.png"><p>2、方法异常信息表</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0010.png"><p>3、Misc</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0011.png"><p>4、行号表</p><p>Java代码的行号和字节码指令行号的对应关系</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0012.png"><p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0013.png"><p>1、图中圈的东西表示该局部变量的作用域</p><p>2、Start PC==11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length== 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 ==5。</p><p>4、<code>Ljava/lang/String</code>   前面的L表示引用类型</p><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ol><li> 参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li> 局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul><li>byte、short、char在储存前辈转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li> JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li> 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li> 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li> 如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0014.png"><h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h3><p><strong>this 存放在 index = 0 的位置：</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>局部变量表：this 存放在 index = 0 的位置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0015.png"><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Date dateP, String name2)</span> </span>&#123;</span><br><span class="line">      dateP = <span class="keyword">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="keyword">double</span> weight = <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0016.png"><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="keyword">int</span> c = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0017.png"><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li> 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li> 我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li> 和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ol><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li><li> 操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0018.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0019.png"><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ol><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>  32bit的类型占用一个栈单位深度</li><li>  64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0020.jpg"><p>局部变量表就相当于食材</p><p>操作数栈就相当于做法步骤</p><h2 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">       <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0021.png"><h3 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0022.png"><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><ul><li>  解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0023.png"><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0024.png"><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0025.png"><p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0026.png"><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p><strong>关于类型转换的说明</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0027.png"><ul><li>  因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>  但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0028.png"><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">int</span> k = m + n;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">      <span class="keyword">int</span> i = getSum();</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0029.png"><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0030.png"><h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li></ol><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">10</span>; size <span class="number">712</span> bytes</span><br><span class="line">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java1</span>.<span class="title">DynamicLinkingTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I</span><br><span class="line">   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = String             #27            // methodA()....</span><br><span class="line">   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #6 = String             #30            // methodB()....</span><br><span class="line">   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br><span class="line">   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">   #9 = Class              #33            // java/lang/Object</span><br><span class="line">  #10 = Utf8               num</span><br><span class="line">  #11 = Utf8               I</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               ()V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               LocalVariableTable</span><br><span class="line">  #17 = Utf8               this</span><br><span class="line">  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">  #19 = Utf8               methodA</span><br><span class="line">  #20 = Utf8               methodB</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = NameAndType        #10:#11        // num:I</span><br><span class="line">  #25 = Class              #34            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Utf8               methodA()....</span><br><span class="line">  #28 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V</span><br><span class="line">  #30 = Utf8               methodB()....</span><br><span class="line">  #31 = NameAndType        #19:#13        // methodA:()V</span><br><span class="line">  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #4                  // String methodA()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String methodB()....</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         9: invokevirtual #7                  // Method methodA:()V</span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: getfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        19: putfield      #2                  // Field num:I</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li>  <code>#8 = Class #32</code> ：去找 #32</li><li>  <code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>  结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li>  <code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li>  <code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li>  <code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0031.png"><p><strong>为什么要用常量池呢？</strong></p><ol><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li></ol><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(Huntable h)</span> </span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部分字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokevirtual #2                  // Method com/atguigu/java2/Animal.eat:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span></span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure><p>invokevirtual 体现为晚期绑定</p><p>invokeinterface 也体现为晚期绑定</p><p>invokespecial 体现为早期绑定</p><h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ol><li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li><li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li></ol><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p><strong>虚方法与非虚方法的区别</strong></p><ol><li> 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li> 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li> 其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li> 类的继承关系</li><li> 方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li> invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li> invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li> invokevirtual：调用所有虚方法</li><li> invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也  会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Father f)</span> </span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son so = <span class="keyword">new</span> Son();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MethodInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son 类中 show() 方法的字节码指令如下</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0032.png"><h4 id="关于-invokedynamic-指令"><a href="#关于-invokedynamic-指令" class="headerlink" title="关于 invokedynamic 指令"></a>关于 invokedynamic 指令</h4><ol><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Func</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">func</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">(Func func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lambda lambda = <span class="keyword">new</span> Lambda();</span><br><span class="line"></span><br><span class="line">        Func func = s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0033.png"><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ol><li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ol><p>Java：String info = “mogu blog”;             (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p><pre><code>Python: info = 130.5 (运行时才检查)</code></pre><h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol><li> 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>  如果通过则返回这个方法的直接引用，查找过程结束</li><li>  如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li> 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li> 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li> 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li><li> 比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li></ol><p><strong>例子1</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0034.png"><p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p><p><strong>例子2</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0035.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0036.jpg"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0037.jpg"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0038.jpg"><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0039.png"><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p></blockquote><ol><li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：<ul><li>  正常执行完成</li><li>  出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li><li>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ol><p><strong>方法退出的两种方式</strong></p><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><p><strong>正常退出：</strong></p><ol><li><p> 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</p></li><li><p> 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p></li><li><p>在字节码指令中，返回指令包含：</p><ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ol><p><strong>异常退出：</strong></p><ol><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</li><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0040.png"><p>异常处理表：</p><ul><li>  反编译字节码文件，可得到 Exception table</li><li>  from ：字节码指令起始地址</li><li>  to ：字节码指令结束地址</li><li>  target ：出现异常跳转至地址为 11 的指令执行</li><li>  type ：捕获异常的类型</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_004/0041.png"><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h2><h3 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a>举例栈溢出的情况？</h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h3 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a>调整栈大小，就能保证不出现溢出么？</h3><p>不能保证不溢出，只能保证SOF出现的几率小</p><h3 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a>分配的栈内存越大越好么？</h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h3 id="垃圾回收是否涉及到虚拟机栈？"><a href="#垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="垃圾回收是否涉及到虚拟机栈？"></a>垃圾回收是否涉及到虚拟机栈？</h3><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h3 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h3><p>具体问题具体分析</p><ol><li> 如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li> 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的智商s1.toString的一个新对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第3章-运行时数据区</title>
      <link href="post/a7ad3cab.html"/>
      <url>post/a7ad3cab.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>此章把运行时数据区里比较少的地方讲一下。虚拟机栈，堆，方法区这些地方后续再讲。</p></blockquote><h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0001.png"><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0002.png"><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0003.png"><h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a>运行时数据区结构</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><blockquote><p>下图来自阿里巴巴手册JDK8</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0004.jpg"><h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h3><ol><li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p></li><li><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0005.png"><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0006.png"><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol><li> 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li> 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><blockquote><p>关于线程，并发可以看笔者的Java并发系列</p></blockquote><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li> <strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li> <strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li> <strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li> <strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li> <strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h1 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0007.png"><ol><li> JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li> 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li> 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li> 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li> 任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li> 它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li> 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li> 它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0008.png"><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line"></span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class</span><br><span class="line">  Last modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">atguigu</span>.<span class="title">java</span>.<span class="title">PCRegisterTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #27            // abc</span><br><span class="line">   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #32            // com/atguigu/java/PCRegisterTest</span><br><span class="line">   #6 = Class              #33            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               i</span><br><span class="line">  #19 = Utf8               I</span><br><span class="line">  #20 = Utf8               j</span><br><span class="line">  #21 = Utf8               k</span><br><span class="line">  #22 = Utf8               s</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               PCRegisterTest.java</span><br><span class="line">  #26 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #27 = Utf8               abc</span><br><span class="line">  #28 = Class              #34            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #31 = NameAndType        #38:#39        // println:(I)V</span><br><span class="line">  #32 = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        10: ldc           #2                  // String abc</span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>  左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0009.png"><h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0010.png"><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li> 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li> 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li> 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><blockquote><p>注意并行和并发的区别，笔者的并发系列有讲</p></blockquote><h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><ol><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0011.png"><h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0012.png"><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</li></ol><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="为什么要使用-Native-Method？"><a href="#为什么要使用-Native-Method？" class="headerlink" title="为什么要使用 Native Method？"></a>为什么要使用 Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="与Java环境外交互"><a href="#与Java环境外交互" class="headerlink" title="与Java环境外交互"></a>与Java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><h3 id="本地方法的现状"><a href="#本地方法的现状" class="headerlink" title="本地方法的现状"></a>本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_003/0013.png"><p><strong>注意事项</strong></p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第2章-类加载子系统</title>
      <link href="post/2e0079af.html"/>
      <url>post/2e0079af.html</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章-类加载子系统"></a>第2章-类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><h3 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h3><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0001.png"><h3 id="详细图"><a href="#详细图" class="headerlink" title="详细图"></a>详细图</h3><p>英文版</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0002.jpg"><p>中文版</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0003.jpg"><p>注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ol><li> 类加载器</li><li> 执行引擎</li></ol><h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p><ol><li><p> 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p> ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p> <strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0004.png"><h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><ol><li> class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li> class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li> 在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0005.png"><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><ul><li>  执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>  加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>  加载失败则抛出异常</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0006.png"><p>完整的流程图如下所示：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0007.png"><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><strong>加载：</strong></p><ol><li><p> 通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p> 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p> <strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li> 从本地系统中直接加载</li><li> 通过网络获取，典型场景：Web Applet</li><li> 从zip压缩包中读取，成为日后jar、war格式的基础</li><li> 运行时计算生成，使用最多的是：动态代理技术</li><li> 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li> 从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ol><li> 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li> 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><p><strong>举例</strong></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0008.png"><h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><ol><li> 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li><li> 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li> 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ol><li><p> <strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p> 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p></li><li><p> 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><p><strong>符号引用</strong></p><ul><li>  反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0023.png"/><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit()"></a>clinit()</h3><ol><li><p> 初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</p></li><li><p> 此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</p></li><li><p> <code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p></li><li><p> <code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</p></li><li><p> 若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p></li><li><p> 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p></li></ol><blockquote><p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度</p></blockquote><h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0009.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 putstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> 5 putstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span> <span class="comment">//先赋20</span></span><br><span class="line">10 putstatic #5 &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line">13 getstatic #2 &lt;java/lang/System.out&gt;</span><br><span class="line">16 getstatic #3 &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span><span class="comment">//再赋10</span></span><br><span class="line">24 putstatic #5 &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p><strong>举例2：无 static 变量</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0010.png"><p>加上之后就有了</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0011.png"><h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0012.png"><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0013.png"><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">&#x2F;然后程序卡死了</span><br></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>  两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>  先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>  所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li><p>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></p></li><li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</p></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0014.png"><p><strong>ExtClassLoader</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0015.png"><p><strong>AppClassLoader</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0016.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C/C++ 语言，我们获取不到</strong></li><li>  两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li> 这个类加载使用C/C++语言实现的，嵌套在JVM内部</li><li> 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li> 并不继承自java.lang.ClassLoader，没有父加载器</li><li> 加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li> 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote><p><strong>扩展类加载器（Extension ClassLoader）</strong></p></blockquote><ol><li> Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li> 派生于ClassLoader类</li><li> 父类加载器为启动类加载器</li><li> 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li> Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li> 派生于ClassLoader类</li><li> 父类加载器为扩展类加载器</li><li> 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li> 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li> 通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        ClassLoader classLoader = Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/classes</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_131</span>\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br></pre></td></tr></table></figure><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li> 隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li> 修改类加载的方式</li><li> 扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li> 防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="如何自定义类加载器？"><a href="#如何自定义类加载器？" class="headerlink" title="如何自定义类加载器？"></a>如何自定义类加载器？</h4><ol><li> 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li> 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li> 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><blockquote><p><strong>ClassLoader 类介绍</strong></p></blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0017.png"><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0018.png"><h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0019.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li> 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li> 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li> 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li> 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0020.png"><h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a>双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.lang.String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        StringTest test = <span class="keyword">new</span> StringTest();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello,atguigu.com</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0021.png"><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_002/0022.png"><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol><li> 自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li> 这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li> 类的完整类名必须一致，包括包名</li><li> <strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li> 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ol><li> JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li> <strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li> 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列-第1章-JVM与Java体系结构</title>
      <link href="post/8c954c6.html"/>
      <url>post/8c954c6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>1、本系列博客，主要是面向Java8的虚拟机。如有特殊说明，会进行标注。</p><p>2、本系列博客主要参考<strong>尚硅谷的JVM视频教程</strong>，整理不易，所以图片打上了一些水印，还请读者见谅。后续可能会加上一些补充的东西。</p><p>3、尚硅谷的有些视频还不错（PS：不是广告，毕竟看了人家比较好的教程，得给人家打个call）</p><p>4、转载请注明出处，多谢~，希望大家一起能维护一个良好的开源环境。</p></blockquote><h1 id="第1章-JVM和Java体系架构"><a href="#第1章-JVM和Java体系架构" class="headerlink" title="第1章-JVM和Java体系架构"></a>第1章-JVM和Java体系架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否也遇到过这些问题？</p><ol><li> 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li><li> 想解决线上JVM GC问题，但却无从下手。</li><li> 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li><li> 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0001.png"><p>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p><h2 id="开发人员如何看待上层框架"><a href="#开发人员如何看待上层框架" class="headerlink" title="开发人员如何看待上层框架"></a>开发人员如何看待上层框架</h2><ol><li> 一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。</li><li> 如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0002.png"><ul><li>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。</li></ul><h2 id="架构师每天都在思考什么？"><a href="#架构师每天都在思考什么？" class="headerlink" title="架构师每天都在思考什么？"></a>架构师每天都在思考什么？</h2><ol><li> 应该如何让我的系统更快？</li><li> 如何避免系统出现瓶颈？</li></ol><p><strong>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</strong></p><ol><li> 参与现有系统的性能优化，重构，保证平台性能和稳定性</li><li> 根据业务场景和需求，决定技术方向，做技术选型</li><li> 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li><li> 解决各类潜在系统风险，核心功能的架构与代码编写</li><li> 分析系统瓶颈，解决各种疑难杂症，性能调优等</li></ol><h2 id="我们为什么要学习JVM"><a href="#我们为什么要学习JVM" class="headerlink" title="我们为什么要学习JVM"></a>我们为什么要学习JVM</h2><ol><li> 面试的需要（BATJ、TMD，PKQ等面试都爱问）</li><li> 中高级程序员必备技能</li></ol><ul><li>项目管理、调优的需要</li></ul><ol start="3"><li>追求极客的精神，<ul><li>比如：垃圾回收算法、JIT、底层原理</li></ul></li></ol><h2 id="Java-VS-C"><a href="#Java-VS-C" class="headerlink" title="Java VS C++"></a>Java VS C++</h2><ol><li> 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li><li> C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收，这也是一种趋势，减少程序员的工作量。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0003.png"><h2 id="什么人需要学JVM？"><a href="#什么人需要学JVM？" class="headerlink" title="什么人需要学JVM？"></a>什么人需要学JVM？</h2><ol><li>拥有一定开发经验的Java开发人员，希望升职加薪</li><li>软件设计师，架构师</li><li>系统调优人员</li><li>虚拟机爱好者，JVM实践者</li></ol><h2 id="推荐及参考书籍"><a href="#推荐及参考书籍" class="headerlink" title="推荐及参考书籍"></a>推荐及参考书籍</h2><p><strong>官方文档</strong></p><p><strong>英文文档规范</strong>：<a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0004.png"><p><strong>中文书籍：</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0005.png"><blockquote><p>周志明老师的这本书<strong>非常推荐看</strong>，不过只推荐看第三版，第三版较第二版更新了很多，个人觉得没必要再看第二版。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0006.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0007.png"><h2 id="TIOBE排行榜"><a href="#TIOBE排行榜" class="headerlink" title="TIOBE排行榜"></a>TIOBE排行榜</h2><p><strong>TIOBE 排行榜</strong>：<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0008.png"><ul><li>世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言。</li><li>目前网上一直流传Java被python，go撼动Java第一的地位。学习者不需要太担心，Java强大的生态圈，也不是说是朝夕之间可以被撼动的。</li></ul><h2 id="Java生态圈"><a href="#Java生态圈" class="headerlink" title="Java生态圈"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ol><li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul><li>  Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul></li><li>作为一种文化，Java几乎成为了“开源”的代名词。<ul><li>  第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>  就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul></li><li> 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ol><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java-跨平台的语言"></a>Java-跨平台的语言</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0009.png"><h2 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM-跨语言的平台"></a>JVM-跨语言的平台</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0010.png"><ol><li> 随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li><li> Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li></ol><ul><li>Java不是最强大的语言，但是JVM是最强大的虚拟机</li></ul><ol><li><p> 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p></li><li><p> 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p></li><li><p> Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p></li></ol><h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><ol><li>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</li><li>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</li><li>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</li></ol><h2 id="如何真正搞懂JVM？"><a href="#如何真正搞懂JVM？" class="headerlink" title="如何真正搞懂JVM？"></a>如何真正搞懂JVM？</h2><ol><li> Java虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！</li><li> 自己动手写一个Java虚拟机，难吗？</li><li> 天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0011.png"><h2 id="Java发展重大事件"><a href="#Java发展重大事件" class="headerlink" title="Java发展重大事件"></a>Java发展重大事件</h2><ul><li>  1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为Oak，后期命名为Java</li><li>  1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li><li>  1996年1月23日Sun Microsystems发布了JDK 1.0。</li><li>  1998年，JDK1.2版本发布。同时，Sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li><li>  2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li><li>  2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li><li>  2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li><li>  2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li><li>  2006年，JDK6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li><li>  2007年，Java平台迎来了新伙伴Clojure。</li><li>  2008年，oracle收购了BEA，得到了JRockit虚拟机。</li><li>  2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。</li><li>  2010年，Oracle收购了Sun，获得Java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit。JCP组织管理Java语言</li><li>  2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li><li>  <strong>2017年，JDK9发布。将G1设置为默认GC，替代CMS</strong></li><li>  同年，IBM的J9开源，形成了现在的Open J9社区</li><li>  2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li><li>  同年，Oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li><li>  <strong>同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可</strong></li><li>  2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC</li></ul><h2 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0012.png"><ul><li>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。</li><li>主要的区别就是两者更新周期不一样</li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h3><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</li></ul><ul><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ol><li> Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li> JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li> <strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li> 一次编译，到处运行</li><li> 自动内存管理</li><li> 自动垃圾回收功能</li></ol><h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0013.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0014.png"><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ol><li> HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li> 它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0015.png"><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p>凡是能生成被Java虚拟机所能解释、运行的字节码文件，那么理论上我们就可以自己设计一套语言了</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/JVM/chapter_001/0016.png"><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。具体来说：这两种架构之间的区别：</p><h3 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h3><p>基于栈式架构的特点：</p><ol><li> 设计和实现更简单，适用于资源受限的系统；</li><li> 避开了寄存器的分配难题：使用零地址指令方式分配</li><li> 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li> 不需要硬件支持，可移植性更好，更好实现跨平台</li></ol><h3 id="基于寄存器的指令级架构"><a href="#基于寄存器的指令级架构" class="headerlink" title="基于寄存器的指令级架构"></a>基于寄存器的指令级架构</h3><p>基于寄存器架构的特点：</p><ol><li> 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li> 指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</li><li> 性能优秀和执行更高效</li><li> 花费更少的指令去完成一项操作</li><li> 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ol><h3 id="两种架构的举例"><a href="#两种架构的举例" class="headerlink" title="两种架构的举例"></a>两种架构的举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure><p>  8个指令</p></li><li><p><strong>而基于寄存器的计算流程</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为1</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值加3</span></span><br></pre></td></tr></table></figure><p>  2个指令</p></li></ul><blockquote><p>具体后面会讲</p></blockquote><h3 id="JVM架构总结"><a href="#JVM架构总结" class="headerlink" title="JVM架构总结"></a>JVM架构总结</h3><ol><li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。</li><li> 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</li></ol><ul><li>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li></ul><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ol><li> 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li> 程序开始执行时他才运行，程序结束时他就停止</li><li> <strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li></ol><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p><strong>有如下的几种情况：</strong></p><ol><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ol><h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ol><li> 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。</li><li> 这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。<ul><li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li><li>而解释器就是走到哪，解释到哪。</li></ul></li><li> 现在Hotspot内置了此虚拟机。</li></ol><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ol><li>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</li><li>Exact Memory Management：准确式内存管理<ul><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li></ul></li><li>具备现代高性能虚拟机的维形<ul><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</li></ol><h3 id="HotSpot-VM（重点）"><a href="#HotSpot-VM（重点）" class="headerlink" title="HotSpot VM（重点）"></a>HotSpot VM（重点）</h3><ol><li>HotSpot历史<ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul></li><li>目前<strong>Hotspot占有绝对的市场地位，称霸武林</strong>。<ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的HotSpot指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>  通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ol><h3 id="JRockit（商用三大虚拟机之一）"><a href="#JRockit（商用三大虚拟机之一）" class="headerlink" title="JRockit（商用三大虚拟机之一）"></a>JRockit（商用三大虚拟机之一）</h3><ol><li>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li><li>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li><li>优势：全面的Java运行时解决方案组合<ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li><li>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，JRockit被Oracle收购。</li><li>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</li><li>高斯林：目前就职于谷歌，研究人工智能和水下机器人</li></ol><h3 id="IBM的J9（商用三大虚拟机之一）"><a href="#IBM的J9（商用三大虚拟机之一）" class="headerlink" title="IBM的J9（商用三大虚拟机之一）"></a>IBM的J9（商用三大虚拟机之一）</h3><ol><li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li><li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</li><li>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</li><li>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</li></ol><h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC/CLDC Hotspot"></a>KVM和CDC/CLDC Hotspot</h3><ol><li><p> Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM </p></li><li><p> KVM（Kilobyte）是CLDC-HI早期产品</p></li><li><p> 目前移动领域地位尴尬，智能机被Android和iOS二分天下。</p></li><li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>  老人手机、经济欠发达地区的功能手机</li></ul></li><li><p> 所有的虚拟机的原则：一次编译，到处运行。</p></li></ol><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ol><li> 前面三大“高性能Java虚拟机”使用在<strong>通用硬件平台上</strong></li><li> 这里Azul VW和BEA Liquid VM是与<strong>特定硬件平台绑定</strong>、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。</li><li> Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li><li> 每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li><li> 2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li></ol><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ol><li> 高性能Java虚拟机中的战斗机。</li><li> BEA公司开发的，直接运行在自家Hypervisor系统上</li><li> Liquid VM即是现在的JRockit VE（Virtual Edition）。<strong>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</li><li> 随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li></ol><h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><ol><li>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</li><li>它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</li><li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</li></ol><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ol><li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</li><li>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</li><li>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</li></ol><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ol><li>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</li><li><strong>基于OpenJDK开发了自己的定制版本AlibabaJDK</strong>，简称AJDK。是整个阿里Java体系的基石。</li><li>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。<ul><li>  创新的GCIH（GCinvisible heap）技术实现了off-heap，<strong>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li><li>  GCIH中的<strong>对象还能够在多个Java虚拟机进程中实现共享</strong></li><li>  使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>  PMU hardware的Java profiling tool和诊断协助功能</li><li>  针对大数据场景的ZenGC</li></ul></li><li> taobao vm应用在阿里产品上性能高，<strong>硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</strong></li></ol><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ol><li>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</li><li><strong>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循 Java虚拟机规范</li><li>不能直接执行Java的Class文件</li><li>基于寄存器架构，不是jvm的栈架构。</li><li> 执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</li></ol><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><ol start="7"><li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li></ol><h3 id="Graal-VM（未来虚拟机）"><a href="#Graal-VM（未来虚拟机）" class="headerlink" title="Graal VM（未来虚拟机）"></a>Graal VM（未来虚拟机）</h3><ol><li>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</li><li>GraalVM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机，可以作为“任何语言”</strong>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li> <strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong>。但是Java的软件生态没有丝毫变化。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 1.内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-JDK8源码讲解及常见面试题</title>
      <link href="post/cbc5672a.html"/>
      <url>post/cbc5672a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>JDK7说过的东西，本篇文章不再讲解</p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>在JDK8中，优化了HashMap的数据结构，引入了红黑树。即HashMap的数据结构：数组+链表+红黑树。HashMap变成了这样。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK8/0001.png"><h3 id="为什么要引入红黑树"><a href="#为什么要引入红黑树" class="headerlink" title="为什么要引入红黑树"></a>为什么要引入红黑树</h3><p>1、主要是为了提高HashMap的性能，即解决发生hash冲突后，因为链表过长而导致索引效率慢的问题</p><p>2、链表的索引速度是O(n)，而利用了红黑树快速增删改查的特点，时间复杂度就是O(logn)。</p><h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p><code>HashMap</code>中的数组元素，链表节点均采用<code>Node</code>类 实现，与 <code>JDK 1.7</code> 的对比（<code>Entry</code>类），仅仅只是换了名字。</p><p>就是一些常规的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * Node  = HashMap的内部类，实现了Map.Entry接口，本质是 = 一个映射(键值对)</span></span><br><span class="line"><span class="comment">  * 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法</span></span><br><span class="line"><span class="comment">  **/</span>  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; </span><br><span class="line">        <span class="keyword">final</span> K key; </span><br><span class="line">        V value; </span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TreeNode类"><a href="#TreeNode类" class="headerlink" title="TreeNode类"></a>TreeNode类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性 = 父节点、左子树、右子树、删除辅助节点 + 颜色</span></span><br><span class="line">  TreeNode&lt;K,V&gt; parent;  </span><br><span class="line">  TreeNode&lt;K,V&gt; left;   </span><br><span class="line">  TreeNode&lt;K,V&gt; right;</span><br><span class="line">  TreeNode&lt;K,V&gt; prev;   </span><br><span class="line">  <span class="keyword">boolean</span> red;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">      <span class="keyword">super</span>(hash, key, val, next);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回当前节点的根节点  </span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">          <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">              <span class="keyword">return</span> r;  </span><br><span class="line">          r = p;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><blockquote><p>JDK7里讲过的就不再讲了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 存储数据的Node类型 数组，长度 = 2的幂；</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  </span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//与红黑树相关的参数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1、单链表(桶)的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，</span></span><br><span class="line"><span class="comment">  则将链表转换成红黑树</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1、桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据</span></span><br><span class="line"><span class="comment">  存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内节点数量 &lt; 6时，则将 红黑树转换</span></span><br><span class="line"><span class="comment">  成链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1、最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）。</span></span><br><span class="line"><span class="comment">  否则，若 （单链表）桶内元素太多时，则直接扩容，而不是树形化。</span></span><br><span class="line"><span class="comment">  2、为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构造函数源码"><a href="#构造函数源码" class="headerlink" title="构造函数源码"></a>构造函数源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数3：指定&quot;容量大小&quot;和&quot;加载因子&quot;的构造函数</span></span><br><span class="line"><span class="comment">     * 加载因子和容量由自己指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定初始容量必须非负，否则报错  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +  </span><br><span class="line">                                           initialCapacity); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 &gt; 最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充比必须为正  </span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">        <span class="comment">// 设置加载因子</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、设置扩容阈值</span></span><br><span class="line"><span class="comment">        2、此处不是真正的阈值，仅仅只是将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂，</span></span><br><span class="line"><span class="comment">        该阈值后面会重新计算</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor()"></a>tableSizeFor()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂</span></span><br><span class="line"><span class="comment">     * 与JDK 1.7对比：类似于JDK 1.7 中 inflateTable()里的 roundUpToPowerOf2(toSize)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">     <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">65538</span>;  <span class="comment">//这个数字是2^16 + 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始:&quot;</span> + Integer.toBinaryString(n));</span><br><span class="line">        <span class="keyword">int</span> res = tableSizeFor(n);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果:&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(n));</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(n));</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(n));</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(n));</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(n));</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始:10000000000000010</span><br><span class="line">11000000000000001</span><br><span class="line">11110000000000001</span><br><span class="line">11111111000000001</span><br><span class="line">11111111111111111</span><br><span class="line">11111111111111111</span><br><span class="line">最终结果:131072</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>第一次运行：</strong><br>    10000000000000010        n &gt;&gt;&gt; 1;<br>    01000000000000000        进行|运算<br>    11000000000000001<br>分析：<br>    把最大位的1，通过位移后移一位，并且通过|运算，组合起来</p><p><strong>第二次运行：</strong><br>    11000000000000001        n &gt;&gt;&gt; 2;<br>    00110000000000000        进行|运算<br>    11110000000000001<br>分析：<br>    把最大的两位，已经变成1的，往后移动两位，并且通过|运算，组合起来</p><p><strong>第三次运行：</strong><br>    11110000000000001        n &gt;&gt;&gt; 4;<br>    00001111000000000        进行|运算<br>    11111111000000001<br>分析：<br>    把最大4位，已经变成1的，往后移动4位，并且通过|运算，组合起来</p><p><strong>第四次运行：</strong><br>    11111111000000001        n &gt;&gt;&gt; 8;<br>    00000000111111110        进行|运算<br>    11111111111111111<br>分析：<br>    把最大的8位，已经变成1的，往后移动8位，并且通过|运算，组合起来</p><p><strong>第五次运算：</strong><br>    同上。因为我的数据，最大只到17位，所有第五次没有效果。可以用32位来进行运算，第五次是通过前16位已经变成1的数据，往后移动16位，然后通过或运算，最后的结果是32位都变成1。</p><blockquote><p>原理就是，保证造成一个所有位都为1的数据。并且通过最后的+1。变成2^N次方的数据。</p></blockquote><h1 id="put源码"><a href="#put源码" class="headerlink" title="put源码"></a>put源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//在第一个参数里就直接计算出了hash值</span></span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1、若哈希表的数组tab为空，则通过resize()进行初始化，所以，初始化哈希表的时机就是第1次</span></span><br><span class="line"><span class="comment">       调用put函数时，即调用resize() 初始化创建。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* if分支</span></span><br><span class="line"><span class="comment">       1、根据键值key计算的hash值，计算插入存储的数组索引i</span></span><br><span class="line"><span class="comment">   2、插入时，需判断是否存在Hash冲突：</span></span><br><span class="line"><span class="comment">     2-1、若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕。</span></span><br><span class="line"><span class="comment">     2-2、否则代表发生hash冲突，进入else分支</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">//判断 table[i]的元素的key是否与需插入的key一样，若相同则直接用新value覆盖旧value</span></span><br><span class="line">           <span class="comment">//【即更新操作】</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//继续判断：需插入的数据结构是否为红黑树or链表。若是红黑树，则直接在树中插入or更新键值对     </span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、putTreeVal作用：向红黑树插入 or 更新数据（键值对）</span></span><br><span class="line"><span class="comment">     2、过程：遍历红黑树判断该节点的key是否与需插入的key是否相同：</span></span><br><span class="line"><span class="comment">             2-1、若相同，则新value覆盖旧value</span></span><br><span class="line"><span class="comment">             2-2、若不相同，则插入</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//进入到这个分支说明是链表节点</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               过程：</span></span><br><span class="line"><span class="comment">               1、遍历table[i]，判断Key是否已存在：采用equals()对比当前遍历节点的key 与</span></span><br><span class="line"><span class="comment">               需插入数据的key：若已存在，则直接用新value覆盖旧value</span></span><br><span class="line"><span class="comment">         2、遍历完毕后仍无发现上述情况，则直接在链表尾部插入数据(尾插法)</span></span><br><span class="line"><span class="comment">         3、新增节点后，需判断链表长度是否&gt;8（8 = 桶的树化阈值）：若是，则把链表转换为红黑树</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//对于2情况的操作  尾插法插入尾部</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//对于3情况的操作</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 对1情况的后续操作：发现key已存在，直接用新value 覆盖 旧value，返回旧value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">// 插入成功后，判断实际存在的键值对数量size &gt; threshold</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//JDK7实现:使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">   h ^= k.hashCode(); </span><br><span class="line">   h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">   <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//JDK8实现: 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动） </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1、当key = null时，hash值 = 0，所以HashMap的key可为null      </span></span><br><span class="line"><span class="comment">  2、当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后对哈希码进行扰动处理。</span></span><br><span class="line"><span class="comment">  高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16) </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK8 hash的运算原理：高位参与低位运算，使得hash更加均匀。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK8/0002.png"><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>这个方法改动比较大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   <span class="comment">//该函数有2种使用情况：1、初始化哈希表 2、当前数组容量过小，需扩容   </span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 扩容前的数组（当前数组）</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 扩容前的数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">// 扩容前的数组的阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩充</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对情况2：若无超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 通过右移扩充2倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况1：初始化哈希表（采用指定值或者默认值）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旧数组数据移动到新数组里，整体过程也是遍历旧数组每个数据</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//这个待会细讲</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK8扩容时，数据在数组下标的计算方式</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK8/0003.png"><ul><li><code>JDK8</code>根据此结论作出的新元素存储位置计算规则非常简单，提高了扩容效率。</li></ul><ul><li>这与 <code>JDK7</code>在计算新元素的存储位置有很大区别：<code>JDK7</code>在扩容后，都需按照原来方法进行rehash，效率不高。</li></ul><h1 id="get源码"><a href="#get源码" class="headerlink" title="get源码"></a>get源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 计算需获取数据的hash值,通过getNode（）获取所查询的数据,获取后，判断数据是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算存放在数组table中的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先在数组中找，若存在，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若数组中没有，则到红黑树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若红黑树中也没有，则通过遍历，到链表中寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—下面是常见面试题—"><a href="#—下面是常见面试题—" class="headerlink" title="—下面是常见面试题—"></a>—下面是常见面试题—</h1><h1 id="HashMap在JDK7和8中区别？"><a href="#HashMap在JDK7和8中区别？" class="headerlink" title="HashMap在JDK7和8中区别？"></a>HashMap在JDK7和8中区别？</h1><p>1、hash冲突时：JDK7用的是头插法，而JDK1.8及之后使用的都是尾插法。JDK7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK8之后是使用尾插法，能够避免出现逆序且链表死循环的问题。</p><p>2、扩容时：JDK7需要重新进行rehash。JDK8则直接时判断hash值新参与的位是0还是1，0就是原位置，1就是原位置+就容量</p><p>3、引入了红黑树（原因前面说过）</p><p>4、hash的计算：JDK7是9次扰动（4次位运算 + 5次异或运算），JDK8时是2次扰动（1次位运算 + 1次异或运算）。</p><p>5、JDK7是先扩容再插入k-v，JDK8时是插入后一起扩容。</p><h1 id="为什么不直接用hash码作为数组table的下标？"><a href="#为什么不直接用hash码作为数组table的下标？" class="headerlink" title="为什么不直接用hash码作为数组table的下标？"></a>为什么不直接用hash码作为数组table的下标？</h1><p>1、哈希码一般是int型，范围是-(2^31) – 2^31 - 1。容易出现哈希码与数组大小范围不匹配的情况，即计算出来的哈希码可能不在数组大小范围内，从而导致无法匹配存储位置。</p><p>2、常见解决办法就是hash值与数组长度取模。</p><h1 id="为什么容量要求为2的幂？"><a href="#为什么容量要求为2的幂？" class="headerlink" title="为什么容量要求为2的幂？"></a>为什么容量要求为2的幂？</h1><p>一般来说散列表容量的常规设计思路是容量取素数，因为素数导致冲突的概率 &lt; 合数。比如Hashtable初始化容量就是11（不过扩容后不能保证是素数）</p><p><strong>hashmap这样设计的原因是</strong></p><p>1、保证哈希码的均匀性。首先容量可为奇数，也可为偶数。假设数组长度为奇数，那么二进制最后一位是1。假设数组长度为偶数，那么二进制最后一位是0。如果是奇数  hash&amp;(length - 1) 铁定是偶数，就会导致浪费了数组的一半位置（奇数索引无法被放数据，hash冲突概率高）。如果是2的幂这种偶数，length - 1就是奇数，那么最终的hash&amp;(length-1)计算出来的索引位置取决于hash值，也就是说可以是偶数索引，也可以是奇数索引，均匀分布。</p><p>2、length是2的幂时 hash&amp;(length - 1)等价于hash % length。但是&amp;效率更高，而只有length是2的幂，这两个才等价。</p><h1 id="二次扰动的好处"><a href="#二次扰动的好处" class="headerlink" title="二次扰动的好处"></a>二次扰动的好处</h1><p>高位充分参与低位运算，加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突</p><h1 id="什么样类型的数据适合做hashmap的key"><a href="#什么样类型的数据适合做hashmap的key" class="headerlink" title="什么样类型的数据适合做hashmap的key?"></a>什么样类型的数据适合做hashmap的key?</h1><p>像Integer这种，内部属性value被final修饰，保证了Hash值的不可更改性，有效的减少了hash冲突</p><h1 id="为什么选择8作为树化阈值？"><a href="#为什么选择8作为树化阈值？" class="headerlink" title="为什么选择8作为树化阈值？"></a>为什么选择8作为树化阈值？</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java8代码官方解释的原因</span></span><br><span class="line">  * Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">    * use them only when bins contain enough nodes to warrant use</span><br><span class="line">    * (see TREEIFY_THRESHOLD). <span class="function">And when they become too <span class="title">small</span> <span class="params">(due to</span></span></span><br><span class="line"><span class="function"><span class="params">    * removal or resizing)</span> they are converted back to plain bins.  In</span></span><br><span class="line"><span class="function">    * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="function">    * rarely used.  Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="function">    * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="function">    * <span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a</span></span><br><span class="line"><span class="function">    * parameter of about 0.5 on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span></span><br><span class="line"><span class="function">    * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="function">    * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="function">    * occurrences of list size k <span class="title">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * <span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span> /</span></span><br><span class="line"><span class="function">    * <span class="title">factorial</span><span class="params">(k)</span>). The first values are:</span></span><br><span class="line"><span class="function">    *</span></span><br><span class="line"><span class="function">    * 0:    0.60653066</span></span><br><span class="line"><span class="function">    * 1:    0.30326533</span></span><br><span class="line"><span class="function">    * 2:    0.07581633</span></span><br><span class="line"><span class="function">    * 3:    0.01263606</span></span><br><span class="line"><span class="function">    * 4:    0.00157952</span></span><br><span class="line"><span class="function">    * 5:    0.00015795</span></span><br><span class="line"><span class="function">    * 6:    0.00001316</span></span><br><span class="line"><span class="function">    * 7:    0.00000094</span></span><br><span class="line"><span class="function">    * 8:    0.00000006</span></span><br><span class="line"><span class="function">    * more: less than 1 in ten million</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的node节点，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小，作者是根据概率统计而选择了8作为阀值。</p><h1 id="为什么选择6和8作为链表化和树化的阈值"><a href="#为什么选择6和8作为链表化和树化的阈值" class="headerlink" title="为什么选择6和8作为链表化和树化的阈值?"></a>为什么选择6和8作为链表化和树化的阈值?</h1><p>1、首先就是遵循泊松分布概率选了6和8</p><p>2、其次：如果选择6和8（如果链表小于等于6树还原转为链表，大于等于8转为树），中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-JDK7源码讲解</title>
      <link href="post/f1f58db2.html"/>
      <url>post/f1f58db2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本文基于版本 <code>JDK 1.7</code>，即 <code>Java 7</code>。</p></blockquote><h1 id="HashMap用法"><a href="#HashMap用法" class="headerlink" title="HashMap用法"></a>HashMap用法</h1><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>; <span class="comment">// 获得指定键的值</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;  <span class="comment">// 添加键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;  <span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">// 删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;  <span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;  <span class="comment">// 单独抽取key序列，将所有key生成一个Set</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;  <span class="comment">// 单独value序列，将所有value生成一个Collection</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空 </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/11 21:05</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明1个 HashMap的对象</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向HashMap添加数据（成对 放入 键 - 值对）</span></span><br><span class="line">        map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;hadoop&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;产品经理&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 HashMap 的某个数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;key = 产品经理时的值为：&quot;</span> + map.get(<span class="string">&quot;产品经理&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------下面是遍历-------------------&quot;</span>);</span><br><span class="line">        test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取HashMap的全部数据：遍历HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法1：获得key-value的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------方法1------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、获得key-value对（Entry）的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、遍历Set集合，从而获取key-value</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.1、通过迭代器：先获得key-value对（Entry）的Iterator，再循环遍历</span></span><br><span class="line">        Iterator iter1 = entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 遍历时，需先获取entry，再分别获取key、value</span></span><br><span class="line">            Map.Entry entry = (Map.Entry) iter1.next();</span><br><span class="line">            System.out.print((String) entry.getKey());</span><br><span class="line">            System.out.println((Integer) entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：获得key的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------方法2------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得key的Set集合</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取key，再获取value</span></span><br><span class="line">        <span class="comment">// 2.1 通过for循环</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 通过迭代器：先获得key的Iterator，再循环遍历</span></span><br><span class="line">        Iterator iter2 = keySet.iterator();</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">            key = (String) iter2.next();</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3：获得value的Set集合 再遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------方法3------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得value的Set集合</span></span><br><span class="line">        Collection valueSet = map.values();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历Set集合，从而获取value</span></span><br><span class="line">        <span class="comment">// 2.1 获得values 的Iterator</span></span><br><span class="line">        Iterator iter3 = valueSet.iterator();</span><br><span class="line">        <span class="comment">// 2.2 通过遍历，直接获取value</span></span><br><span class="line">        <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">            System.out.println(iter3.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于遍历方式，推荐使用针对 key-value对（Entry）的方式：效率高</span></span><br><span class="line"><span class="comment"> * 原因：</span></span><br><span class="line"><span class="comment"> * 1. 对于 遍历keySet 、valueSet，实质上 = 遍历了2次：</span></span><br><span class="line"><span class="comment"> *    第一次转为iterator迭代器遍历、</span></span><br><span class="line"><span class="comment"> *    第二次从HashMap中取出key和value操作</span></span><br><span class="line"><span class="comment"> * 2. 对于遍历entrySet，实质只遍历了1次，也就是获取存储实体Entry（存储了key 和 value ）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key &#x3D; 产品经理时的值为：3</span><br><span class="line"></span><br><span class="line">------------------下面是遍历-------------------</span><br><span class="line">------------方法1------------</span><br><span class="line">Java1</span><br><span class="line">hadoop2</span><br><span class="line">产品经理3</span><br><span class="line">----------</span><br><span class="line">Java1</span><br><span class="line">hadoop2</span><br><span class="line">产品经理3</span><br><span class="line">------------方法2------------</span><br><span class="line">Java1</span><br><span class="line">hadoop2</span><br><span class="line">产品经理3</span><br><span class="line">----------</span><br><span class="line">Java1</span><br><span class="line">hadoop2</span><br><span class="line">产品经理3</span><br><span class="line">------------方法3------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1、HashMap是散列表的一种，HashMap本身采用数组来进行储存。同时HashMap采用拉链法来解决hash冲突，拉链法就是通过链表来解决hash冲突。所以说整体上来看，HashMap采用的数据结构 = <strong>数组（主） + 单链表（副）</strong></p><p>大致是这样的一个结构</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0001.png"><ul><li>每个链表就算哈希表的桶（bucket）</li><li>链表的节点值就算一个键值对</li></ul><h2 id="重要参数介绍"><a href="#重要参数介绍" class="headerlink" title="重要参数介绍"></a>重要参数介绍</h2><p><strong>构造函数源码</strong></p><p>先贴一下，后面参数介绍会使用到。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = initialCapacity;</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">       inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">       putAllForCreate(m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面的代码有些顺序和源码可能不太一样，仅仅是顺序，笔者是为了更好的阅读体验</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    名词介绍：</span></span><br><span class="line"><span class="comment">    1、容量（capacity）： HashMap中数组【强调一下是数组，不是元素个数】的长度</span></span><br><span class="line"><span class="comment">    2、容量范围：必须是2的幂并且小于最大容量（2的30次方）</span></span><br><span class="line"><span class="comment">    3、初始容量 = 哈希表创建时的容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认初始容量 = 哈希表创建时的容量。默认容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 十进制的2^4=16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量 =  2的30次方（若传入的容量过大，将被最大值替换）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、加载因子(Load factor)：HashMap在其容量自动增加前的一种尺度。</span></span><br><span class="line"><span class="comment">    2、加载因子越大、填满的元素越多 = 空间利用率高、但hash冲突的机会加大、查找效率变低（因为链表变长了）</span></span><br><span class="line"><span class="comment">    3、加载因子越小、填满的元素越少 = 空间利用率小、hash冲突的机会减小、查找效率高（链表不长）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认加载因子 = 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是上面说的数组，hashmap用Entry数组储存k-v键值对</span></span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的大小，即HashMap中存储的键值对的数量。注意：和容量区分开，容量是数组Entry的长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、扩容阈值（threshold）：当哈希表的大小【就是上面的size】 ≥ 扩容阈值时，就会扩容哈希表</span></span><br><span class="line"><span class="comment">    （即扩充HashMap的容量） </span></span><br><span class="line"><span class="comment">    2、扩容 = 对哈希表进行resize操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数</span></span><br><span class="line"><span class="comment">    3、扩容阈值 = 容量 x 加载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组-Entry"><a href="#数组-Entry" class="headerlink" title="数组-Entry"></a>数组-Entry</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Entry类实现了Map.Entry接口</span></span><br><span class="line"><span class="comment"> * 即 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法</span></span><br><span class="line"><span class="comment">**/</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;  <span class="comment">// 键</span></span><br><span class="line">    V value;  <span class="comment">// 值</span></span><br><span class="line">    Entry&lt;K,V&gt; next; <span class="comment">// 指向下一个节点 ，也是一个Entry对象，从而形成解决hash冲突的单链表</span></span><br><span class="line">    <span class="keyword">int</span> hash;  <span class="comment">// hash值</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造方法，创建一个Entry </span></span><br><span class="line"><span class="comment">     * 参数：哈希值h，键值k，值v、下一个节点n </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </span><br><span class="line">        value = v;  </span><br><span class="line">        next = n;  </span><br><span class="line">        key = k;  </span><br><span class="line">        hash = h;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回 与 此项 对应的键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> key;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 与 此项 对应的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;  </span><br><span class="line">        V oldValue = value;  </span><br><span class="line">        value = newValue;  </span><br><span class="line">        <span class="keyword">return</span> oldValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * equals（）</span></span><br><span class="line"><span class="comment">     * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true  </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        Map.Entry e = (Map.Entry)o;  </span><br><span class="line">        Object k1 = getKey();  </span><br><span class="line">        Object k2 = e.getKey();  </span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;  </span><br><span class="line">            Object v1 = getValue();  </span><br><span class="line">            Object v2 = e.getValue();  </span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * hashCode（） </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 当向HashMap中添加元素时，即调用put(k,v)时， </span></span><br><span class="line"><span class="comment">     * 对已经在HashMap中k位置进行v的覆盖时，会调用此方法 </span></span><br><span class="line"><span class="comment">     * 此处没做任何处理 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 当从HashMap中删除了一个Entry时，会调用该函数 </span></span><br><span class="line"><span class="comment">     * 此处没做任何处理 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>中的数组元素 &amp; 链表节点 采用 <code>Entry</code>类实现</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0001.png"><p>1、一个正方形代表一个Entry对象，同时也代表一个键值对。</p><p>2、即 <code>HashMap</code>的本质 = 1个存储<code>Entry</code>类对象的数组 + 多个单链表</p><p>3、Entry对象本质 = 1个映射（键 - 值对），属性包括：键（<code>key</code>）、值（<code>value</code>）、 下个节点( <code>next</code>) = 单链表的指针 = 也是一个<code>Entry</code>对象，用于解决<code>hash</code>冲突</p><h1 id="构造函数源码"><a href="#构造函数源码" class="headerlink" title="构造函数源码"></a>构造函数源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略上节阐述的参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      构造函数1：默认构造函数（无参）</span></span><br><span class="line"><span class="comment">      加载因子和容量为默认，分别是0.75和16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         实际上是调用构造函数3：指定&quot;容量大小&quot;和&quot;加载因子&quot;的构造函数</span></span><br><span class="line"><span class="comment">         传入的指定容量和加载因子均为默认</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      构造函数2：指定&quot;容量大小&quot;的构造函数</span></span><br><span class="line"><span class="comment">      加载因子是默认的0.75 、容量为指定大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际上是调用的也是构造函数3，只是在传入的加载因子参数为默认加载因子</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      构造函数3：指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="comment">      加载因子和容量都是程序员自己指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 &gt; 最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置加载因子</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置扩容阈值 = 初始容量</span></span><br><span class="line"><span class="comment">        1、注意：此处不是真正的阈值，仅是为了接收参数初始容量大小（capacity）、加载因子(Load factor)，</span></span><br><span class="line"><span class="comment">        并没有真正初始化哈希表，即初始化存储数组table</span></span><br><span class="line"><span class="comment">        2、真正初始化哈希表（初始化存储数组table）是在第1次添加键值对时，即第1次调用put()时，下面会</span></span><br><span class="line"><span class="comment">        详细说明。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        threshold = initialCapacity;   </span><br><span class="line"></span><br><span class="line">        init(); <span class="comment">// 一个空方法用于未来的子对象扩展</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      构造函数4：包含“子Map”的构造函数</span></span><br><span class="line"><span class="comment">      即构造出来的HashMap包含传入Map参数</span></span><br><span class="line"><span class="comment">      加载因子和容量均为默认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置容量大小和加载因子为默认值</span></span><br><span class="line">        <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法用于初始化数组和阈值</span></span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="put-源码"><a href="#put-源码" class="headerlink" title="put()源码"></a>put()源码</h1><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*  ①</span></span><br><span class="line"><span class="comment">    1、若哈希表未初始化（即 table为空)，则调用inflateTable方法，使用构造函数时设置的阈值</span></span><br><span class="line"><span class="comment">    (即初始容量)初始化数组table </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*  ②</span></span><br><span class="line"><span class="comment">    1、判断key是否为空值null</span></span><br><span class="line"><span class="comment">2、若key == null，则调用putForNullKey方法，putForNullKey方法最终将该键-值存放到数组</span></span><br><span class="line"><span class="comment">table中的第1个位置，即table[0]。本质：key = Null时，hash值 = 0，故存放到table[0]中）</span></span><br><span class="line"><span class="comment">该位置永远只有1个value，新传进来的value会覆盖旧的value</span></span><br><span class="line"><span class="comment">3、k != null往下走</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//下面就是k != null的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//根据hash值最终获得key对应存放的数组Table中位置(也就是数组下标)</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  ③</span></span><br><span class="line"><span class="comment">    1、通过遍历以该数组元素为头结点的链表，逐个判断是否发生hash冲突，同时判断该key对应的值是</span></span><br><span class="line"><span class="comment">    否已存在</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">/* ④</span></span><br><span class="line"><span class="comment">            1、如果发生了hash冲突，且key也相等。则用新value替换旧value(此时说明发生了更新的情况)，</span></span><br><span class="line"><span class="comment">            注意这里强调的是发生了hash冲突并且key也相等。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//修改次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">/* ⑤</span></span><br><span class="line"><span class="comment">    1、走到这一步有两种情况</span></span><br><span class="line"><span class="comment">      1-1、没有发生hash冲突</span></span><br><span class="line"><span class="comment">      1-2、发生了hash冲突，但是没有在链表中找到key一样的键</span></span><br><span class="line"><span class="comment">    2、接着准备采用头插法，插入链表的头部(也就是数组里面)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="inflateTable"><a href="#inflateTable" class="headerlink" title="inflateTable()"></a>inflateTable()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">将传入的容量大小转化为：&gt;传入容量大小的最小的2的次幂，即如果传入的是容量大小是18，那么转化后，</span></span><br><span class="line"><span class="comment">初始化容量大小为32（即2的5次幂）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//重新计算阈值 threshold = 容量 * 加载因子  </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用计算后的初始容量（已经是2的次幂） 初始化数组table（作为数组长度）即 哈希表的容量大小 = </span></span><br><span class="line"><span class="comment">    数组大小（长度）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="roundUpToPowerOf2"><a href="#roundUpToPowerOf2" class="headerlink" title="roundUpToPowerOf2()"></a>roundUpToPowerOf2()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若容量超过了最大值，初始化容量设置为最大值 ；否则，设置为&gt;传入容量大小的最小的2的次幂</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">    ? MAXIMUM_CAPACITY</span><br><span class="line">    : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="putForNullKey"><a href="#putForNullKey" class="headerlink" title="putForNullKey()"></a>putForNullKey()</h2><p>当 key ==null时，将该 key-value 的存储位置规定为数组table 中的第1个位置，即table [0]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、遍历以table[0]为首的链表，寻找是否存在key==null对应的键值对</span></span><br><span class="line"><span class="comment">   1-1、若有：则用新value替换旧value；同时返回旧的value值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、若无key==null的键，那么调用addEntry（），将空键和对应的值封装到Entry中，并放到table[0]中</span></span><br><span class="line"><span class="comment">    2、能走到这里的情况就是table[0]位置之前没有元素，这一次是第一次添加key为null的元素</span></span><br><span class="line"><span class="comment">    3、k == null已经是固定放在了table[0]的位置，不会有链表存在，只会有一个元素。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此处可以看出：</p><ul><li><code>HashMap</code>的键<code>key</code> 可为<code>null</code>（区别于 <code>HashTable</code>的<code>key</code> 不可为<code>null</code>）</li><li><code>HashMap</code>的键<code>key</code> 可为<code>null</code>且只能为1个，但值<code>value</code>可为null且为多个</li></ul><h2 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h2><blockquote><p>这个方法比较重要，1.7和1.8改动的比较大</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、该函数在JDK7和8中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的</span></span><br><span class="line"><span class="comment">   * 哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span></span><br><span class="line"><span class="comment">   * 2、JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span></span><br><span class="line"><span class="comment">   * 3、JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      h ^= k.hashCode();</span><br><span class="line"><span class="comment">//4次位运算 + 5次异或运算</span></span><br><span class="line">      h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">      <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="indexFor"><a href="#indexFor" class="headerlink" title="indexFor()"></a>indexFor()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里h &amp; (length-1)的意思就是hash值与数组长度取模。只是因为数组长度是特殊的2的幂，</span></span><br><span class="line"><span class="comment">//所以这个等价关系刚好成立</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="addEntry"><a href="#addEntry" class="headerlink" title="addEntry()"></a>addEntry()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：添加键值对（Entry）到HashMap中。参数3:插入数组table的索引位置,也就是数组下标</span></span><br><span class="line"><span class="comment">//注意：JDK7是先扩容再插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、插入前，先判断容量是否足够</span></span><br><span class="line"><span class="comment">          1.1、若不足够，则进行扩容（2倍）、重新计算Hash值、重新计算存储数组下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 1.2、若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中</span></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="扩容源码"><a href="#扩容源码" class="headerlink" title="扩容源码"></a>扩容源码</h1><p>下面的也是JDK7扩容的步骤，接着上面的<code>addEntry()</code></p><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 作用：当大小不足时（size &gt; 阈值，注意是size，不是容量），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，返回   </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4、根据新容量（2倍容量）新建1个数组，即newTable </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 6、新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 7、重新设置阈值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入。但是这样会导致扩容完成后，链表逆序</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="comment">//通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 1、遍历以该数组元素为首的链表</span></span><br><span class="line"><span class="comment">                 2、转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//重新计算每个元素的存储位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这个地方暂时先放着，后面讲死循环链表的时候会讲到</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">//讲当前元素，赋给新数组的对应下标位置。</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">// 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>大概画了一下图：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0002.png"/><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0003.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0004.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0005.png"><p>1、在扩容<code>resize（）</code>过程中，在将旧数组上的数据转移到新数组上时，转移操作就是按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况。</p><p>2、设重新计算存储位置后不变，即扩容前 1-&gt;2-&gt;3，扩容后 = 3-&gt;2-&gt;1</p><p>3、此时若（多线程）并发执行 put（）操作，一旦出现扩容情况，则 <strong>容易出现环形链表</strong>，从而在获取数据、遍历链表时形成死循环（Infinite Loop），即<strong>线程不安全</strong>。</p><h2 id="createEntry"><a href="#createEntry" class="headerlink" title="createEntry()"></a>createEntry()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++; <span class="comment">//这里才进行size++</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>举个例子说明流程：</p><p>1、假设hashmap中容量为16，加载因为为0.75 = 12。</p><p>2、此时hashmap中有11个元素，也就是size == 11，在你添加第12个元素时。看代码，此时size还是11，所以并不会扩容。只有在你调用完<code>createEntry()</code>,<code>size++</code>执行完毕后，size变成12。</p><p>3、在添加第13个元素时，才会进入if逻辑里进行先扩容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="扩容出现的死循环链表"><a href="#扩容出现的死循环链表" class="headerlink" title="扩容出现的死循环链表"></a>扩容出现的死循环链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入。但是这样会导致扩容完成后，链表逆序</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="comment">//通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 1、遍历以该数组元素为首的链表</span></span><br><span class="line"><span class="comment">                 2、转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next; <span class="comment">//pos_1</span></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//重新计算每个元素的存储位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这个地方暂时先放着，后面讲死循环链表的时候会讲到</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">//讲当前元素，赋给新数组的对应下标位置。</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">// 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>1、为了演示方便，初始状态时，hashmap容量为2，加载因子为默认的0.75.</p><h2 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h2><p><strong>hashmap初始状态</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0006.png"><p>1、此时只有一个元素，扩容阈值为2*0.75 = 1.5。</p><p>2、此时假设有两个线程，线程a和线程b同时put，并且都没有进入到addEntry()方法里的if逻辑【因为此时size都没有++，size == 1   1 &lt; 1.5  所以if判断不成立。】。两个线程都准备同时调用createEntry()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>3、线程a put的是 e3 = &lt;k3,v3&gt;。线程b put的是e2 = &lt;k2,v2&gt;。两个都调用了<code>createEntry()</code>方法。</p><h2 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h2><p><strong>两个线程调用完毕之后，hashmap目前是这样的。</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0007.png"><p>此时size==3。下次再进行put的时候，<strong>addEntry()方法里的if判断就会成立</strong>。</p><h2 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h2><p>1、接着，又来了两个线程，线程1和线程2。【假设线程1put的是e1，线程2put的是e0。其实也不用管它们两put的是谁】</p><p>2、两个线程都同时调用resize()方法，新数组已经扩容完毕，准备转移旧数组上的数据到新数组里。也就是准备调用resize()里的下面这个方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5、将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br></pre></td></tr></table></figure><p>3、来看下此时内存里的状态</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0008.png"/><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0009.png"><h2 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h2><p>来看下源码【上面源码里有注释，这里把注释去掉】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line"><span class="comment">//pos_1</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);   </span><br><span class="line">                <span class="comment">//pos_2</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">//pos_3</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">//pos_4</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、假设线程1<strong>执行完</strong>代码pos_1位置后，暂时挂起。此时e == e2  e.next == e3</p><p>2、线程2直接<strong>扩容完毕</strong>，那么完成后的状态是这样【假设e2和e3还是hash到同一个位置】</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0010.png"><p>3、线程1还是原来的状态</p><blockquote><p>强调一点：线程2已经扩容完毕</p></blockquote><h2 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h2><p>目前两个线程里的新数组是这样的</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0011.png"><p>为了方便后面观看，我画成这样。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0012.png"><h2 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line"><span class="comment">//pos_1</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);   </span><br><span class="line">                <span class="comment">//pos_2</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">//pos_3</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">//pos_4</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>之前说过：假设线程1<strong>执行完</strong>代码pos_1位置后，暂时挂起。此时e == e2   e.next == e3【也就是next == e3】</p></blockquote><p>1、线程1唤醒后，继续执行pos_2，pos_3，pos_4</p><p>2、执行pos_2：意思是e2的next指针指向了线程1的新hash表【也就是newTable1】，因为newTable1是新的所以为null，</p><p>所以e2.next = null。</p><p>3、执行pos_3：newTable1[3] = e2;</p><p>4、执行pos_4： e = e3;</p><p>也就变成了下面这个样子。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0013.png"><h2 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h2><p>1、线程1继续执行循环</p><blockquote><p>注意之前强调过线程2已经扩容完毕，那么table就已经被指向了newTable2，也就是说第二次循环时，线程1所循环的table变量就是newTable2</p></blockquote><p>2、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line"><span class="comment">//pos_1</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);   </span><br><span class="line">                <span class="comment">//pos_2</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                <span class="comment">//pos_3</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                <span class="comment">//pos_4</span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、执行pos_1：此时e == e3，那么next就是 e3.next，此时next == e2；</p><p>2、执行pos_2：经过第一轮循环，newTable1[3] == e2。那么执行完这行代码后，e3.next还是等于e2【相当于没执行】</p><p>3、执行pos_3：newTable1[3] == e3。</p><p>4、执行pos_4：e = e2</p><p>执行完，变成这样。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0014.png"><h2 id="步骤8"><a href="#步骤8" class="headerlink" title="步骤8"></a>步骤8</h2><p>线程1执行第三次循环</p><p>1、执行pos_1：next = e2.next得到  next == null。</p><p>2、执行pos_2： <code>e.next = newTable[i]</code>     e2.next == newTable1[3]。也就是相当于 e2.next == e3</p><p>3、执行pos_3： newTable[i] = e得到  newTable1[3] == e2</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_collection/HashMap/JDK7/0015.png"><p>这样就形成了循环链表，再get()数据就会陷入死循环。</p><h1 id="get-源码"><a href="#get-源码" class="headerlink" title="get()源码"></a>get()源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//当key==null时，则到table[0]为头结点的链表去寻找对应 key == null的键</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//当key ≠ null时，去获得对应值 </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历以table[0]为头结点的链表，寻找 key==null 对应的值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从table[0]中取key==null的value值 </span></span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> e.value; </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据key值，通过hash（）计算出对应的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据hash值计算出对应的数组下标,遍历以该数组下标的数组元素为头结点的链表所有节点，</span></span><br><span class="line">        <span class="comment">//寻找该key对应的值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  e != <span class="keyword">null</span>;  e = e.next) &#123;  </span><br><span class="line"></span><br><span class="line">            Object k;  </span><br><span class="line">            <span class="comment">// 若 hash值和key 相等，则证明该Entry = 我们要的键值对</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                <span class="keyword">return</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第四阶段-AQS源码解读-[1]</title>
      <link href="post/92c4503d.html"/>
      <url>post/92c4503d.html</url>
      
        <content type="html"><![CDATA[<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/22 21:12</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 可重入锁:</span></span><br><span class="line"><span class="comment"> * 1、可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。</span></span><br><span class="line"><span class="comment"> * 2、是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个</span></span><br><span class="line"><span class="comment"> * 对象)，不会因为之前已经获取过还没释放而阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLockA = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------外层调用&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------中层调用&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (objectLockA)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------内层调用&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====外层&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====中层&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====内层&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReEnterLockDemo().m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><blockquote><p>官方说明：<a href="https://www.apiref.com/java11-zh/java.base/java/util/concurrent/locks/LockSupport.html">https://www.apiref.com/java11-zh/java.base/java/util/concurrent/locks/LockSupport.html</a></p></blockquote><p>LockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程，相当于线程等待和唤醒机制的加强版。</p><h2 id="3种让线程等待和唤醒的方法"><a href="#3种让线程等待和唤醒的方法" class="headerlink" title="3种让线程等待和唤醒的方法"></a>3种让线程等待和唤醒的方法</h2><ul><li>方式1:  使用Object中的wait()方法让线程等待， 使用Object中的notify()方法唤醒线程</li><li>方式2:  使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程 </li><li>方式3:  LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h2 id="Object类提供的等待唤醒机制的缺点"><a href="#Object类提供的等待唤醒机制的缺点" class="headerlink" title="Object类提供的等待唤醒机制的缺点"></a>Object类提供的等待唤醒机制的缺点</h2><h3 id="正常情况下"><a href="#正常情况下" class="headerlink" title="正常情况下"></a>正常情况下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)</span><br><span class="line">            &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A------come in</span><br><span class="line">B------通知</span><br><span class="line">A------被唤醒</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="异常情况1"><a href="#异常情况1" class="headerlink" title="异常情况1"></a>异常情况1</h3><p>去掉同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            synchronized (objectLock)&#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            synchronized (objectLock)&#123;</span></span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------通知&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A------come in</span><br><span class="line">Exception in thread &quot;A&quot; Exception in thread &quot;B&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at com.youth.guiguthirdquarter.AQS.LockSupportDemo1.lambda$main$0(LockSupportDemo1.java:16)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">at java.lang.Object.notify(Native Method)</span><br><span class="line">at com.youth.guiguthirdquarter.AQS.LockSupportDemo1.lambda$main$1(LockSupportDemo1.java:26)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>报错了。</p><h3 id="异常情况2"><a href="#异常情况2" class="headerlink" title="异常情况2"></a>异常情况2</h3><p>先唤醒，再等待。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)</span><br><span class="line">            &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">B------通知</span><br><span class="line">A------come in</span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>死循环，A无法被唤醒了。</p><p>这两点我们之前也说过，Object类提供的wait和notify</p><p>1、只能在synchronized同步代码块里使用</p><p>2、只能先等待（wait），再唤醒（notify）。顺序一旦错了，那个等待线程就无法被唤醒了。</p><h2 id="Condion类提供的等待唤醒机制的缺点"><a href="#Condion类提供的等待唤醒机制的缺点" class="headerlink" title="Condion类提供的等待唤醒机制的缺点"></a>Condion类提供的等待唤醒机制的缺点</h2><p>缺点和Object类里的wait，notify一样。</p><p>1、只能在lock同步代码块里使用，不然就报错</p><p>2、只能先等待（await），再唤醒（signal）。顺序一旦错了，那个等待线程就无法被唤醒了。</p><p>但相对于wait，notify改进的一点是，可以绑定lock进行定向唤醒。</p><h2 id="LockSupport的优点"><a href="#LockSupport的优点" class="headerlink" title="LockSupport的优点"></a>LockSupport的优点</h2><p>有的时候我不需要进入同步代码块，我只是需要让线程阻塞，这个时候LockSupport就发挥作用了。并且还解决了之前的第二个问题，也就是等待必须在唤醒的前面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span>  <span class="comment">//除非许可证可用，否则禁用当前线程以进行线程调度。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span><span class="title">unpark</span><span class="params">(Thread thread)</span><span class="comment">//如果给定线程尚不可用，则为其提供许可。</span></span></span><br></pre></td></tr></table></figure><ul><li><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p></li><li><p>LockSupport类使用了一种名为Permit(许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可(permit),<br>permit只有两个值1和零，默认是零。可以把许可看成是一种(0,1)信号量(Semaphore），但与Semaphore不同的是，许可的累加上限是1。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LockSupport底层还是UNSAFE（前面讲过）。</p><ul><li><p>permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时,park方法会被唤醒，然后会将permit再次设置为0并返回。</p></li><li><p>调用unpark(thread)方法后，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)会自动唤醒thread线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p></li><li><p>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0，<br>调用一次unpark就将0变成1，<br>调用一次park会消费permit，也就是将1变成o，同时park立即返回。<br>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。<br>每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累凭证。</p></li><li><p>形象的理解<br>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。<br>当调用park方法时</p><pre><code>如果有凭证，则会直接消耗掉这个凭证然后正常退出;如果无凭证，就必须阻塞等待凭证可用;</code></pre><p>而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无效。</p></li></ul><p>我们用LockSupport来测试下之前的异常场景</p><h3 id="异常情况1-1"><a href="#异常情况1-1" class="headerlink" title="异常情况1"></a>异常情况1</h3><p>无同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         LockSupport：俗称 锁中断</span></span><br><span class="line"><span class="comment">         LockSupport它的解决的痛点</span></span><br><span class="line"><span class="comment">         1。LockSupport不用持有锁块，不用加锁，程序性能好，</span></span><br><span class="line"><span class="comment">         2。不需要等待和唤醒的先后顺序，不容易导致卡死</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----begin-时间：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒-时间：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 通知t1...&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1 ----begin-时间：<span class="number">1603376148147</span></span><br><span class="line">t1 ----被唤醒-时间：<span class="number">1603376148147</span></span><br><span class="line">main 通知t1...</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>没有问题</p><h3 id="异常情况2-1"><a href="#异常情况2-1" class="headerlink" title="异常情况2"></a>异常情况2</h3><p>先唤醒，再阻塞（等待）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----begin-时间：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒-时间：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 通知t1...&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main 通知t1...</span><br><span class="line">t1 ----begin-时间：1603376257183</span><br><span class="line">t1 ----被唤醒-时间：1603376257183</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，如果你先唤醒了。那么后面的<code>LockSupport.park();</code>就相当于瞬间被唤醒了，不会和之前一样程序卡死。为什么呢？结合之前分析的流程</p><p>1、先执行unpark，将许可证由0变为1</p><p>2、然后park来了发现许可证此时为0（也就是有许可证），那么他就不会阻塞，马上就往后执行。同时消耗许可证（也就是将1又变为0）。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h2><p><strong>字面意思：</strong>抽象的队列同步器</p><p><strong>技术翻译：</strong>是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石， 通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量<code>state</code>表示持有锁的状态。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0001.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0011.png"><p>AbstractOwnableSynchronizer<br>AbstractQueuedLongSynchronizer<br>AbstractQueuedSynchronizer    </p><p>上面几个都是AQS，但是通常地: AbstractQueuedSynchronizer简称为AQS。</p><p>AQS是一个抽象的父类，可以将其理解为一个框架。基于AQS这个框架，我们可以实现多种同步器，比如下方图中的几个Java内置的同步器。同时我们也可以基于AQS框架实现我们自己的同步器以满足不同的业务场景需求。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0002.png"><h2 id="AQS能干嘛？"><a href="#AQS能干嘛？" class="headerlink" title="AQS能干嘛？"></a>AQS能干嘛？</h2><p>加锁会导致阻塞：有阻塞就需要排队，实现排队必然需要有某种形式的队列来进行管理</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0003.png"><p>1、抢到资源的线程直接使用办理业务，抢占不到资源的线程的必然涉及一种<strong>排队等候机制</strong>，抢占资源失败的线程继续去等待(类似办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候)，仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p><p>2、既然说到了<strong>排队等候机制</strong>，那么就一定 会有某种队列形成，这样的队列是什么数据结构呢?</p><p>3、如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点(Node) ，通过CAS、自旋以及LockSuport.park()的方式，维护state变量的状态，使并发达到同步的效果。</p><h1 id="AQS独占模式（以ReentrantLock-源码为例）"><a href="#AQS独占模式（以ReentrantLock-源码为例）" class="headerlink" title="AQS独占模式（以ReentrantLock 源码为例）"></a>AQS独占模式（以ReentrantLock 源码为例）</h1><h2 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做当前持有锁的线程 可能是最好理解的。实际上可能略有出入，往下看分析即可</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure><h2 id="Node类结构"><a href="#Node类结构" class="headerlink" title="Node类结构"></a>Node类结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// 代码此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// 等待condition唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 共享模式同步状态获取讲会无条件的传播下去（共享模式下，该字段才会使用）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// ===============-2和-3用的不多，暂时不分析======================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到，waitStatus初始值为0)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><h2 id="AQS队列基本结构"><a href="#AQS队列基本结构" class="headerlink" title="AQS队列基本结构"></a>AQS队列基本结构</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0004.png"><p>注意排队队列，不包括head（也就是后文要说的哨兵节点）。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youth.guiguthirdquarter.AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/25 21:59</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//带入一个银行办理业务的案例来模拟我们的AQS如何进行线程的管理和通知唤醒机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3个线程模拟3个来银行网点，受理窗口办理业务的顾客</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//A顾客就是第一个顾客，此时受理窗口没有任何人，A可以直接去办理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----A thread come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MINUTES.sleep(<span class="number">20</span>); &#125;<span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个顾客，第二个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时B只能等待，</span></span><br><span class="line">        <span class="comment">//进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----B thread come in&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三个顾客，第三个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时C只能等待，</span></span><br><span class="line">        <span class="comment">//进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----C thread come in&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这样的一个实际例子说明。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0005.png"><h2 id="非公平锁lock-加锁"><a href="#非公平锁lock-加锁" class="headerlink" title="非公平锁lock()加锁"></a>非公平锁lock()加锁</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           1、非公平锁不公平的第一个原因就出现在这里。刚准备加锁的线程，这里会用CAS抢一下锁（也就是通过</span></span><br><span class="line"><span class="comment">           看state的状态）。如果抢成功了就调用setExclusiveOwnerThread，设置当前持有独占锁的线程为本</span></span><br><span class="line"><span class="comment">           线程。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">//如果抢锁失败就走入这个流程，抢锁失败说明当前锁已经被占用了</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//相当于只要调用了这个方法，说明线程独占锁成功</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">       exclusiveOwnerThread = thread;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>A线程刚进来的时候，AQS的head和tail节点都还没有被初始化，则会被默认初始化为null。并且state默认初始化为0。</p></blockquote><p>1、A线程进去窗口办理业务，此时state == 0，那么CAS就直接成功了，并且把sate改为1。然后调用下<code>setExclusiveOwnerThread</code>，就直接结束了。【加锁成功，直接返回】</p><p><strong>B线程</strong></p><p>1、接着B线程去窗口办理业务，因为之前A线程把state变为了1，那么B线程在进行第一个if-CAS判断就会失败。所以就走到了else分支，调用<code>acquire(1)</code>方法。</p><p><strong>C线程</strong></p><p>因为A线程占用着锁，C线程执行逻辑和B一样。（后续假设C进行加锁时间在B后面一点）</p><h3 id="acquire-和tryAcquire"><a href="#acquire-和tryAcquire" class="headerlink" title="acquire()和tryAcquire()"></a>acquire()和tryAcquire()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、acquire()方法来自父类AQS，我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span></span><br><span class="line"><span class="comment">   否则，acquireQueued方法会将线程压到队列中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时 arg == 1</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1、首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试。因为有可能直接就成功了呢，也就不需要</span></span><br><span class="line"><span class="comment">       进队列排队了。</span></span><br><span class="line"><span class="comment">       2、有可能成功的情况就是，在走到这一步的时候，前面占锁的线程刚好释放锁</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">             selfInterrupt();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、上面的tryAcquire里会直接调用ReentrantLock类的nonfairTryAcquire方法，</span></span><br><span class="line"><span class="comment">2、尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">   3、有两种情况会返回true：</span></span><br><span class="line"><span class="comment">   1.没有线程在等待锁</span></span><br><span class="line"><span class="comment">   2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1、state == 0 此时此刻没有线程持有锁</span></span><br><span class="line"><span class="comment">       2、前面也说了有可能成功的情况就是，在走到这一步的时候，前面占锁的线程刚好释放锁</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//那就用CAS尝试一下，成功了就获取到锁了。</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="comment">// 会进入这个else if分支，说明是重入锁了，需要操作：state=state+1</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>B线程</strong></p><p>1、B线程最终走进了<code>nonfairTryAcquire()</code>方法，但是因为A还在占锁（占着处理窗口state），所以此时state为1，B线程走到else if分支进行判断。</p><p>2、B线程发现已经占有锁的线程不是自己，说明不是重入锁，也不会进入else if分支。最终返回fasle，回到<code>tryAcquire</code>，准备挂起线程。</p><p><strong>C线程</strong></p><p>因为A线程占用着锁，C线程执行逻辑和B一样</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、假设tryAcquire(arg) 返回false，那么代码将执行：acquireQueued(addWaiter(Node.EXCLUSIVE),</span></span><br><span class="line"><span class="comment">arg)，这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line"><span class="comment">2、此方法的作用是把线程包装成node，同时进入到队列中。参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class="line"><span class="comment">3、以下几行代码想把当前node加到链表的最后面去，也就是进到队列的最后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">//得到尾节点（head和tail在没有初始化前都是null，没有初始化的时候也说明队列为空）</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//队列不为空时（即之前已经初始化过了），会进入下面这个分支，此时只需要将新的node加入队尾</span></span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; </span><br><span class="line">           <span class="comment">// 将当前的队尾节点，设置为自己的前驱 </span></span><br><span class="line">           node.prev = pred; </span><br><span class="line">           <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为排队队列新的尾巴</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，上面已经有</span></span><br><span class="line"><span class="comment">               node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1、仔细看看上面的代码，有两种情况会走到这里</span></span><br><span class="line"><span class="comment">          1、pred==null(说明队列是空的) </span></span><br><span class="line"><span class="comment">          2、CAS设置队尾失败(有线程在竞争入队)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>之前说了A线程刚进来的时候，AQS的head和tail节点都还没有被初始化，则会被默认初始化为null</p></blockquote><p><strong>B线程</strong></p><p>1、B线程进入<code>addWaiter()</code>，发现pred == null，直接进入<code>enq()</code></p><p><strong>C线程</strong></p><p>1、【前面说了C在B后面】，C线程进来后和B不一样，因为B在后面已经设置了tail指针。那么C线程在判断的时候pred 就不是null，就直接进入了if分支</p><p>2、C在if逻辑里准备入队，进行相应设置后，变成下面这样。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0006.png"><h3 id="enq"><a href="#enq" class="headerlink" title="enq()"></a>enq()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、采用空的for循环，以自旋的方式入队，到这个方法只有两种可能：队列为空，或者有线程竞争入队【上面说过】</span></span><br><span class="line"><span class="comment">   2、自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           </span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1、进入这个分支，说明是队列为空的这种情况，那么就准备初始化一个空的节点（new Node()）</span></span><br><span class="line"><span class="comment">          作为排队队列的head。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、初始化head节点，前面说过 head 和 tail 初始化的时候都是 null 的。</span></span><br><span class="line"><span class="comment">               2、还是一步CAS，因为可能是很多线程同时进来呢   </span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))                    </span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、注意这里传的参数是new Node()，说明是一个空的节点（并不是我们B线程封装的节点，</span></span><br><span class="line"><span class="comment">               这个空节点只作为占位符，称作傀儡节点或者哨兵节点）。这个时候head节点的waitStatus==0,</span></span><br><span class="line"><span class="comment">               看new Node()构造方法就知道了。注意：new Node()虽然是空节点，但他不是null</span></span><br><span class="line"><span class="comment">               2、这个时候有了head，但是tail还是null，设置一下，把tail指向head，放心，马上就有</span></span><br><span class="line"><span class="comment">               线程要来了，到时候tail就要被抢了</span></span><br><span class="line"><span class="comment">               3、注意：这里只是设置了tail=head，这里可没return哦。所以，设置完了以后，继续for</span></span><br><span class="line"><span class="comment">               循环，下次就到下面的else分支了</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;             </span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、下面几行，和上一个方法 addWaiter 是一样的，只是这个套在无限循环里，就是将当前</span></span><br><span class="line"><span class="comment">               线程排到队尾，有线程竞争的话排不上重复排，直到排上了再return </span></span><br><span class="line"><span class="comment">               【这里看不懂的话就看下面的例子】               </span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               </span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>B线程</strong></p><p><strong>第一轮循环</strong></p><p>1、B线程进入enq()。首先发现t == tail 依然为null，那么就直接进入if分支。</p><p>2、进入if分支后，调用<code>compareAndSetHead(new Node())</code>准备初始化head节点。注意这里传的参数是<code>new Node()</code>，说明是一个空的节点（并不是我们B线程封装的节点，这个空节点只作为占位符，<strong>称作傀儡节点或者哨兵节点</strong>），然后将head赋值给tail。</p><blockquote><p> 补充：双向链表中，第一个节点为虚节点(也叫哨兵节点)，其实并不存储任何信息，只是占位。 真正的第一个有数据的节点，是从第二个节点开始的。</p></blockquote><p>此时队列变成了下面的样子：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0007.png"><p>3、然后if结束之后，继续空的for循环，B线程开始了第二轮循环。</p><p><strong>第二轮循环</strong></p><p>1、第二次循环再过来的时候，t == tail，但此时tail不再为null，所以进入else分支。</p><p>2、<code>node.prev = t</code>，进入if之后，让B节点的prev指针指向t，然后<code>compareAndSetTail(t, node)</code>设置尾节点</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0008.png"><p>3、CAS设置尾节点成功之后，执行if里的逻辑</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0009.png"><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、现在，又回到这段代码了</span></span><br><span class="line"><span class="comment">    if (!tryAcquire(arg) </span></span><br><span class="line"><span class="comment">           &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line"><span class="comment">        selfInterrupt();</span></span><br><span class="line"><span class="comment">   2、acquireQueued这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入排队队列队尾</span></span><br><span class="line"><span class="comment">   3、注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，意味着上面这段</span></span><br><span class="line"><span class="comment">   代码将进入selfInterrupt()</span></span><br><span class="line"><span class="comment">   4、这个方法非常重要，真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();             </span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、p == head 说明当前节点虽然进到了排队队列，但是是队列的第一个，因为它的前驱是head</span></span><br><span class="line"><span class="comment">               （或者说是哨兵节点，因为head指向了哨兵节点）</span></span><br><span class="line"><span class="comment">               2、注意，队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为排队队列</span></span><br><span class="line"><span class="comment">               3、所以当前节点可以去试抢一下锁</span></span><br><span class="line"><span class="comment">               4、这里我们说一下，为什么可以去试试：它是排队队列队头，所以作为队头，可以去试一试能不能</span></span><br><span class="line"><span class="comment">               拿到锁，因为可能之前的线程已经释放锁了。如果尝试成功，那它就不需要被挂起，直接拿锁，</span></span><br><span class="line"><span class="comment">               效率会高</span></span><br><span class="line"><span class="comment">               5、tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC，这个后面释放锁的时候会讲</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">               1、到这里，说明上面的if分支没有成功。</span></span><br><span class="line"><span class="comment">                 1、要么当前node本来就不是队头，</span></span><br><span class="line"><span class="comment">                 2、要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//tryAcquire()方法抛异常时，failed为true，会取消当前节点的排队。</span></span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);<span class="comment">//取消排队</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>B线程</strong></p><p>1、进入<code>acquireQueued()</code>后，发现也是一个空循环。首先通过<code>node.predecessor()</code>得到B节点的前一个节点P，也就是哨兵节点。</p><p>2、p == head为true。然后if里再次执行<code>tryAcquire(arg)</code>拿一次锁【流程前面已经分析过了，不重复了】。因为A线程任然持有锁，所以最终结果B节点<code>tryAcquire</code>失败。准备挂起线程</p><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span></span><br><span class="line"><span class="comment">   第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">       <span class="comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       1、前驱节点 waitStatus大于0 ，之前说过，大于0说明前驱节点取消了排队。</span></span><br><span class="line"><span class="comment">       2、这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。所以</span></span><br><span class="line"><span class="comment">       下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，简单说，就是为了找个好爹，因为你还</span></span><br><span class="line"><span class="comment">       得依赖它来唤醒呢，如果前驱节点取消了排队，找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           1、如果进入到这个分支意味着什么，前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line"><span class="comment">           在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line"><span class="comment">           2、正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0，用CAS将前驱节点</span></span><br><span class="line"><span class="comment">           的waitStatus设置为Node.SIGNAL(也就是-1)，表示我后面有节点需要被唤醒。</span></span><br><span class="line"><span class="comment">           3、这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继</span></span><br><span class="line"><span class="comment">           节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，</span></span><br><span class="line"><span class="comment">           我们知道，每个node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。</span></span><br><span class="line"><span class="comment">           这里涉及的是两个问 题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 </span></span><br><span class="line"><span class="comment">           “waitStatus代表后继节点的状态”这种思路去看一遍源码。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class="line"><span class="comment">   这个方法结束根据返回值我们简单分析下：</span></span><br><span class="line"><span class="comment">      1、如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line"><span class="comment">      我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line"><span class="comment">      2、如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">   需要跳回到前面这个方法</span></span><br><span class="line"><span class="comment">   if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class="line"><span class="comment">                  parkAndCheckInterrupt())</span></span><br><span class="line"><span class="comment">                  interrupted = true;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>B线程</strong></p><p><strong>第一次循环</strong></p><p>1、B线程的前驱节点是哨兵节点（ws == 0），  所以最终走了else分支，执行了  <code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>方法。将哨兵节点的<code>compareAndSetWaitStatus</code>值变为了-1</p><p>2、返回false，返回到<code>acquireQueued()</code>进行第二次循环【不再赘述】。</p><p><strong>第二次循环</strong></p><p>1、此时B线程的前驱节点–哨兵节点的ws == -1。那么此方法返回true，准备执行parkAndCheckInterrupt</p><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、如果shouldParkAfterFailedAcquire(p, node)返回true，那么需要执行parkAndCheckInterrupt():</span></span><br><span class="line"><span class="comment">    这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的，</span></span><br><span class="line"><span class="comment">    2、这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span></span><br><span class="line"><span class="comment">    2、仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会</span></span><br><span class="line"><span class="comment">    返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱</span></span><br><span class="line"><span class="comment">    设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3、解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span></span><br><span class="line"><span class="comment">    主要是为了应对在经过这个方法后，node已经是head的直接后继节点了。</span></span><br><span class="line"><span class="comment">    4、假设返回fasle的时候，node已经是head的直接后继节点了，但是你直接挂起了线程，就要走别人唤醒你的那</span></span><br><span class="line"><span class="comment">    几步代码。那这里完全可以重新走一遍for循环，直接尝试下获取锁，可能会更快。注意是可能，不代表一定，因为</span></span><br><span class="line"><span class="comment">    你也无法确定unparkSuccessor释放锁，通知后继节点这个方法执行的快慢。但是你多尝试一次获取锁，总归是快的。</span></span><br><span class="line"><span class="comment">    for (;;) &#123;</span></span><br><span class="line"><span class="comment">            final Node p = node.predecessor();</span></span><br><span class="line"><span class="comment">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span></span><br><span class="line"><span class="comment">                setHead(node);</span></span><br><span class="line"><span class="comment">                p.next = null; // help GC</span></span><br><span class="line"><span class="comment">                failed = false;</span></span><br><span class="line"><span class="comment">                return;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，B线程才算真正的入队坐稳了。B线程在这里阻塞，或者说挂起。</p><h2 id="非公平锁lock-解锁"><a href="#非公平锁lock-解锁" class="headerlink" title="非公平锁lock()解锁"></a>非公平锁lock()解锁</h2><p>然后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><h3 id="release-和tryRelease"><a href="#release-和tryRelease" class="headerlink" title="release()和tryRelease()"></a>release()和tryRelease()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//h是哨兵节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到ReentrantLock看tryRelease方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒后继节点，从上面调用处知道，参数node是head头结点（或者说是哨兵节点，因为本身head就指向了哨兵节点）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）从队尾往前找，</span></span><br><span class="line"><span class="comment">    找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B线程</strong></p><p>1、哨兵节点的后一个节点就是B节点，B节点的waitStatus == 0，所以就直接走唤醒线程那一步了。</p><h3 id="唤醒之后"><a href="#唤醒之后" class="headerlink" title="唤醒之后"></a>唤醒之后</h3><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></table></figure><p>返回这个方法进行第三次循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node还是B节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//A线程走了，B就可以tryacquire成功</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC，</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、B线程<code>tryAcquire()</code>成功之后就占有了state，也就是拿到了锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2、此时state那里有B线程的引用<code>exclusiveOwnerThread</code>，队列里也有B线程的引用，需要把队列里的多余引用给GC掉。</p><p>3、AQS采用的是将head指向B节点成为新的哨兵节点，旧的哨兵节点因为没有任何引用指向了，慢慢就会被GC掉。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Fourth_stage/0010.png"><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>看了上面的源码，这个知识点应该是可以很轻松理解的。公平锁和非公平锁在源码层次只有几处不一样。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁的-lock-方法"><a href="#非公平锁的-lock-方法" class="headerlink" title="非公平锁的 lock 方法"></a>非公平锁的 lock 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、和公平锁相比，这里会直接先进行一次CAS，成功就返回了。这是第一处不一样</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer类的acquire(int arg)方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对队列进行判断，直接CAS抢，这是第二点不一样【对比请看下方公平锁的lock】</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁的-lock-方法"><a href="#公平锁的-lock-方法" class="headerlink" title="公平锁的 lock 方法"></a>公平锁的 lock 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer类的acquire(int arg)方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、和非公平锁相比，这里多了一个判断：是否有线程在队列列等待，有我就不抢了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p><a href="https://coderbee.net/index.php/concurrent/20131115/577">CLH队列</a></p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> AQS源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万字长文详解Java泛型</title>
      <link href="post/adb2faf0.html"/>
      <url>post/adb2faf0.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h2><p>1、泛型的本质是为了参数化类型，也就是在在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型，很明显这种方法提高了代码的复用性。</p><p>2、泛型的引入提高了安全性，泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。。</p><p>3、在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p><p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlmapperGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 不指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noSpecifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">    String test = (String) glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specifyType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = <span class="keyword">new</span> GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 不需要强制类型转换</span></span><br><span class="line">    String test = glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么提高了安全性？"><a href="#为什么提高了安全性？" class="headerlink" title="为什么提高了安全性？"></a>为什么提高了安全性？</h2><p>再举例子说明一下</p><p><strong>不安全举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 16:09</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Safe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            String s = (String) arrayList.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaa</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">at keyAndDifficultPoints.Generic.Test_Safe.test(Test_Safe.java:25)</span><br><span class="line">at keyAndDifficultPoints.Generic.Test_Safe.main(Test_Safe.java:16)</span><br></pre></td></tr></table></figure><p>很明显的一个类型转换错误。ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p><strong>泛型提高安全性</strong></p><p>将上面的代码稍微改一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">       <span class="comment">//下面代码编译时就直接报错了</span></span><br><span class="line">       arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">           String s = (String) arrayList.get(i);</span><br><span class="line">           System.out.println(s);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过泛型来提前检测类型，编译时就通不过。</p><h2 id="泛型为什么很重要"><a href="#泛型为什么很重要" class="headerlink" title="泛型为什么很重要"></a>泛型为什么很重要</h2><p>我们看一下比较常用的JUC包</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniComposeStage(asyncPool, fn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span></span></span><br><span class="line"><span class="function"><span class="params">        Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这些都大量的用到了泛型，如果不把泛型学好，想真正深入源码了解一些东西，可能就完全看不懂了。</p><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p><strong>最普通的泛型类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 16:38</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_GenericClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、泛型的类型参数只能是类类型（包括自定义类），不能是简单数据类型（比如int,long这些）</span></span><br><span class="line"><span class="comment">         * 2、传入的实参类型需与泛型的类型参数类型相同，即为这里的Integer。</span></span><br><span class="line"><span class="comment">         * 3、new 后面的泛型参数可以省略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Generic&lt;Integer&gt; genericInteger1 = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">        Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">&quot;my&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(genericInteger.getVar());</span><br><span class="line">        System.out.println(genericString.getVar());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、此处T虽然可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> * 但是为了代码的可读性一般来说：</span></span><br><span class="line"><span class="comment"> * K,V用来表示键值对</span></span><br><span class="line"><span class="comment"> * E是Element的缩写，常用来遍历时表示</span></span><br><span class="line"><span class="comment"> * T就是Type的缩写，常用在普通泛型类上</span></span><br><span class="line"><span class="comment"> * 2、还有一些不常见的U,R啥的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T <span class="keyword">var</span>)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;       <span class="comment">// 此处指定了两个泛型类型</span></span><br><span class="line">    <span class="keyword">private</span> K key;     <span class="comment">// 此变量的类型由外部决定</span></span><br><span class="line">    <span class="keyword">private</span> V value;   <span class="comment">// 此变量的类型由外部决定</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">my</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><ul><li>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</li></ul><p>还是以上面的泛型类为例进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Generic generic = <span class="keyword">new</span> Generic(<span class="string">&quot;我是字符串&quot;</span>);</span><br><span class="line">       Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">123</span>);</span><br><span class="line">       Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">123.123</span>);</span><br><span class="line">       Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(generic.getVar());</span><br><span class="line">       System.out.println(generic1.getVar());</span><br><span class="line">       System.out.println(generic2.getVar());</span><br><span class="line">       System.out.println(generic3.getVar());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是字符串</span><br><span class="line">123</span><br><span class="line">123.123</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>没有报错，正确输出了。</p><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义方法，方法的返回值就是泛型类型  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>当实现泛型接口的类，未传入泛型实参时：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class InfoImpl&lt;T&gt; implements Info&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class InfoImpl implements Info&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt; </span>&#123;   <span class="comment">// 定义泛型接口的子类</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个是先烈实现这个接口,虽然我们只创建了一个泛型接口Info&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：InfoImpl01&lt;T&gt;，public String getVar();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl01</span> <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">String</span>&gt; </span>&#123;   <span class="comment">// 定义泛型接口的子类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl01</span><span class="params">(String <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(String <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>在java中，泛型类和接口的定义非常简单，但是泛型方法就比较复杂了。</p><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。</p><p><strong>最简单的一个泛型方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_GenericMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_GenericMethod test_genericMethod = <span class="keyword">new</span> Test_GenericMethod();</span><br><span class="line">        Integer integer = test_genericMethod.genericMethod(<span class="number">12</span>);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1、public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">     * 2、只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">     * 3、&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">     * 4、&lt;T&gt; 后面的这个T，代表这个方法的返回值类型</span></span><br><span class="line"><span class="comment">     * 4、与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本用法（非泛型类中的泛型方法）"><a href="#基本用法（非泛型类中的泛型方法）" class="headerlink" title="基本用法（非泛型类中的泛型方法）"></a>基本用法（非泛型类中的泛型方法）</h2><p>下面来细说一下泛型方法</p><p>首先说一个误区</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic01</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic01</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、这个虽然在方法中使用了泛型，但这并不是一个泛型方法。这只是类中一个普通的</span></span><br><span class="line"><span class="comment">     * 成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。所以在这个方法中才</span></span><br><span class="line"><span class="comment">     * 可以继续使用 T 这个泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</span></span><br><span class="line"><span class="comment">     * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    public E setKey(E key) &#123;</span></span><br><span class="line"><span class="comment">//        this.key = key;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本用法</strong>（非）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 17:46</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_GenericMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_GenericMethod test_genericMethod = <span class="keyword">new</span> Test_GenericMethod();</span><br><span class="line">        Generic01&lt;Integer&gt; generic01 = <span class="keyword">new</span> Generic01&lt;&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        Generic01&lt;String&gt; generic02 = <span class="keyword">new</span> Generic01&lt;&gt;(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line"></span><br><span class="line">        test_genericMethod.genericMethod_test01(generic01);</span><br><span class="line">        test_genericMethod.genericMethod_test02(generic02, <span class="string">&quot;我是T&quot;</span>);</span><br><span class="line"></span><br><span class="line">        test_genericMethod.Method01(generic01);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1、public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">     * 2、只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">     * 3、&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">     * 4、&lt;T&gt; 后面的这个T，代表这个方法的返回值类型</span></span><br><span class="line"><span class="comment">     * 4、与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 2、首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T。</span></span><br><span class="line"><span class="comment">     * 3、这个T可以出现在这个泛型方法的任意位置.泛型的数量也可以为任意多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod_test01</span><span class="params">(Generic01&lt;T&gt; generic01)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是genericMethod_test01：&quot;</span> + generic01.getKey());</span><br><span class="line">        T test = generic01.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T, V&gt; <span class="function">T <span class="title">genericMethod_test02</span><span class="params">(Generic01&lt;T&gt; generic01, V value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是genericMethod_test02：&quot;</span> + generic01.getKey() + <span class="string">&quot;==&gt; value：&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        T test = generic01.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method01</span><span class="params">(Generic01&lt;? extends Number&gt; generic01)</span> </span>&#123;</span><br><span class="line">        System.out.println(generic01.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method02</span><span class="params">(Generic01&lt;?&gt; generic01)</span> </span>&#123;</span><br><span class="line">        System.out.println(generic01.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot;</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    public &lt;T&gt; T showKeyName(Generic01&lt;E&gt; generic01, T t) &#123;</span></span><br><span class="line"><span class="comment">//        return t;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是genericMethod_test01：123</span><br><span class="line">我是genericMethod_test02：AAAAA&#x3D;&#x3D;&gt; value：我是T</span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h2><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 20:14</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_GenericMethod01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line"><span class="comment">     * 2、由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别</span></span><br><span class="line"><span class="comment">     泛型方法中识别的泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T</span></span><br><span class="line"><span class="comment">     * 不是同一种类型。也就是说main函数中使用的时候也可以是不一样的泛型类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apple</span><br><span class="line">apple</span><br><span class="line">Person</span><br><span class="line">apple</span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h2><p>再看一个泛型方法和可变参数的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_GenericMethod02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;123&quot;</span>,<span class="number">753</span>,<span class="number">123.12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是三个点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : args) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">753</span><br><span class="line">123.12</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h2><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span></span><br><span class="line"><span class="comment">     * 2、泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，</span></span><br><span class="line"><span class="comment">     * 泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line"><span class="comment">     * 3、泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在初始化类时确定,所以无所谓</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="细枝末节"><a href="#细枝末节" class="headerlink" title="细枝末节"></a>细枝末节</h2><blockquote><p>可能合上面的有一些重复</p></blockquote><p>1、泛型异常类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;异常类不能声明为泛型类，编译报错</span><br><span class="line">class MyException&lt;T&gt; extends Exception&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic.Minutiae;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 22:28</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Minutiae1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的内部结构就可以使用类的泛型</span></span><br><span class="line"></span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        T[] arr = new T[10];</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        T[] arr = (T[]) <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName,<span class="keyword">int</span> orderId,T orderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如下的三个方法都不是泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch(T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，</span></span><br><span class="line"><span class="comment">     * 泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line"><span class="comment">     * 3、泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在初始化类时确定,</span></span><br><span class="line"><span class="comment">     * 所以无所谓</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubOrder</span> <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;<span class="comment">//SubOrder:不是泛型类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubOrder1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="comment">//SubOrder1&lt;T&gt;:仍然是泛型类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 12:10</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 测试泛型数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_GenericArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译错误</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这样声明是正确的</span></span><br><span class="line">        List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br><span class="line">        ls[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样写编译就报错了</span></span><br><span class="line"><span class="comment">//        ls[1].add(1);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是sun官方文档里写的。其实不用太纠结，平时泛型虽然用的多，但也不会用的这么奇葩。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.</span></span><br><span class="line">        Object o = lsa;</span><br><span class="line">        Object[] oa = (Object[]) o;</span><br><span class="line">        List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">        oa[<span class="number">1</span>] = li; <span class="comment">// Correct.</span></span><br><span class="line">        Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">        ls[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ls[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        ls[<span class="number">0</span>].add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">sun文档</a></p><h1 id="泛型在继承方面的细节"><a href="#泛型在继承方面的细节" class="headerlink" title="泛型在继承方面的细节"></a>泛型在继承方面的细节</h1><p>直接看代码注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 泛型在继承方面的体现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面是有继承关系，所以可以赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        obj = str;</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">null</span>;</span><br><span class="line">        String[] arr2 = <span class="keyword">null</span>;</span><br><span class="line">        arr1 = arr2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面属于并列关系，无继承关系。无法赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        Date date = new Date();</span></span><br><span class="line"><span class="comment">//        str = date;</span></span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//此时的list1和list2的类型不具有子父类关系</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1 = list2;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非String的数据。出错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AbstractList&lt;String&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list2 = list3;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V，？ 等等，下面来详细讲一下这些通配符。</p><h2 id="常用的通配符"><a href="#常用的通配符" class="headerlink" title="常用的通配符"></a>常用的通配符</h2><p>本质上都是通配符没啥区别，只不过是编码时的一种约定俗成的东西（可以说提高了代码可读性）。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个大小写字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？ 是这样约定的：</p><ul><li>  ？ 表示不确定的 java 类型</li><li>  T (Type) 表示具体的一个java类型</li><li>  K V (Key Value) 分别代表java键值中的Key Value</li><li>  E (element) 代表Element</li></ul><p>比较难的就是<code>？</code>通配符，下面就着重讲一下</p><h2 id="‘-‘无界通配符"><a href="#‘-‘无界通配符" class="headerlink" title="‘ ? ‘无界通配符"></a>‘ ? ‘无界通配符</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>但是如果用通配符的话：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/15 21:25</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 泛型通配符测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Wildcard_Character</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test(dogList);</span><br><span class="line">        test1(dogList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            System.out.print(animal.toString() + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(List&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            System.out.print(animal.toString() + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test1()</code>在编译时就会飘红</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Generic/0001.png"><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 <code>test()</code>方法中，限定了上界，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错，而<code>test1()</code>就不行。</p><h3 id="‘-‘通配符的继承"><a href="#‘-‘通配符的继承" class="headerlink" title="‘ ? ‘通配符的继承"></a>‘ ? ‘通配符的继承</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    2. 通配符的使用</span></span><br><span class="line"><span class="comment">       通配符：?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类是：G&lt;?&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//        print(list1);</span></span><br><span class="line"><span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        list = list3;</span><br><span class="line">        <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">        <span class="comment">//除了添加null之外。</span></span><br><span class="line"><span class="comment">//        list.add(&quot;DD&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">        Object o = list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="extends和super上下界"><a href="#extends和super上下界" class="headerlink" title="extends和super上下界"></a>extends和super上下界</h2><h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote><p>上结：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p></blockquote><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li></ul><h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote><p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p></blockquote><p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    3.有限制条件的通配符的使用。</span></span><br><span class="line"><span class="comment">        ? extends A:</span></span><br><span class="line"><span class="comment">                G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ? super A:</span></span><br><span class="line"><span class="comment">                G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>; <span class="comment">//[-无穷,Person]</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;  <span class="comment">//[Person,+无穷]</span></span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        List&lt;Object&gt; list5 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list1 = list4;</span><br><span class="line"><span class="comment">//        list1 = list5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        list2 = list3;</span></span><br><span class="line">        list2 = list4;</span><br><span class="line">        list2 = list5;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面的东西很奇怪</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据：</span></span><br><span class="line">        list1 = list3;</span><br><span class="line">        Person p = list1.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">        list2 = list4;</span><br><span class="line">        Object obj = list2.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">////编译不通过</span></span><br><span class="line"><span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据：</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        list2.add(<span class="keyword">new</span> Person());</span><br><span class="line">        list2.add(<span class="keyword">new</span> Student());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##？ 和 T 的区别</p><p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure><p>简单总结下：</p><p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p><h3 id="区别1：通过T来确保泛型参数的一致性"><a href="#区别1：通过T来确保泛型参数的一致性" class="headerlink" title="区别1：通过T来确保泛型参数的一致性"></a>区别1：通过T来确保泛型参数的一致性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Wildcard_Character;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/16 11:28</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_difference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译报错</span></span><br><span class="line"><span class="comment">//        test(integerList, floatList);</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        test1(integerList, floatList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        test(integerList, integerList);</span><br><span class="line">        test1(integerList, integerList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; dest, List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别2：T可以通过-amp-进行多重限定"><a href="#区别2：T可以通过-amp-进行多重限定" class="headerlink" title="区别2：T可以通过&amp;进行多重限定"></a>区别2：T可以通过&amp;进行多重限定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_difference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*---------------------测试多重限定符---------------------*/</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayDeque deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Object&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多重限定时，在编译的时候取最小范围或共同子类</span></span><br><span class="line"></span><br><span class="line">        test2(list);</span><br><span class="line"><span class="comment">//        test3(list); 编译报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译报错</span></span><br><span class="line"><span class="comment">//        test2(deque);</span></span><br><span class="line"><span class="comment">//        test3(deque);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        test2(linkedList);</span><br><span class="line">        test3(linkedList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以进行多重限定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends List &amp; Collection&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以进行多重限定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Queue &amp; List&gt; <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译报错，无法进行多重限定</span></span><br><span class="line"><span class="comment">//    public static &lt;? extends List &amp; Collection&gt; void test4(List&lt;T&gt; dest, List&lt;T&gt; src)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Generic/0002.png"><h3 id="区别3：？通配符可以使用超类限定而T不行"><a href="#区别3：？通配符可以使用超类限定而T不行" class="headerlink" title="区别3：？通配符可以使用超类限定而T不行"></a>区别3：？通配符可以使用超类限定而T不行</h3><p>类型参数 T 只具有 一种 类型限定方式：</p><pre><code>T extends A</code></pre><p>但是通配符 ? 可以进行 两种限定：</p><pre><code>? extends A? super A</code></pre><hr><h1 id="关于反射和泛型的一点东西"><a href="#关于反射和泛型的一点东西" class="headerlink" title="关于反射和泛型的一点东西"></a>关于反射和泛型的一点东西</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.Wildcard_Character;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/16 12:09</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 泛型反射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Reflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        A a = createInstance(A.class);</span><br><span class="line">        B b = createInstance(B.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这样写明显是要安全很多的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getA</span><span class="params">(String path)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        A a = (A) Class.forName(<span class="string">&quot;keyAndDifficultPoints.Wildcard_Character.A&quot;</span>).newInstance();</span><br><span class="line">        <span class="comment">//很明显下面的这行代码是错的，但是写代码的时候你不知道path是哪个</span></span><br><span class="line"><span class="comment">//        B b = (B)Class.forName(&quot;keyAndDifficultPoints.Wildcard_Character.A&quot;).newInstance();</span></span><br><span class="line">        System.out.println(a.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是对象A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是对象B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所以当不知道声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为T没有声明，所以编译报错</span></span><br><span class="line"><span class="comment">//    public Class&lt;T&gt; clazz2;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; clazzT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="泛型原理（泛型擦除）"><a href="#泛型原理（泛型擦除）" class="headerlink" title="泛型原理（泛型擦除）"></a>泛型原理（泛型擦除）</h1><h2 id="类型擦除简介"><a href="#类型擦除简介" class="headerlink" title="类型擦除简介"></a>类型擦除简介</h2><p>​    Java的泛型是伪泛型，为什么说Java的泛型是伪泛型呢？因为在编译期间，所有的泛型信息都会被擦除掉，我们常称为<strong>泛型擦除</strong>。</p><p>​    Java中的泛型基本上都是在编译器这个层次来实现的，在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，编译器在编译的时候去掉，这个过程就称为类型擦除。</p><p>​    如在代码中定义的<code>List&lt;object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会编程List，JVM看到的只是List。而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方法与C++模版机制实现方式之间的重要区别。</p><p>可以通过两个例子，来证明java泛型的类型擦除。</p><p><strong>例1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     stringList.add(<span class="string">&quot;my&quot;</span>);</span><br><span class="line">     List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">     integerList.add(<span class="number">123</span>);</span><br><span class="line">     System.out.println(stringList.getClass() == integerList.getClass());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个List，不过一个是List<String>泛型类型，只能存储字符串。一个是List<Integer>泛型类型，只能存储整形。最后，我们通过stringList对象和integerList对象的getClass方法获取它们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下了原始类型。</p><p><strong>例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//这样调用add方法只能存储整形，因为泛型类型的实例为Integer</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这样写编译就会报错</span></span><br><span class="line"><span class="comment">//        list.add(&quot;my&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射的方式则可以存储String</span></span><br><span class="line">        list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;my&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">my</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>在程序中定义了一个List<Integer>泛型类型，如果直接调用add方法，那么只能存储整形的数据。不过当我们利用反射调用add方法的时候，却可以存储字符串。这说明了Integer泛型实例在编译之后被擦除了，只保留了 原始类型。</p><h2 id="类型擦除后保留的原始类型"><a href="#类型擦除后保留的原始类型" class="headerlink" title="类型擦除后保留的原始类型"></a>类型擦除后保留的原始类型</h2><p>1、在上面，几次提到了<strong>原始类型</strong>。什么是原始类型？原始类型就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除，并使用其限定类型（无限定的变量用Object替换）。</p><p>例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.principle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/16 23:01</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_principle02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们用IDEA的工具，查看这个类的字节码信息。我把完整的字节码复制在下方：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x20</span></span><br><span class="line"><span class="comment">// signature &lt;T:Ljava/lang/Object;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: keyAndDifficultPoints/principle/Test_Generic&lt;T&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">keyAndDifficultPoints</span>/<span class="title">principle</span>/<span class="title">Test_Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: Test_principle02.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TT;</span></span><br><span class="line">  <span class="comment">// declaration: T</span></span><br><span class="line">  <span class="keyword">private</span> Ljava/lang/Object; value</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x0</span></span><br><span class="line">  &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">13</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/Test_Generic; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LkeyAndDifficultPoints/principle/Test_Generic&lt;TT;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: keyAndDifficultPoints.principle.Test_Generic&lt;T&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature ()TT;</span></span><br><span class="line">  <span class="comment">// declaration: T getValue()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getValue</span><span class="params">()</span>Ljava/lang/Object</span>;</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">17</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    GETFIELD keyAndDifficultPoints/principle/Test_Generic.value : Ljava/lang/Object;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/Test_Generic; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LkeyAndDifficultPoints/principle/Test_Generic&lt;TT;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: keyAndDifficultPoints.principle.Test_Generic&lt;T&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="comment">// signature (TT;)V</span></span><br><span class="line">  <span class="comment">// declaration: void setValue(T)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setValue</span><span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 21 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    PUTFIELD keyAndDifficultPoints/principle/Test_Generic.value : Ljava/lang/Object</span>;</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER <span class="number">22</span> L1</span><br><span class="line">    RETURN</span><br><span class="line">   L2</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/Test_Generic; L0 L2 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature LkeyAndDifficultPoints/principle/Test_Generic&lt;TT;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: keyAndDifficultPoints.principle.Test_Generic&lt;T&gt;</span></span><br><span class="line">    LOCALVARIABLE value Ljava/lang/Object; L0 L2 <span class="number">1</span></span><br><span class="line">    <span class="comment">// signature TT;</span></span><br><span class="line">    <span class="comment">// declaration: T</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以明显的看到<strong>泛型T</strong>被替换成了<strong>Object</strong>。</p><p>​    因为在Test_Generic<T>中，T是一个无限定的类型变量，所以用Object替换。其结果就是一个普通的类，如同泛型加入java变成语言之前已经实现的那样。在程序中可以包含不同类型的Test_Generic，如Test_Generic<String>或Test_Generic<Integer>，但是，擦除类型后它们就成为原始的Test_Generic类型了，原始类型都是Object。</p><p>​    从上面的那个例2中，我们也可以明白List<Integer>被擦除类型后，原始类型也变成了Object，所以通过反射我们就可以存储字符串了。</p><p>2、如果类型变量有限定，那么原始类型就用第一个边界的类型变量来替换。</p><p>比如Test_Generic这样声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_Generic1</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">List</span> &amp; <span class="title">Collection</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们还是看字节码（后面如无必须，只截取部分字节码）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x20</span></span><br><span class="line"><span class="comment">// signature &lt;T::Ljava/util/List;:Ljava/util/Collection;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: keyAndDifficultPoints/principle/Test_Generic1&lt;T extends java.util.List, java.util.Collection&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">keyAndDifficultPoints</span>/<span class="title">principle</span>/<span class="title">Test_Generic1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: Test_principle03.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TT;</span></span><br><span class="line">  <span class="comment">// declaration: T</span></span><br><span class="line">  <span class="keyword">private</span> Ljava/util/List; value</span><br></pre></td></tr></table></figure><p>会发现T变成了List </p><p>如果顺序变一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_Generic1</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Collection</span> &amp; <span class="title">List</span>&gt;</span></span><br></pre></td></tr></table></figure><p>字节码就变了</p><p>T变成了Collection</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x20</span></span><br><span class="line"><span class="comment">// signature &lt;T::Ljava/util/Collection;:Ljava/util/List;&gt;Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">// declaration: keyAndDifficultPoints/principle/Test_Generic1&lt;T extends java.util.Collection, java.util.List&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">keyAndDifficultPoints</span>/<span class="title">principle</span>/<span class="title">Test_Generic1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: Test_principle03.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x2</span></span><br><span class="line">  <span class="comment">// signature TT;</span></span><br><span class="line">  <span class="comment">// declaration: T</span></span><br><span class="line">  <span class="keyword">private</span> Ljava/util/Collection; value</span><br></pre></td></tr></table></figure><p>也就是说在进行字节码编译的时候是使用离T最近的一个类型。</p><h3 id="解答一个疑惑"><a href="#解答一个疑惑" class="headerlink" title="解答一个疑惑"></a>解答一个疑惑</h3><p>在上文说到&amp;的多重限定时</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyAndDifficultPoints.principle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/16 23:30</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_principle04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*---------------------测试多重限定符---------------------*/</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Object&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//多重限定时，在编译的时候取最小范围或共同子类</span></span><br><span class="line">        test2(list);</span><br><span class="line"><span class="comment">//        test3(list); 编译报错</span></span><br><span class="line">        test4(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译报错</span></span><br><span class="line"><span class="comment">//        test2(deque);</span></span><br><span class="line"><span class="comment">//        test3(deque);</span></span><br><span class="line"><span class="comment">//        test4(queue);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        test2(linkedList);</span><br><span class="line">        test3(linkedList);</span><br><span class="line">        test4(linkedList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以进行多重限定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends List &amp; Collection&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以进行多重限定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Queue &amp; List&gt; <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以进行多重限定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Collection &amp; List&gt; <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译报错，无法进行多重限定</span></span><br><span class="line"><span class="comment">//    public static &lt;? extends List &amp; Collection&gt; void test4(List&lt;T&gt; dest, List&lt;T&gt; src)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先来看一下字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keyAndDifficultPoints</span>/<span class="title">principle</span>/<span class="title">Test_principle04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: Test_principle04.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">11</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/Test_principle04; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 17 L0</span></span><br><span class="line"><span class="function">    NEW java/util/ArrayList</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/util/ArrayList.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 18 L1</span></span><br><span class="line"><span class="function">    NEW java/util/ArrayDeque</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/util/ArrayDeque.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 2</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">    LINENUMBER 19 L2</span></span><br><span class="line"><span class="function">    NEW java/util/LinkedList</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/util/LinkedList.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 3</span></span><br><span class="line"><span class="function">   L3</span></span><br><span class="line"><span class="function">    LINENUMBER 22 L3</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    INVOKESTATIC keyAndDifficultPoints/principle/Test_principle04.<span class="title">test2</span> <span class="params">(Ljava/util/List;)</span>V</span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 24 L4</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    INVOKESTATIC keyAndDifficultPoints/principle/Test_principle04.<span class="title">test4</span> <span class="params">(Ljava/util/Collection;)</span>V</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 33 L5</span></span><br><span class="line"><span class="function">    ALOAD 3</span></span><br><span class="line"><span class="function">    INVOKESTATIC keyAndDifficultPoints/principle/Test_principle04.<span class="title">test2</span> <span class="params">(Ljava/util/List;)</span>V</span></span><br><span class="line"><span class="function">   L6</span></span><br><span class="line"><span class="function">    LINENUMBER 34 L6</span></span><br><span class="line"><span class="function">    ALOAD 3</span></span><br><span class="line"><span class="function">    INVOKESTATIC keyAndDifficultPoints/principle/Test_principle04.<span class="title">test3</span> <span class="params">(Ljava/util/Queue;)</span>V</span></span><br><span class="line"><span class="function">   L7</span></span><br><span class="line"><span class="function">    LINENUMBER 35 L7</span></span><br><span class="line"><span class="function">    ALOAD 3</span></span><br><span class="line"><span class="function">    INVOKESTATIC keyAndDifficultPoints/principle/Test_principle04.<span class="title">test4</span> <span class="params">(Ljava/util/Collection;)</span>V</span></span><br><span class="line"><span class="function">   L8</span></span><br><span class="line"><span class="function">    LINENUMBER 38 L8</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L9</span></span><br><span class="line"><span class="function">    LOCALVARIABLE args [Ljava/lang/String</span>; L0 L9 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE list Ljava/util/List; L1 L9 <span class="number">1</span></span><br><span class="line">    LOCALVARIABLE queue Ljava/util/Queue; L2 L9 <span class="number">2</span></span><br><span class="line">    LOCALVARIABLE linkedList Ljava/util/LinkedList; L3 L9 <span class="number">3</span></span><br><span class="line">    <span class="comment">// signature Ljava/util/LinkedList&lt;Ljava/lang/Object;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: java.util.LinkedList&lt;java.lang.Object&gt;</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="comment">// signature &lt;T::Ljava/util/List;:Ljava/util/Collection;&gt;(TT;)V</span></span><br><span class="line">  <span class="comment">// declaration: void test2&lt;T extends java.util.List, java.util.Collection&gt;(T)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">test2</span><span class="params">(Ljava/util/List;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 44 L0</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LOCALVARIABLE t Ljava/util/List</span>; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature TT;</span></span><br><span class="line">    <span class="comment">// declaration: T</span></span><br><span class="line">    MAXSTACK = <span class="number">0</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="comment">// signature &lt;T::Ljava/util/Queue;:Ljava/util/List;&gt;(TT;)V</span></span><br><span class="line">  <span class="comment">// declaration: void test3&lt;T extends java.util.Queue, java.util.List&gt;(T)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">test3</span><span class="params">(Ljava/util/Queue;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 49 L0</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LOCALVARIABLE t Ljava/util/Queue</span>; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature TT;</span></span><br><span class="line">    <span class="comment">// declaration: T</span></span><br><span class="line">    MAXSTACK = <span class="number">0</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="comment">// signature &lt;T::Ljava/util/Collection;:Ljava/util/List;&gt;(TT;)V</span></span><br><span class="line">  <span class="comment">// declaration: void test4&lt;T extends java.util.Collection, java.util.List&gt;(T)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">test4</span><span class="params">(Ljava/util/Collection;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 54 L0</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LOCALVARIABLE t Ljava/util/Collection</span>; L0 L1 <span class="number">0</span></span><br><span class="line">    <span class="comment">// signature TT;</span></span><br><span class="line">    <span class="comment">// declaration: T</span></span><br><span class="line">    MAXSTACK = <span class="number">0</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>test4()</code>方法里离T最近的是<code>Collection</code>，那么T在编译后就被<code>Collection</code>代替了。那按理来说</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test4(queue);</span><br></pre></td></tr></table></figure><p>1、这里我们传一个Collection的实现类Queue，也应该是可以的啊，但是为什么报错了呢？注意一点报错报的是编译错误，泛型提供编译前检测机制，也就是说在没运行前，泛型规定了<code>多重限定时，在编译的时候取最小范围或共同子类</code>。</p><p>2、那实际上到底可以不可以传Queue呢？根据之前的讲解，我相信大家已经有了结论。实际上是可以的，只不过要跳过编译检测机制，通过反射来放Queue。</p><h3 id="泛型方法调用"><a href="#泛型方法调用" class="headerlink" title="泛型方法调用"></a>泛型方法调用</h3><p>​    在调用泛型方法的时候，可以指定泛型，也可以不指定泛型。在不指定泛型的情况下，泛型变量的类型为 该方法中的几种类型的同一个父类的最小级，直到Object。在指定泛型的时候，该方法中的几种类型必须是该泛型实例类型或者其子类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不指定泛型的时候</span></span><br><span class="line">        <span class="keyword">int</span> a1 = add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型</span></span><br><span class="line">        Number b1 = add(<span class="number">1</span>, <span class="number">1.2</span>);<span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number</span></span><br><span class="line">        Object c1 = add(<span class="number">1</span>, <span class="string">&quot;my&quot;</span>);<span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定泛型的时候</span></span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//指定了Integer，所以只能为Integer类型或者其子类</span></span><br><span class="line"><span class="comment">//        int b = Test.&lt;Integer&gt;add(1, 2.2);//编译错误，指定了Integer，不能为Float</span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型擦除引起的问题及解决方法"><a href="#类型擦除引起的问题及解决方法" class="headerlink" title="类型擦除引起的问题及解决方法"></a>类型擦除引起的问题及解决方法</h2><h3 id="类型检测针对谁？"><a href="#类型检测针对谁？" class="headerlink" title="类型检测针对谁？"></a>类型检测针对谁？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">123</span>);<span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除后，原始类型为Object，是应该运行任意引用类型的添加的。可实际上却不是这样，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p><p>那么，这么类型检查是针对谁的呢？我们来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList.add(<span class="number">1</span>); <span class="comment">//编译报错</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList(); <span class="comment">//第一种 情况</span></span><br><span class="line">        arrayList1.add(<span class="number">1</span>); <span class="comment">//编译报错</span></span><br><span class="line"></span><br><span class="line">        ArrayList arrayList2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//第二种 情况</span></span><br><span class="line">        arrayList2.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p><p>我么来看一下List的get()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到基本各个类都已经自动帮你转了。</p><h3 id="类型擦除与多态的冲突和解决方法"><a href="#类型擦除与多态的冲突和解决方法" class="headerlink" title="类型擦除与多态的冲突和解决方法"></a>类型擦除与多态的冲突和解决方法</h3><p>这个其实是类型擦除引起的最大的问题了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_principle05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getVar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(Integer <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，从他们的@Override标签中也可以看到，在子类中重写这两个方法一点问题也没有，实际上是这样的吗？</p><p><strong>分析：</strong></p><p>泛型擦除后，父类是下面这样子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(Object <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类还是这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getVar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(Integer <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。</p><blockquote><p><strong>重载（Overload）:首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。</strong></p><p>（1）：方法名必须相同。</p><p>（2）：方法的参数列表一定不一样。</p><p>（3）：访问修饰符和返回值类型可以相同也可以不同。</p><p><strong>重写（override）：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。</strong></p><p><strong>重写的特征：</strong></p><p>（1）：方法名必须相同，返回值类型必须相同</p><p>（2）：参数列表必须相同</p><p>（3）：访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</p><p>（4）：子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</p><p>（5）：构造方法不能被重写</p></blockquote><p>我们来测试下到底是重载还是重写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyGeneric myGeneric = <span class="keyword">new</span> MyGeneric();</span><br><span class="line">       myGeneric.setVar(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">       myGeneric.setVar(<span class="keyword">new</span> Object());<span class="comment">//编译错误</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果是重载的话，第四行代码是不会报错的，因为调的是不同的重载方法。但是发现编译报错了，也就是说没有参数是Object的这样的重载函数。所以说是重写了，导致MyGeneric对象只能调用自己重写的方法。</p><p>为什么会这样呢？</p><p>原因是这样的，我们传入父类的泛型类型是Integer，Generic<Integer>，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(Integer <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p><p>​    可是由于种种原因，虚拟机并不能将泛型类型变为Integer，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道，可是它能直接实现吗，不能。如果真的不能的话，那我们怎么去重写我们想要的Integer类型参数的方法啊。</p><p>JVM采用了一个特殊的方法，来完成这项功能，那就是<strong>桥方法</strong>。</p><p>我们对下面这个类进行编译，看其字节码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGeneric</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getVar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(Integer <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="comment">// signature LkeyAndDifficultPoints/principle/Generic&lt;Ljava/lang/Integer;&gt;;</span></span><br><span class="line"><span class="comment">// declaration: keyAndDifficultPoints/principle/MyGeneric extends keyAndDifficultPoints.principle.Generic&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keyAndDifficultPoints</span>/<span class="title">principle</span>/<span class="title">MyGeneric</span> <span class="keyword">extends</span> <span class="title">keyAndDifficultPoints</span>/<span class="title">principle</span>/<span class="title">Generic</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: MyGeneric.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">9</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL keyAndDifficultPoints/principle/Generic.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/MyGeneric; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 12 L0</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LOCALVARIABLE args [Ljava/lang/String</span>; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">0</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getVar</span><span class="params">()</span>Ljava/lang/Integer</span>;  <span class="comment">//这是我们重写的getVar()方法</span></span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">16</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL keyAndDifficultPoints/principle/Generic.getVar ()Ljava/lang/Object;</span><br><span class="line">    CHECKCAST java/lang/Integer</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/MyGeneric; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setVar</span><span class="params">(Ljava/lang/Integer;)</span>V  <span class="comment">////这是我们重写的setVar()方法</span></span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 20 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    INVOKESPECIAL keyAndDifficultPoints/principle/Generic.<span class="title">setVar</span> <span class="params">(Ljava/lang/Object;)</span>V</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 21 L1</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/MyGeneric</span>; L0 L2 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE <span class="keyword">var</span> Ljava/lang/Integer; L0 L2 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1041</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synthetic bridge <span class="title">setVar</span><span class="params">(Ljava/lang/Object;)</span>V  <span class="comment">//编译时由编译器生成的桥方法</span></span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 9 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    CHECKCAST java/lang/Integer</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL keyAndDifficultPoints/principle/MyGeneric.<span class="title">setVar</span> <span class="params">(Ljava/lang/Integer;)</span>V</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/MyGeneric</span>; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1041</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> synthetic bridge <span class="title">getVar</span><span class="params">()</span>Ljava/lang/Object</span>;  <span class="comment">//编译时由编译器生成的桥方法</span></span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">9</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKEVIRTUAL keyAndDifficultPoints/principle/MyGeneric.getVar ()Ljava/lang/Integer;</span><br><span class="line">    ARETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LkeyAndDifficultPoints/principle/MyGeneric; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法。最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p><p>所以，虚拟机巧妙的使用了巧方法，来解决了类型擦除和多态的冲突。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 重难点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JDK8新特性</title>
      <link href="post/de3879ae.html"/>
      <url>post/de3879ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java8新特性纵览"><a href="#Java8新特性纵览" class="headerlink" title="Java8新特性纵览"></a>Java8新特性纵览</h1><blockquote><p>本篇文章只讲解比较重要的</p></blockquote><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Java8_New_Features/0001.png"><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="为什么使用Lambda表达式？"><a href="#为什么使用Lambda表达式？" class="headerlink" title="为什么使用Lambda表达式？"></a>为什么使用Lambda表达式？</h2><ul><li>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</li><li>在Java8之后的很多源码里用到了Lambda表达式，不学的话可能看不懂源码。</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//原始写法</span></span><br><span class="line">       Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       r1.run();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//lambda表达式，可以表达一样的意思</span></span><br><span class="line">       Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;我爱北京故宫&quot;</span>);</span><br><span class="line"></span><br><span class="line">       r2.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> compare1 = com1.compare(<span class="number">12</span>,<span class="number">21</span>);</span><br><span class="line">       System.out.println(compare1);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//Lambda表达式的写法</span></span><br><span class="line">       Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> compare2 = com2.compare(<span class="number">32</span>,<span class="number">21</span>);</span><br><span class="line">       System.out.println(compare2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">       <span class="comment">//方法引用</span></span><br><span class="line">       Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> compare3 = com3.compare(<span class="number">32</span>,<span class="number">21</span>);</span><br><span class="line">       System.out.println(compare3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda语法规则"><a href="#Lambda语法规则" class="headerlink" title="Lambda语法规则"></a>Lambda语法规则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lambda表达式的使用</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class="line"><span class="comment"> * 2.格式：</span></span><br><span class="line"><span class="comment"> * -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class="line"><span class="comment"> * -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class="line"><span class="comment"> * -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 3. Lambda表达式的使用：（分为6种情况介绍）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也</span></span><br><span class="line"><span class="comment"> * 可以省略</span></span><br><span class="line"><span class="comment"> * -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一</span></span><br><span class="line"><span class="comment"> 对&#123;&#125;和return关键字</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 4.Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上</span></span><br><span class="line"><span class="comment"> 使用 <span class="doctag">@FunctionalInterface</span> 注解，</span></span><br><span class="line"><span class="comment"> * 这样做可以检查它是否是一个函数式接口。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable r2 = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京故宫&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                System.out.println(o1);</span><br><span class="line">                System.out.println(o2);</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line">        con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h2 id="什么是函数式-Functional-接口"><a href="#什么是函数式-Functional-接口" class="headerlink" title="什么是函数式(Functional)接口"></a>什么是函数式(Functional)接口</h2><ul><li><p>只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。 </p></li><li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>我们可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p></li><li><p>在java.util.function包下定义了Java 8 的丰富的函数式接口</p></li></ul><h2 id="如何理解函数式接口"><a href="#如何理解函数式接口" class="headerlink" title="如何理解函数式接口"></a>如何理解函数式接口</h2><ul><li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程） </li><li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 </li><li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li><li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li></ul><h2 id="Java内置函数式接口"><a href="#Java内置函数式接口" class="headerlink" title="Java内置函数式接口"></a>Java内置函数式接口</h2><p><strong>核心函数式接口</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Java8_New_Features/0002.png"><p><strong>其它函数式接口</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Java8_New_Features/0003.png"><p><strong>Consumer</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       happyTime(<span class="number">500</span>, <span class="keyword">new</span> Consumer&lt;Double&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;学习太累了，去天上人间买了瓶矿泉水，价格为：&quot;</span> + aDouble);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       happyTime(<span class="number">400</span>,money -&gt; System.out.println(<span class="string">&quot;学习太累了，去天上人间喝了口水，价格为：&quot;</span> + money));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyTime</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">       con.accept(money);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">学习太累了，去天上人间买了瓶矿泉水，价格为：<span class="number">500.0</span></span><br><span class="line">********************</span><br><span class="line">学习太累了，去天上人间喝了口水，价格为：<span class="number">400.0</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Predicate</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;南京&quot;</span>,<span class="string">&quot;天津&quot;</span>,<span class="string">&quot;东京&quot;</span>,<span class="string">&quot;西京&quot;</span>,<span class="string">&quot;普京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filterStrs = filterString(list, <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;<span class="comment">//这里是定义一个校验规则</span></span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(filterStrs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用lambda表达式会很简单</span></span><br><span class="line">        List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterStrs1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.test(s))&#123;</span><br><span class="line">                filterList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[北京, 南京, 东京, 西京, 普京]</span><br><span class="line">[北京, 南京, 东京, 西京, 普京]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义函数式接口</span></span><br><span class="line"><span class="comment"> * 只是说加上<span class="doctag">@FunctionalInterface</span>之后可以校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个方法的第一个参数是lambda表达式，相当于是实例化了那个函数式接口</span></span><br><span class="line">        String s = toUpperString(str -&gt; str.toUpperCase(), <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toUpperString</span><span class="params">(MyFunInterface&lt;String&gt; mf,String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mf.getValue(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><ul><li><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p></li><li><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p></li><li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</p></li><li><p>格式：使用操作符 “::” 将类(或对象) 与 方法名分隔开来。</p></li><li><p>如下三种主要使用情况： </p><ul><li><p>对象 :: 实例方法名</p></li><li><p>类 :: 静态方法名</p></li><li><p>类 :: 实例方法名</p></li></ul></li></ul><p>我们直接拿例子来说明情况，先提前准备两个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Employee().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">System.out.println(<span class="string">&quot;Employee(int id).....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Employee employee = (Employee) o;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id != employee.id)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (age != employee.age)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (Double.compare(employee.salary, salary) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(employee.name) : employee.name == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">long</span> temp;</span><br><span class="line">result = id;</span><br><span class="line">result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">result = <span class="number">31</span> * result + age;</span><br><span class="line">temp = Double.doubleToLongBits(salary);</span><br><span class="line">result = <span class="number">31</span> * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供用于测试的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeData</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title">getEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;马化腾&quot;</span>, <span class="number">34</span>, <span class="number">6000.38</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">&quot;马云&quot;</span>, <span class="number">12</span>, <span class="number">9876.12</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;刘强东&quot;</span>, <span class="number">33</span>, <span class="number">3000.82</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">&quot;雷军&quot;</span>, <span class="number">26</span>, <span class="number">7657.37</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">&quot;李彦宏&quot;</span>, <span class="number">65</span>, <span class="number">5555.32</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1006</span>, <span class="string">&quot;比尔盖茨&quot;</span>, <span class="number">42</span>, <span class="number">9500.43</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1007</span>, <span class="string">&quot;任正非&quot;</span>, <span class="number">26</span>, <span class="number">4333.32</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> Employee(<span class="number">1008</span>, <span class="string">&quot;扎克伯格&quot;</span>, <span class="number">35</span>, <span class="number">2500.32</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面来通过实际例子讲解方法引用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法引用的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</span></span><br><span class="line"><span class="comment"> *   方法引用，也是函数式接口的实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 使用格式：  类(或对象) :: 方法名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 具体分为如下的三种情况：</span></span><br><span class="line"><span class="comment"> *    情况1     对象 :: 非静态方法</span></span><br><span class="line"><span class="comment"> *    情况2     类 :: 静态方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    情况3     类 :: 非静态方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 方法引用使用的要求：</span></span><br><span class="line"><span class="comment"> * 接口中的抽象方法的形参列表和返回值类型</span></span><br><span class="line"><span class="comment"> * 与</span></span><br><span class="line"><span class="comment"> * 方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRefTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">con1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">PrintStream ps = System.out;</span><br><span class="line">Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Employee emp = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="number">5600</span>);</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Function&lt;Double,Long&gt; func = <span class="keyword">new</span> Function&lt;Double, Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Double d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.round(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)  第一个参数T t1,也可以变成方法的调用者</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)        看上面说的，t1变成了调用者等价于第一个参数T t1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;abm&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">// Employee中的String getName();   第一个参数T t相当于方法调用者emp，返回值R和String对应</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Employee employee = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">23</span>, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">System.out.println(func2.apply(employee));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h1><p>格式：ClassName :: new</p><p>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一、构造器引用</span></span><br><span class="line"><span class="comment"> *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span></span><br><span class="line"><span class="comment"> *      抽象方法的返回值类型即为构造器所属的类的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二、数组引用</span></span><br><span class="line"><span class="comment"> *     大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorRefTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器引用</span></span><br><span class="line"><span class="comment">     * Supplier中的T get()</span></span><br><span class="line"><span class="comment">     * Employee的空参构造器：Employee()</span></span><br><span class="line"><span class="comment">     * 1、和方法引用一样的理解方法，你的get()方法没有参数，我的Employee()也没有参数。</span></span><br><span class="line"><span class="comment">     * 2、你的get()方法有返回值T，我的Employee()方法返回值也是一个对象</span></span><br><span class="line"><span class="comment">     * 3、所以刚好可以用  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> Supplier&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Employee();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> Employee(id);</span><br><span class="line">        Employee employee = func1.apply(<span class="number">1001</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        Employee employee1 = func2.apply(<span class="number">1002</span>);</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> Employee(id,name);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组引用</span></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">        String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">        String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="强大的Stream-API"><a href="#强大的Stream-API" class="headerlink" title="强大的Stream API"></a>强大的Stream API</h1><h2 id="Stream-API说明"><a href="#Stream-API说明" class="headerlink" title="Stream API说明"></a>Stream API说明</h2><ul><li><p>Java8中有两大最为重要的改变。第一个是 <strong>Lambda</strong> <strong>表达式</strong>；另外一个则是 <strong>Stream API</strong>。 </p></li><li><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p></li><li><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</p></li></ul><h2 id="为什么要使用Stream-API"><a href="#为什么要使用Stream-API" class="headerlink" title="为什么要使用Stream API"></a>为什么要使用Stream API</h2><ul><li><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等，很多一些复杂的数据获取可以直接在sql层面去解决。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据本身不支持一些复杂的数据计算，这个时候就需要Java层面去处理。 </p></li><li><p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p></li></ul><h2 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h2><p>Stream到底是什么呢？</p><p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p><p><strong>“集合讲的是数据，Stream讲的是计算！”</strong></p><p><strong>注意：</strong></p><p>①Stream 自己不会存储元素。</p><p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </p><p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</p><p><strong>Stream</strong> <strong>的操作三个步骤</strong></p><p>1、创建Stream</p><p>一个数据源（如：集合、数组），获取一个流</p><p>2、中间操作</p><p>一个中间操作链，对数据源的数据进行处理</p><p>3、终止操作(终端操作) </p><p>一旦执行终止操作，就执行中间操作链，才产生结果【也就是所谓的延迟执行】。之后，不会再被使用</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Java8_New_Features/0004.png"><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; stream() : 返回一个顺序流，顺序流等会中间操作拿数据的时候按顺序拿</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">        IntStream stream = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">        Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        Employee e2 = <span class="keyword">new</span> Employee(<span class="number">1002</span>,<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Employee[] arr1 = <span class="keyword">new</span> Employee[]&#123;e1,e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建 Stream方式三：通过Stream的of()，通过显示值创建一个流。它可以接收任意数量的参数</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式四：创建无限流【用的少，了解下就行】</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      迭代</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">//遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      生成</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Stream的中间操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-筛选与切片</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">//        filter(Predicate p)——过滤   接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;京&quot;));</span></span><br><span class="line"><span class="comment">         * 跟之前的这个lambda表达式代码是一个意思</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，</span></span><br><span class="line"><span class="comment">        则返回一个空流。与 limit(n) 互补</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">41</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"></span><br><span class="line">        list.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//映射</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应</span></span><br><span class="line"><span class="comment">        用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class="line">        namesStream.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//练习2：</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class="line">        <span class="comment">//这个还需要两层遍历</span></span><br><span class="line">        streamStream.forEach(s -&gt;&#123;</span><br><span class="line">            s.forEach(System.out::println);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连</span></span><br><span class="line"><span class="comment">        接成一个流。flatMap一层遍历即可拿到想要的结果</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringToStream</span><span class="params">(String str)</span></span>&#123;<span class="comment">//aa</span></span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : str.toCharArray())&#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> list.stream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        sorted()——自然排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">65</span>, <span class="number">34</span>, <span class="number">87</span>, <span class="number">0</span>, -<span class="number">98</span>, <span class="number">7</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line">        <span class="comment">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class="line"><span class="comment">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line"><span class="comment">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        sorted(Comparator com)——定制排序</span></span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> ageValue = Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">           <span class="keyword">if</span>(ageValue != <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> ageValue;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Stream的终止操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-匹配与查找</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class="line"><span class="comment">//          练习：是否所有的员工的年龄都大于18</span></span><br><span class="line">        <span class="keyword">boolean</span> allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">        System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class="line"><span class="comment">//         练习：是否存在员工的工资大于 10000</span></span><br><span class="line">        <span class="keyword">boolean</span> anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line">        System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class="line"><span class="comment">//          练习：是否存在员工姓“雷”</span></span><br><span class="line">        <span class="keyword">boolean</span> noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;雷&quot;</span>));</span><br><span class="line">        System.out.println(noneMatch);</span><br><span class="line"><span class="comment">//        findFirst——返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class="line">        System.out.println(employee);</span><br><span class="line"><span class="comment">//        findAny——返回当前流中的任意元素</span></span><br><span class="line">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">// count——返回流中元素的总个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"><span class="comment">//        max(Comparator c)——返回流中最大值</span></span><br><span class="line"><span class="comment">//        练习：返回最高的工资：</span></span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class="line">        System.out.println(maxSalary);</span><br><span class="line"><span class="comment">//        min(Comparator c)——返回流中最小值</span></span><br><span class="line"><span class="comment">//        练习：返回最低工资的员工</span></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        forEach(Consumer c)——内部迭代</span></span><br><span class="line">        employees.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">        employees.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2-归约</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line"><span class="comment">//        练习1：计算1-10的自然数的和</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line"><span class="comment">//        练习2：计算公司所有员工工资的总和</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class="line"><span class="comment">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class="line">        System.out.println(sumMoney.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-收集</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line"><span class="comment">//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        employeeList.forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        employeeSet.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><h2 id="什么是Optional？"><a href="#什么是Optional？" class="headerlink" title="什么是Optional？"></a>什么是Optional？</h2><ul><li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p></li><li><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 </p></li><li><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></li></ul><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_Basis/Java8_New_Features/0005.png"><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>首先准备两个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Girl girl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;girl=&quot;</span> + girl +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGirl</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Girl&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的测试两个API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 常用的方法：ofNullable(T t)</span></span><br><span class="line"><span class="comment"> *            orElse(T t)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class="line"><span class="comment">Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class="line"><span class="comment">Optional.ofNullable(T t)：t可以为null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line"><span class="comment">//        girl = null;</span></span><br><span class="line">        <span class="comment">//of(T t):保证t是非空的</span></span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line"><span class="comment">//        girl = null;</span></span><br><span class="line">        <span class="comment">//ofNullable(T t)：t可以为null</span></span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class="line">        System.out.println(optionalGirl);</span><br><span class="line">        <span class="comment">//orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class="line">        <span class="comment">//如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class="line">        Girl girl1 = optionalGirl.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;赵丽颖&quot;</span>));</span><br><span class="line">        System.out.println(girl1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际场景使用</strong></p><p>可能出现空指针的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGirlName</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boy.getGirl().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line">        boy = <span class="keyword">null</span>;</span><br><span class="line">        String girlName = getGirlName(boy);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.atguigu.java4.OptionalTest.getGirlName(OptionalTest.java:47)</span><br><span class="line">at com.atguigu.java4.OptionalTest.test3(OptionalTest.java:54)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Process finished with exit code -1</span><br></pre></td></tr></table></figure><p>没有Optional的解决办法，但是如果调用层数过多，就得一层一层判断是否为null，写起来很麻烦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化以后的getGirlName():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGirlName1</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(boy != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Girl girl = boy.getGirl();</span><br><span class="line">            <span class="keyword">if</span>(girl != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> girl.getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line">        boy = <span class="keyword">null</span>;</span><br><span class="line">        String girlName = getGirlName1(boy);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用Optional解决问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Optional类的getGirlName():</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getGirlName2</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">       <span class="comment">//此时的boy1一定非空</span></span><br><span class="line">       Boy boy1 = boyOptional.orElse(<span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">       Girl girl = boy1.getGirl();</span><br><span class="line"></span><br><span class="line">       Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">       <span class="comment">//girl1一定非空</span></span><br><span class="line">       Girl girl1 = girlOptional.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> girl1.getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Boy boy = <span class="keyword">null</span>;</span><br><span class="line">       boy = <span class="keyword">new</span> Boy();</span><br><span class="line">       boy = <span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">&quot;苍老师&quot;</span>));</span><br><span class="line">       String girlName = getGirlName2(boy);</span><br><span class="line">       System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种是绝对不会出现空指针的。</p><h1 id="接口的增强"><a href="#接口的增强" class="headerlink" title="接口的增强"></a>接口的增强</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDK7及以前：只能定义全局常量和抽象方法</span><br><span class="line">  &gt;全局常量：public static final的.但是书写时，可以省略不写</span><br><span class="line">  &gt;抽象方法：public abstract的</span><br><span class="line">  </span><br><span class="line">JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA:北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接口中的public 可以省略，自动就是public</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompareA：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SuperClass:北京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;CompareB：上海&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SubClass s = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//s.method1();</span></span><br><span class="line"><span class="comment">//SubClass.method1();</span></span><br><span class="line"><span class="comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。实现类用不了</span></span><br><span class="line">CompareA.method1();</span><br><span class="line"><span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line"><span class="comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line">s.method2();</span><br><span class="line"><span class="comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line"><span class="comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line"><span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line">s.method3();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span>,<span class="title">CompareB</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SubClass：上海&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SubClass：深圳&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line"><span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line"><span class="comment">//调用接口中的默认方法</span></span><br><span class="line">CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日期API【TODO】"><a href="#日期API【TODO】" class="headerlink" title="日期API【TODO】"></a>日期API【TODO】</h1><h1 id="注解【TODO】"><a href="#注解【TODO】" class="headerlink" title="注解【TODO】"></a>注解【TODO】</h1>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> JDK8 </tag>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第三阶段-JUC并发包-[2]</title>
      <link href="post/70c90e5d.html"/>
      <url>post/70c90e5d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Phaser工具"><a href="#Phaser工具" class="headerlink" title="Phaser工具"></a>Phaser工具</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>java7中引入了一种新的可重复使用的同步屏障,称为移相器Phaser。Phaser拥有与<code>CyclicBarrier</code>和<code>CountDownLatch</code>类似的功能.</p><p>但是这个类提供了更加灵活的应用。CountDownLatch和CyclicBarrier都是只适用于固定数量的参与者。移相器适用于可变数目的屏障，在这个意义上，可以在任何时间注册新的参与者。并且在抵达屏障是可以注销已经注册的参与者。因此,注册到同步移相器的参与者的数目可能会随着时间的推移而变化。</p><p>如CyclicBarrier一样,移相器可以重复使用,这意味着当前参与者到达移相器后,可以再一次注册自己并等待另一次到达.</p><p>移相器的另一个重要特征是:移相器可能是分层的,这允许你以树形结构来安排移相器以减少竞争</p><p><strong>简单例子：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/11 21:57</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="comment">//JDK8语法，相当于创建5个线程</span></span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>,<span class="number">5</span>).boxed().map(i-&gt;phaser).forEach(Task::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//主线程也注册进去</span></span><br><span class="line">        phaser.register();</span><br><span class="line"></span><br><span class="line">        phaser.arriveAndAwaitAdvance();<span class="comment">//main线程   到达并等待前行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;All of work are finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Task(Phaser phaser) &#123;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">            phaser.register();<span class="comment">//把自己加入计数器中</span></span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The worker[ &quot;</span>+getName()+ <span class="string">&quot; ]&quot;</span> +<span class="string">&quot; is working.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(RANDOM.nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            phaser.arriveAndAwaitAdvance();<span class="comment">//自己完成，等待其他线程完成。  到达并等待前行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><pre><code>The worker[ Thread-1 ] is working.The worker[ Thread-2 ] is working.The worker[ Thread-0 ] is working.The worker[ Thread-4 ] is working.The worker[ Thread-3 ] is working.All of work are finished.</code></pre><h2 id="重复使用的例子"><a href="#重复使用的例子" class="headerlink" title="重复使用的例子"></a>重复使用的例子</h2><p>​    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">跑完步，需要去骑自行车，骑完自行车需要去跳高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> no;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> no, Phaser phaser) &#123;</span><br><span class="line">            <span class="keyword">this</span>.no = no;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(no + <span class="string">&quot; start running.&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">                System.out.println(no + <span class="string">&quot; end running.&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(no + <span class="string">&quot; start bicycle.&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">                System.out.println(no + <span class="string">&quot; end bicycle.&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                System.out.println(no + <span class="string">&quot; start long jump.&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">                System.out.println(no + <span class="string">&quot; end long jump.&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    </p><p><strong>结果</strong>：</p><pre><code>1 start running.2 start running.3 start running.3 end running.2 end running.1 end running.1 start bicycle.2 start bicycle.3 start bicycle.3 end bicycle.2 end bicycle.1 end bicycle.1 start long jump.2 start long jump.3 start long jump.2 end long jump.1 end long jump.3 end long jump.</code></pre><p>可以看到栅栏被重复利用了。</p><h2 id="动态减少"><a href="#动态减少" class="headerlink" title="动态减少"></a>动态减少</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设3号运动员受伤了</span></span><br><span class="line">        <span class="keyword">new</span> InjuredAthletes(<span class="number">3</span>, phaser).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运动员受伤了，需要减少</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InjuredAthletes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> no;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        InjuredAthletes(<span class="keyword">int</span> no, Phaser phaser) &#123;</span><br><span class="line">            <span class="keyword">this</span>.no = no;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sport(no, phaser, <span class="string">&quot; start running.&quot;</span>, <span class="string">&quot; end running.&quot;</span>);</span><br><span class="line">                sport(no, phaser, <span class="string">&quot; start bicycle.&quot;</span>, <span class="string">&quot; end bicycle.&quot;</span>);</span><br><span class="line">                System.out.println(no + <span class="string">&quot;号运动员受伤了&quot;</span>);</span><br><span class="line">                phaser.arriveAndDeregister();<span class="comment">//动态减少</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> no;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> no, Phaser phaser) &#123;</span><br><span class="line">            <span class="keyword">this</span>.no = no;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sport(no, phaser, <span class="string">&quot; start running.&quot;</span>, <span class="string">&quot; end running.&quot;</span>);</span><br><span class="line">                sport(no, phaser, <span class="string">&quot; start bicycle.&quot;</span>, <span class="string">&quot; end bicycle.&quot;</span>);</span><br><span class="line">                sport(no, phaser, <span class="string">&quot; start long jump.&quot;</span>, <span class="string">&quot; end long jump.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sport</span><span class="params">(<span class="keyword">int</span> no, Phaser phaser, String x, String y)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(no + x);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">        System.out.println(no + y);</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 start running.</span><br><span class="line">1 start running.</span><br><span class="line">3 start running.</span><br><span class="line">2 end running.</span><br><span class="line">1 end running.</span><br><span class="line">3 end running.</span><br><span class="line">3 start bicycle.</span><br><span class="line">1 start bicycle.</span><br><span class="line">2 start bicycle.</span><br><span class="line">2 end bicycle.</span><br><span class="line">3 end bicycle.</span><br><span class="line">1 end bicycle.</span><br><span class="line">1 start long jump.</span><br><span class="line">2 start long jump.</span><br><span class="line">3号运动员受伤了</span><br><span class="line">2 end long jump.</span><br><span class="line">1 end long jump.</span><br></pre></td></tr></table></figure><p>3号运动员受伤了，那么他就不能完成jump，3号运动员的<code>phaser.arriveAndAwaitAdvance()</code>也就无法执行，就会导致程序无法终止。因为Phaser数量是3个，只要三个线程都到了才会结束。所以说3号运动员受伤后，可以减少Phaser的数量：<code>phaser.arriveAndDeregister();//动态减少</code></p><p>​    </p><p>​    </p><p>​    </p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulkRegister</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br></pre></td></tr></table></figure><p><strong>register</strong></p><ul><li>  是注册一个线程数，比较常用</li></ul><p><strong>bulkRegister</strong></p><ul><li>  可以批量注册</li></ul><h3 id="到达"><a href="#到达" class="headerlink" title="到达"></a>到达</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndDeregister</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>arrive</strong></p><ul><li>  这个到达后，不会阻塞，相当于<code>countdown</code>机制【因为countdown只会阻塞调用者，其它线程干完任务就可以干其他事】</li><li>  大家要理解一点，party 数和线程是没有关系的，不能说一个线程代表一个 party，因为我们完全可以在一个线程中重复调用 arrive() 方法。这么表达纯粹是方便理解用。</li></ul><p><strong>arriveAndAwaitAdvance</strong></p><ul><li>  到达后会阻塞，相当于<code>CyclicBarrier</code>机制</li></ul><p><strong>arriveAndDeregister</strong></p><ul><li>  当线程出现异常，不能正常到达时，可以调用该方法，<code>动态减少注册数</code></li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> ArriveTask(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待全部任务进行完成</span></span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">&quot;The phase 1 work finish done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArriveTask</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ArriveTask</span><span class="params">(<span class="keyword">int</span> no,Phaser phaser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(String.valueOf(no));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(getName() +  <span class="string">&quot; start working. &quot;</span>);</span><br><span class="line">            threadSleep();</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; The phase one is running.&quot;</span>);</span><br><span class="line">            phaser.arrive();</span><br><span class="line"></span><br><span class="line">            threadSleep();</span><br><span class="line">            System.out.println(getName() +  <span class="string">&quot; keep to other thing. &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadSleep</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(RANDOM.nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onAdvance"><a href="#onAdvance" class="headerlink" title="onAdvance()"></a>onAdvance()</h3><p>这个方法是 protected 的，所以它不是 phaser 提供的 API，从方法名字上也可以看出，它会在一个 phase 结束的时候被调用。</p><p>它的返回值代表是否应该终结（terminate）一个 phaser，之所以拿出来说，是因为我们经常会见到有人通过覆写该方法来自定义 phaser 的终结逻辑，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phase &gt;= N || registeredParties == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、我们可以通过 <code>phaser.isTerminated()</code> 来检测一个 phaser 实例是否已经终结了</p><p>2、当一个 phaser 实例被终结以后，register()、arrive() 等这些方法都没有什么意义了，大家可以玩一玩，观察它们的返回值，原本应该返回 phase 值的，但是这个时候会返回一个负数。</p></blockquote><h3 id="监控子线程任务"><a href="#监控子线程任务" class="headerlink" title="监控子线程任务"></a>监控子线程任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><ul><li>  相当于起到监控的作用</li><li>  如果子线程还没有执行完成，主线程就会阻塞</li><li>  相较而言，可以不用增加注册量</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> AwaitAdvance(i,phaser).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待全部任务进行完成</span></span><br><span class="line">    phaser.awaitAdvance(phaser.getPhase());</span><br><span class="line">    System.out.println(<span class="string">&quot;The phase 1 work finish done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制关闭"><a href="#强制关闭" class="headerlink" title="强制关闭"></a>强制关闭</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceTermination</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>  强制关闭phaser，但是<code>如果线程陷入阻塞，不会唤醒</code></li></ul><h2 id="监控API"><a href="#监控API" class="headerlink" title="监控API"></a>监控API</h2><h3 id="获取阶段数"><a href="#获取阶段数" class="headerlink" title="获取阶段数"></a>获取阶段数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>  返回当前相位数。 最大相位数为Integer.MAX_VALUE</li><li>  每增加一轮就会加一</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line">        System.out.println(phaser.getPhase());</span><br><span class="line"></span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(phaser.getPhase());</span><br><span class="line"></span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(phaser.getPhase());</span><br><span class="line"></span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(phaser.getPhase());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><pre><code>0123</code></pre><h3 id="获取注册的数"><a href="#获取注册的数" class="headerlink" title="获取注册的数"></a>获取注册的数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRegisteredParties</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>  获得注册的线程数，相当于Countdown初始的的计数器</li><li>  可以动态更改</li></ul><h3 id="获得到达和未到达的数目"><a href="#获得到达和未到达的数目" class="headerlink" title="获得到达和未到达的数目"></a>获得到达和未到达的数目</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArrivedParties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUnarrivedParties</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>getArrivedParties</strong></p><ul><li>  获得已经到达的线程数，和没有到达的线程数</li></ul><p><strong>getUnarrivedParties</strong></p><ul><li>  获得没有到达的线程数，和没有到达的线程数</li></ul><h2 id="Phaser的分层结构"><a href="#Phaser的分层结构" class="headerlink" title="Phaser的分层结构"></a>Phaser的分层结构</h2><p>  <strong>Tiering</strong> 这个词本身就不好翻译，大家将就一下，要表达的意思就是，将多个 Phaser 实例构造成一棵树。</p><p>  1、第一个问题来了，为什么要把多个 Phaser 实例构造成一棵树，解决什么问题？有什么优点？</p><p>  Phaser 内部用一个 <code>state</code> 来管理状态变化，随着 parties 的增加，并发问题带来的性能影响会越来越严重。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0-15: unarrived</span></span><br><span class="line"><span class="comment"> * 16-31: parties，   所以一个 phaser 实例最大支持 2^16-1=65535 个 parties</span></span><br><span class="line"><span class="comment"> * 32-62: phase，     31 位，那么最大值是 Integer.MAX_VALUE，达到最大值后又从 0 开始</span></span><br><span class="line"><span class="comment"> * 63: terminated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br></pre></td></tr></table></figure><blockquote><p>通常我们在说 0-15 位这种，说的都是从低位开始的</p></blockquote><p>  state 的各种操作依赖于 CAS，典型的无锁操作，但是，在大量竞争的情况下，可能会造成很多的自旋。</p><p>  而构造一棵树就是为了降低每个节点（每个 Phaser 实例）的 parties 的数量，从而有效降低单个 state 值的竞争。</p><p>  2、第二个问题，它的结构是怎样的？</p><p>  这里我们不讲源码，用通俗一点的语言表述一下。我们先写段代码构造一棵树：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phaser root = <span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Phaser n1 = <span class="keyword">new</span> Phaser(root, <span class="number">5</span>);</span><br><span class="line">Phaser n2 = <span class="keyword">new</span> Phaser(root, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Phaser m1 = <span class="keyword">new</span> Phaser(n1, <span class="number">5</span>);</span><br><span class="line">Phaser m2 = <span class="keyword">new</span> Phaser(n1, <span class="number">5</span>);</span><br><span class="line">Phaser m3 = <span class="keyword">new</span> Phaser(n1, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Phaser m4 = <span class="keyword">new</span> Phaser(n2, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>  根据上面的代码，我们可以画出下面这个很简单的图：</p> <img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Third_stage/0002.png"><p>  这棵树上有 7 个 phaser 实例，每个 phaser 实例在构造的时候，都指定了 parties 为 5，但是，对于每个拥有子节点的节点来说，每个子节点都是它的一个 party，我们可以通过 phaser.getRegisteredParties() 得到每个节点的 parties 数量：</p><ul><li>  m1、m2、m3、m4 的 parties 为 5</li><li>  n1 的 parties 为 5 + 3，n2 的 parties 为 5 + 1</li><li>  root 的 parties 为 5 + 2</li></ul><p>  结论应该非常容易理解，我们来阐述一下过程。</p><p>  在子节点注册第一个 party 的时候，这个时候会在父节点注册一个 party，注意这里说的是子节点添加第一个 party 的时候，而不是说实例构造的时候。</p><p>  在上面代码的基础上，大家可以试一下下面的这个代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phaser m5 = <span class="keyword">new</span> Phaser(n2);</span><br><span class="line">System.out.println(<span class="string">&quot;n2 parties: &quot;</span> + n2.getRegisteredParties());</span><br><span class="line">m5.register();</span><br><span class="line">System.out.println(<span class="string">&quot;n2 parties: &quot;</span> + n2.getRegisteredParties());</span><br></pre></td></tr></table></figure><p>  第一行代码中构造了 m5 实例，但是此时它的 parties == 0，所以对于父节点 n2 来说，它的 parties 依然是 6，所以第二行代码输出 6。第三行代码注册了 m5 的第一个 party，显然，第四行代码会输出 7。</p><p>  当子节点的 parties 降为 0 的时候，会从父节点中”剥离”，我们在上面的基础上，再加两行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m5.arriveAndDeregister();</span><br><span class="line">System.out.println(<span class="string">&quot;n2 parties: &quot;</span> + n2.getRegisteredParties());</span><br></pre></td></tr></table></figure><p>  由于 m5 之前只有一个 parties，所以一次 arriveAndDeregister() 就会使得它的 parties 变为 0，此时第二行代码输出父节点 n2 的 parties 为 6。</p><blockquote><p>还有一点有趣的是，在非树的结构中，此时 m5 应该处于 terminated 状态，因为它的 parties 降为 0 了，不过在树的结构中，这个状态由 root 控制，所以我们依然可以执行 m5.register()…</p></blockquote><p>  3、每个 phaser 实例的 phase 周期有快有慢，怎么协调的？</p><p>  在组织成树的这种结构中，每个 phaser 实例的 phase 已经不受自己控制了，由 root 来统一协调，也就是说，root 当前的 phase 是多少，每个 phaser 的 phase 就是多少。</p><p>  那又有个问题，如果子节点的一个周期很快就结束了，要进入下一个周期怎么办？需要等！这个时候其实要等所有的节点都结束当前 phase，因为只有这样，root 节点才有可能结束当前 phase。</p><p>  我觉得 Phaser 中的树结构我们要这么理解，我们要把整棵树当做一个 phaser 实例，每个节点只是辅助用于降低并发而存在，整棵树还是需要满足 Phaser 语义的。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="请谈谈对阻塞队列的理解"><a href="#请谈谈对阻塞队列的理解" class="headerlink" title="请谈谈对阻塞队列的理解"></a>请谈谈对阻塞队列的理解</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 阻塞队列</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 阻塞队列为空时，从队列中获取元素的操作将会被阻塞</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 阻塞队列为满时，往队列里添加元素的操作将会被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 阻塞队列的好处</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多线程领域中，所谓阻塞，即某些情况下会挂起线程，一旦条件满足，线程唤醒。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为什么需要 BlockingQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 JUC 包发布以前，多线程环境下，程序员需要自己控制这些细节，并且兼顾效率与线程安全</span></span><br></pre></td></tr></table></figure><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ArrayBlockingQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数组结构组成的有界阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> LinkedBlockingQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由链表结构组成的有界(但大小默认值为 Integer.MAX_VALUE) 阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> PriorityBlockingQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 支持优先级排序的无界阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> DelayQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用优先级队列实现的延迟无界阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SynchronousQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不存储元素的阻塞队列，也即单个元素的队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> LinkedTransferQueue</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由链表结构组成的无界阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> LinkedBlockingDeque</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由链表结构组成的双向阻塞队列</span></span><br></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 抛出异常组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> add(e)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 队列满时 add 会抛出 java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remove()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 队列空时 remove 会抛出 java.util.NoSuchElementException</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> element()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 得到队首元素，队列为空时，抛出 java.util.NoSuchElementException</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回布尔值组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offer(e)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 往阻塞队列插入数据，成功时返回 <span class="literal">true</span>，失败时返回 <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> poll()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从阻塞队列取出数据，成功时返回 数据，队列为空时返回 null</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> peek()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出队首元素，成功时返回 数据，队列为空时返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 阻塞</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> put(e)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 往阻塞队列插入数据，无返回值，插入不成功时阻塞线程，直至插入成功 Or 线程中断</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> take()</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从阻塞队列取出数据，成功返回数据，不成功时阻塞线程，直至取出成功 Or 线程中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 超时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offer(e,time,unit)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 往阻塞队列插入数据，成功返回 <span class="literal">true</span>，不成功时线程阻塞等待超时时间，过时返回<span class="literal">false</span> 并放弃操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> poll(time,unit)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从阻塞队列取出数据，成功返回 数据，队列为空时线程阻塞等待超时时间，过时返回<span class="literal">false</span> 并放弃操作</span></span><br></pre></td></tr></table></figure><h2 id="阻塞队列的使用场景"><a href="#阻塞队列的使用场景" class="headerlink" title="阻塞队列的使用场景"></a>阻塞队列的使用场景</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生产者消费者模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 消息中间件</span></span><br></pre></td></tr></table></figure><h3 id="传统版生产者消费者模式-Demo"><a href="#传统版生产者消费者模式-Demo" class="headerlink" title="传统版生产者消费者模式 Demo"></a>传统版生产者消费者模式 Demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 14:56</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 功能描述: 4个线程的if语句</span></span><br><span class="line"><span class="comment"> * 要求:生产者线程消费一个,消费者线程消费一个。num只能为1或0</span></span><br><span class="line"><span class="comment"> * 改用while循环的4个线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer_03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer3 consumer = <span class="keyword">new</span> Consumer3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者线程A</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + num);</span><br><span class="line">        notifyAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + num);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列版生产者消费者模式Demo"><a href="#阻塞队列版生产者消费者模式Demo" class="headerlink" title="阻塞队列版生产者消费者模式Demo"></a>阻塞队列版生产者消费者模式Demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 16:04</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video44</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------生产者线程启动-----------&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.produce();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----------消费者线程启动-----------&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myResource.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;********5秒之后,main叫停生产,生产结束*********&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean FLAG = Boolean.TRUE;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        <span class="comment">//打印日志一般需要看类信息</span></span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        Boolean returnValue;</span><br><span class="line">        <span class="keyword">while</span>(FLAG)&#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            returnValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (returnValue)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t\t 插入队列成功 \t&quot;</span> + data);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入超时 \t&quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 大老板叫停,生产者停止生产&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(FLAG)&#123;</span><br><span class="line"><span class="comment">//            Thread.sleep(500);</span></span><br><span class="line">            data = blockingQueue.poll(<span class="number">2L</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费超时,消费者退出&quot;</span> );</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费队列成功 \t&quot;</span> + data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ul><li>第一:降低资源消耗.通过重复利用自己创建的线程降低线程创建和销毁造成的消耗.</li><li>第二: 提高响应速度.当任务到达时,任务可以不需要等到线程的创建，就能立即执行.</li><li>第三: 提高线程的可管理性.线程是稀缺资源,如果无限的创阿金,不仅会消耗资源,还会较低系统的稳定性,使用线程池可以进行统一分配,调优和监控.</li></ul><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor、Executors、ExecutorService、ThreadPoolExecutor 这几个类。</p><h2 id="线程池七大参数入门简介"><a href="#线程池七大参数入门简介" class="headerlink" title="线程池七大参数入门简介"></a>线程池七大参数入门简介</h2><p><strong>流程举例</strong></p><p>一个银行网点 &lt;线程池&gt;，共 10* 个窗口 &lt;maximumPoolSize 最大线程数&gt;，开放 5* 个窗口 &lt;corePoolSize 核心线程数&gt;<br>。今天办理业务的特别多，其余5个窗口加班一天 &lt;keepAliveTime + unit 多余线程存活时间+单位&gt;，办理业务的人在窗口前排队* &lt;workQueue 请求任务的阻塞队列&gt;。银行<em>里的A</em>职员、B职员… 给办理业务 &lt;threadFactory 产生线程、线程名、线程序数…&gt;最多排10个，来了11个，并且每个窗口都有人在办理业务，多的人怎么拒绝呢？&lt;handler 拒绝策略&gt;</p><p><strong>七大参数</strong></p><ul><li><p>corePoolSize 线程池中的常驻核心线程数</p><pre><code> 创建线程池后，当有请求任务进来，就安排池中的线程去执行请求任务   当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列中</code></pre></li><li><p>maximumPoolSize<br>线程池能够容纳同时执行的最大线程数，此值必须大于等于1</p></li><li><p>keepAliveTime 多余的空闲线程的存活时间</p><pre><code> 当前线程池数量超过 corePoolSize 时，当空闲时间达到 keepAliveTime 值时，  多余空闲线程会被销毁直到只剩下 corePoolSize 个线程为止</code></pre></li><li><p>unit<br>keepAliveTime 的单位</p></li><li><p>workQueue<br>任务队列，被提交但尚未被执行的任务</p></li><li><p>threadFactory，表示生成线程池中工作线程的线程工厂&lt;线程名字、线程序数…&gt;，用于创建线程一般用默认的即可</p></li><li><p>handler，拒接策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时，如何拒绝新的任务</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool =</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,</span><br><span class="line">                        <span class="number">5</span>,</span><br><span class="line">                        <span class="number">1L</span>,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                        Executors.defaultThreadFactory(),</span><br><span class="line">                        <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>; i++ )</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span> );</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的底层工作流程"><a href="#线程池的底层工作流程" class="headerlink" title="线程池的底层工作流程"></a>线程池的底层工作流程</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Third_stage/0003.png"><p>1、创建线程池后，等待请求任务</p><p>2、当调用 execute() 方法添加请求任务时，线程池做如下判断</p><ul><li>如果正在运行的线程数量小于 corePoolSize，马上创建线程执行请求任务</li><li>如果正在运行的线程数量大于或等于 corePoolSize，将请求任务放入阻塞队列</li><li>如果阻塞队列满了，且正在运行的线程数小于 mamimumPoolSize,创建非核心线程执行请求任务</li><li>如果队列满了且线程池线程达到最大线程数，线程池启动饱和拒绝策略来执行</li></ul><p>3、当一个线程完成任务时，从阻塞队列中取出下一个任务来执行</p><p>4、当一个线程无事可做超过一定时间<keepAliveTime>时，线程池会判断</p><ul><li>如果当前运行的线程数大于 corePoolSize，该线程被销毁</li><li>所以，线程池完成所有请求任务后，最终会收缩到 corePoolSize 的大小</li></ul><h2 id="线程池的4种拒绝策略"><a href="#线程池的4种拒绝策略" class="headerlink" title="线程池的4种拒绝策略"></a>线程池的4种拒绝策略</h2><p> <strong>JDK 内置的拒绝策略</strong></p><ul><li><p>AbortPolicy(默认)</p><ul><li>直接抛出 RejectedExecutionException  异常阻止系统正常运行</li></ul></li><li><p>CallerRunsPolicy</p><ul><li>“调用者运行” 一种调节机制</li><li>该策略既不会抛弃任务，也不会抛出异常</li><li>而是将某些任务回退到调用者，从而降低新任务的流量</li></ul></li></ul><ul><li><p>DiscardOldestPolicy</p><ul><li>抛弃队列中等待最久的任务</li><li>然后把当前任务中加入队列中尝试再次提交当前任务</li></ul></li><li><p>DiscardPolicy</p><ul><li>直接丢弃任务，不予任何处理也不抛出异常</li><li>如果允许任务丢失，这是最好的一种方案</li></ul></li></ul><p> 以上拒绝策略都是实现了 RejectedExecutionHandler 接口</p><h2 id="线程池在实际生产中使用哪一个"><a href="#线程池在实际生产中使用哪一个" class="headerlink" title="线程池在实际生产中使用哪一个"></a>线程池在实际生产中使用哪一个</h2><blockquote><p>后文会介绍Java内置的几个线程池</p></blockquote><p> 阿里巴巴 Java 开发手册<br>     线程池不允许使用 Executors 创建，而是通过 ThreadPoolExecutor 的方式</p><p>FixedThreadPool 和 SingleThreadPool<br>         允许的阻塞队列容量为 Integer.MAX_VALUE，可能会堆积大量的请求，导致 OOM</p><p>CachedThreadPool 和 ScheduledThreadPool<br>         允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程，导致 OOM</p><h2 id="线程池合理配置参数"><a href="#线程池合理配置参数" class="headerlink" title="线程池合理配置参数"></a>线程池合理配置参数</h2><p><strong>1、CPU 密集型</strong><br>     意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行<br>     CPU 密集任务只有在真正的多核 CPU 上才可能得到加速(通过多线程)<br>     CPU 密集型任务配置尽可能少的线程数量<br>     一般公式 : CPU 核数 + 1个线程的线程池最大线程数</p><p><strong>2、IO 密集型</strong><br>     由于 IO 密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程<br>     一般公式 : CPU 核数* 2</p><p><strong>3、IO 密集型 2</strong><br>     IO 密集型、即该任务需要大量的 IO，即大量的堵塞<br>     在单线程上运行 IO 密集型的任务会导致浪费大量的 CPU 算力浪费在等待上<br>     所以，IO 密集型任务中使用多线程可以大大的加速程序运行，即时在单核 CPU 上<br>     这种加速主要就是利用了被浪费掉的阻塞时间<br>     参考公式 : CPU 核数 / (1 - 阻塞系数)<br>         例: 8 核CPU 8/(1-0.9) = 80 个线程数</p><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p><strong>线程池状态含义如下</strong></p><p>• RUNNING 接受新任务并且处理阻塞队列里的任务</p><p>• SHUTDOWN ：拒绝新任务但是处理阻塞队列里的任务</p><p>• STOP ：拒绝新任务并且放弃阻塞队列里的任务，同时会中断正在处理的任务。</p><p>• TIDYING：所有任务都执行完（包含阻塞队列里面的任务）后，当前线程池活动线程,数为0，将要调用 terminated 方法</p><p>• TERMINATED：终止状态，terminated 方法调用完成以后的状态</p><p><strong>线程池状态转换列举如下</strong></p><p>• RUNNING -&gt; SHUTDOWN 显式调用shutdown （） 方法 或者隐式调用了 finalize()方法里面的 shutdown（） 方法</p><p>• RUNNING或SHUTDOWN) -&gt; STOP 显式调用 shutdownNow（） 方法</p><p>• SHUTDOWN -&gt;TIDYING 当线程池和任务队列都为空时</p><p>• STOP -&gt; TIDYING 当线程池为空时</p><p>• TIDYING -&gt; TERMNATED terminated() hook 方法执行完成</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>关闭有两个方法：<code>shutdown</code>和<code>shutdownNow</code></p><p><strong>shutdown</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>从源码可以看出，本质上执行的是<code>interrupt</code>方法</li><li>如果线程是空闲的，执行的是Condition的await的方法，会被直接打断，被回收</li><li>如果正在工作，该线程会被打上一个标记，等任务执行后被回收</li></ul><p><strong>shutdownNow</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();<span class="comment">//先打断</span></span><br><span class="line">        tasks = drainQueue();<span class="comment">//再把任务队列没有执行的任务取出</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();<span class="comment">//不断的打断</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先打断空闲的打断</li><li>然后清空任务队列</li><li>然后不断的尝试打断正在执行的线程</li><li>最后会返回一个List集合，包含还没有执行的任务</li></ul><p><strong>awaitTermination 操作</strong></p><p>当线程调用<code>awaitTermination</code>方法后，当前线程会被阻塞，直到线程池状态变为TERMINATED 才返回 或者等待时间超时才返回。</p><h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h1><blockquote><p>内置线程池用的不多，不用太在意</p></blockquote><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Java通过Executors提供五种线程池，分别为：</p><ul><li><p><code>newCachedThreadPool</code>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p></li><li><p><code>newFixedThreadPool</code>：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p></li><li><p><code>newScheduledThreadPool</code>：创建一个定长线程池，支持定时及周期性任务执行。</p><p><strong>和一个线程的区别</strong></p><table><thead><tr><th>newSingleThreadExecutor</th><th>Thread</th></tr></thead><tbody><tr><td>任务执行完成后，不会自动销毁，可以复用</td><td>任务执行完成后，会自动销毁</td></tr><tr><td>可以将任务存储在阻塞队列中，逐个执行</td><td>无法存储任务，只能执行一个任务</td></tr></tbody></table></li><li><p><code>newSingleThreadExecutor</code>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p></li><li><p><code>newWorkStealingPool</code>：创建一个ForkJoin线程池，线程数是CPU核数，可以充分利用CPU资源。从1.8开始有的</p></li></ul><p><strong>简单例子：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/23 10:49</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 线程池的三个常用方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video47</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一池5个处理线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//ExecutorService threadPool= Executors.newFixedThreadPool(5);</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一池一线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool= Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一池N线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//模拟10个用户来办理业务 没有用户就是来自外部的请求线程.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有三个内置线程池比较简单，下面介绍下稍复杂的两个内置线程池。</p><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         nul, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//Returns the number of processors available to the Java virtual machine.</span></span><br><span class="line">    Runtime.getRuntime().availableProcessors()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>分析源码我们可以得知</strong></p><ul><li>  采用的ForkJoin框架，可以将任务进行分割，同时线程之间会互相帮助</li><li>  最大的线程数是CPU核数，充分利用CPU资源</li></ul><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  创建的是一个定时的任务，每隔一段时间就会运行一次</li></ul><p><strong>首先可以对比的就是Timer这个类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="keyword">final</span> TimerTask task = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=====&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//1秒执行一次</span></span><br><span class="line">        timer.schedule(task,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><pre><code>=====1602597314888=====1602597316897=====1602597318898=====1602597320898=====1602597322899=====1602597324899</code></pre><p>可以发现：<strong>如果任务时间超过了定时时长，就无法按照预定的时间执行</strong></p><p><strong>其他工具的解决方式</strong>：</p><ul><li>  <code>crontab</code>定时处理器<strong>为了确保时间的正确性，会重新启一个线程</strong></li></ul><p><strong>有三个方法</strong></p><ul><li><p>  schedule(commod,delay,unit) ，这个方法是说系统启动后，需要等待多久执行，delay是等待时间。只执行一次，没有周期性。</p></li><li><p>  scheduleAtFixedRate(commod,initialDelay,period,unit)，这个是以period为固定周期时间，按照一定频率来重复执行任务，initialDelay是说系统启动后，需要等待多久才开始执行。例如：如果设置了period为5秒，线程启动之后执行了大于5秒，线程结束之后，立即启动线程的下一次，如果线程启动之后只执行了3秒就结束了那执行下一次，需要等待2秒再执行。这个是优先保证任务执行的频率，</p></li><li><p>  scheduleWithFixedDelay(commod,initialDelay,delay,unit)，这个是以delay为固定延迟时间，按照一定的等待时间来执行任务，initialDelay意义与上面的相同。例如：设置了delay为5秒，线程启动之后不管执行了多久，结束之后都需要先生5秒，才能执行下一次。这个是优先保证任务执行的间隔。</p></li></ul><h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video53</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">1L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="comment">//默认抛出异常</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.AbortPolicy()</span></span><br><span class="line">                <span class="comment">//回退调用者</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.CallerRunsPolicy()</span></span><br><span class="line">                <span class="comment">//处理不来的不处理</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.DiscardOldestPolicy()</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//模拟10个用户来办理业务 没有用户就是来自外部的请求线程.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//threadPoolInit();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService一般就是用来作为我们自定义线程池的引用。</p><p><strong>API</strong></p><p>1、<code>getActiveCount()</code>：获取当前线程池中活跃的线程个数；若是没有<code>execute(Runnable)</code>任务的话，是不会创建线程的；提交一个任务，也只会创建一个线程去执行，而不会一次性直接创建<code>corePoolSize</code>个线程。</p><p>2、<code>allowCoreThreadTimeOut(true)</code>：当任务执行完成的时候，释放线程池；<strong>若使用的线程池的keepAliveTime为0，需要手动修改</strong>，因为不允许keepAliveTime为0的线程池，调用此方法；</p><p>3、<code>invokeAny(Call&lt;T&gt;)</code>：此方法是一个同步方法，会阻塞调用线程；若其中有一个任务返回了，则其它的任务取消，不会继续执行； 此方法也存在超时设置重构方法；防止线程一直等待；无法结束。</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><h2 id="Future-API"><a href="#Future-API" class="headerlink" title="Future API"></a>Future API</h2><p>1、<code>get()</code>：此方法是阻塞的，但是抛出了InterruptedException，所以是可以被打断的；使用<code>interrupt()</code>进行打断的时候，打断的是调用get()的线程，让当前线程不再阻塞的等待获取数据；并不是真正执行任务的那个线程。</p><p>2、<code>get(TimeOut)</code>：若是获取数据超时了，但是任务还是依旧执行，只是不再等待任务的返回值。</p><p>3、<code>isDone()</code>：执行任务期间不管是否执行成功了，还是执行失败了（抛出异常）。只要结束，isDone()就会返回true。</p><p>4、<code>boolean cancel(boolean mayInterruptIfRunning)</code>：取消任务。</p><p>返回false的情况：1.任务已经执行完成了，是无法被取消的。2.之前已经被cancel过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        testCancel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCancel</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 把线程设置为守护线程, 根据启动线程dead.</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (running.get())&#123;</span><br><span class="line">                <span class="comment">//模拟一个执行很久的任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(future.cancel(<span class="keyword">true</span>));</span><br><span class="line">        System.out.println(future.isCancelled());</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>true<br>true<br>true</p></blockquote><p>根据例子我们可以看到，cancel虽然取消了任务，但是任务任然在执行，这是为什么呢？</p><blockquote><p><a href="https://blog.csdn.net/stephen8341/article/details/50433656">https://blog.csdn.net/stephen8341/article/details/50433656</a></p></blockquote><p>其实我们如果查看FutureTask的源码就会发现cancel只不过是调用了Thread的interrupt方法，而interrupt只能是停掉线程中有sleep,wait,join逻辑的线程，抛出一个InterruptException。这样看来FutureTask的cancel方法并不能停掉一切正在执行的异步任务。但是这里我们有一个妥协的做法就是在判断条件中加!Thread.currentThread().isInterrupted()这个判断即可.</p><p><strong>改进代码1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCance2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 把线程设置为守护线程, 根据启动线程dead.</span></span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line">            <span class="comment">//模拟一个执行很久的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(future.cancel(<span class="keyword">true</span>));</span><br><span class="line">    System.out.println(future.isCancelled());</span><br><span class="line">    System.out.println(future.isDone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>true<br>true<br>true<br>1111111</p></blockquote><p>可以看到任务是真正被终止了。</p><p>还有一个场景</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line">            <span class="comment">//模拟一个执行很久的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面改进代码的第一步，第一行代码是个IO操作，假设耗时非常长，那就根本没有机会判断while条件。此时如果cancel，一样不会真正的终止任务的执行。</p><p><strong>改进代码2</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void testCance3() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 把线程设置为守护线程, 根据启动线程dead.</span><br><span class="line">        AtomicBoolean running &#x3D; new AtomicBoolean(true);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool( r -&gt; &#123;</span><br><span class="line">            Thread t &#x3D; new Thread(r);</span><br><span class="line">            t.setDaemon(true);</span><br><span class="line">            return t;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future &#x3D; executorService.submit(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;            while (!Thread.interrupted())&#123;</span><br><span class="line">&#x2F;&#x2F;                &#x2F;&#x2F;模拟一个执行很久的任务</span><br><span class="line">&#x2F;&#x2F;            &#125;   </span><br><span class="line"></span><br><span class="line">            while (running.get())&#123;</span><br><span class="line">                &#x2F;&#x2F;模拟一个执行很久的任务</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;1111111&quot;);</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(future.cancel(true)); &#x2F;&#x2F; 可以取消掉任务, 但是无法终止任务的执行.</span><br><span class="line">        System.out.println(future.isCancelled());</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>控制台输出：</p><p>true<br>true<br>true</p><p>Process finished with exit code 0</p></blockquote><p>可以看到直接结束了，思想就是将线程设置为守护线程，一旦主线程执行完，守护线程无论在干什么都会马上结束。所以后面的<code>System.out.println(&quot;1111111&quot;);</code>都没有打印</p><h2 id="已经被cancel的任务，是否还能拿到结果？"><a href="#已经被cancel的任务，是否还能拿到结果？" class="headerlink" title="已经被cancel的任务，是否还能拿到结果？"></a>已经被cancel的任务，是否还能拿到结果？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void testCance2() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 把线程设置为守护线程, 根据启动线程dead.</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; future &#x3D; executorService.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        while (!Thread.interrupted())&#123;</span><br><span class="line">            &#x2F;&#x2F;模拟一个执行很久的任务</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;1111111&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">    System.out.println(future.cancel(true));</span><br><span class="line">    System.out.println(future.isCancelled());</span><br><span class="line">    System.out.println(future.isDone());</span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>true<br>true<br>true<br>1111111<br>java.util.concurrent.CancellationException<br>    at java.util.concurrent.FutureTask.report(FutureTask.java:121)<br>    at java.util.concurrent.FutureTask.get(FutureTask.java:192)<br>    at Future.FutureExample1.testCance2(FutureExample1.java:63)<br>    at Future.FutureExample1.main(FutureExample1.java:19)</p></blockquote><p>输出了111111，说明程序已经走到了return那一行，但是可以看到拿不到了爆出了异常。</p><h2 id="Future的缺陷以及解决方案"><a href="#Future的缺陷以及解决方案" class="headerlink" title="Future的缺陷以及解决方案"></a>Future的缺陷以及解决方案</h2><p>1、缺陷一：使用Future可以保证任务的异步执行；但是，只要去获取任务的结果，就会导致程序的阻塞；从而，<strong>从异步再次变为了同步</strong>。</p><p>2、缺陷二：假设批量执行一些异步任务，大部分任务都是几秒完成的，有少许任务是几个小时才完成。那你get()的时候，万一拿到了几个小时执行的任务，就会一直阻塞，导致几秒完成的任务拿不到结果。</p><p>3、像netty会有回调的callback</p><p><strong>缺陷代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureExecSomeTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;Callable&lt;Integer&gt;&gt; callableList = Arrays.asList(            </span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 10 finished!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            () -&gt; &#123;                </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 20 finished!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">     );</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeAll会阻塞等待所有的future执行完成.</span></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = executorService.invokeAll(callableList); </span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : futureList) &#123;       </span><br><span class="line">     System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>JDK7解决方案</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureDefect</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Callable&lt;Integer&gt;&gt; callableList = Arrays.asList(            </span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 10 finished!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            () -&gt; &#123;                </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 20 finished!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    futureList.add(executorService.submit(callableList.get(<span class="number">0</span>)));</span><br><span class="line">    futureList.add(executorService.submit(callableList.get(<span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Integer&gt; future : futureList) &#123;<span class="comment">// 其实相当于把批量任务, 单个的提交给线程池去执行.</span></span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>JDK8解决方案</strong></p><p>CompletionService：具体见下面</p><h1 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul><li><p>CompletionService的实现目标是任务先完成可优先获取到，即结果按照完成先后顺序排序。</p></li><li><p>ExecutorCompletionService类是常用的CompletionService实现类，该类只有三个成员变量：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCompletionService</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">CompletionService</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutorService aes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到ExecutorCompletionService主要是<strong>增强executor线程池的。</strong></li><li>Task包装后被塞入completionQueue，当Task结束，其Future就可以从completionQueue中获取到。</li></ul><p><strong>执行流程：</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Third_stage/0004.png"><h2 id="阻塞和非阻塞获取"><a href="#阻塞和非阻塞获取" class="headerlink" title="阻塞和非阻塞获取"></a>阻塞和非阻塞获取</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">take</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">1234</span></span><br></pre></td></tr></table></figure><p><strong>阻塞获取</strong></p><p>take方法回使调用者阻塞，可以保证一定会有Future取出</p><p><strong>非阻塞获取</strong></p><p>poll方法会去查看是否有任务完成，有则取出；没有，就会返回一个null</p><h2 id="代码解决Future缺陷"><a href="#代码解决Future缺陷" class="headerlink" title="代码解决Future缺陷"></a>代码解决Future缺陷</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletionServiceExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testCompleteExecutorService();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompleteExecutorService</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Callable&lt;Integer&gt;&gt; callableList = Arrays.asList(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 10 finished!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">400</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 20 finished!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数值为线程池对象.</span></span><br><span class="line">        ExecutorCompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br><span class="line">        <span class="comment">// 提交需要执行的任务.</span></span><br><span class="line">        callableList.stream().forEach(item -&gt; completionService.submit(item));</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future;</span><br><span class="line">        <span class="comment">// 阻塞的获取任务结果. 但是, 不是等待全部任务完成, 而是, 完成一个任务, 获取一个任务结果.</span></span><br><span class="line">        <span class="keyword">while</span> ((future = completionService.take()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为take阻塞住了，所以你是看不到下面这个打印的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main is finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 10 finished!</span><br><span class="line">10</span><br><span class="line">Thread 20 finished!</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>稍微改一下就可以打印出来了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletionServiceExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testCompleteExecutorService();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompleteExecutorService</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Callable&lt;Integer&gt;&gt; callableList = Arrays.asList(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 10 finished!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">400</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 20 finished!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数值为线程池对象.</span></span><br><span class="line">        ExecutorCompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executorService);</span><br><span class="line">        <span class="comment">// 提交需要执行的任务.</span></span><br><span class="line">        callableList.stream().forEach(item -&gt; completionService.submit(item));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> taskCount = callableList.size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">            Integer result = completionService.take().get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main is finished!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记得关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 10 finished!</span><br><span class="line">10</span><br><span class="line">Thread 20 finished!</span><br><span class="line">20</span><br><span class="line">Main is finished!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="按完成顺序获取结果验证"><a href="#按完成顺序获取结果验证" class="headerlink" title="按完成顺序获取结果验证"></a>按完成顺序获取结果验证</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletionServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开启3个线程</span></span><br><span class="line">        ExecutorService exs = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> taskCount = <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 结果集</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.定义CompletionService</span></span><br><span class="line">            CompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;Integer&gt;(exs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.添加任务</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;taskCount;i++)&#123;</span><br><span class="line">                completionService.submit(<span class="keyword">new</span> Task(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.获取结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;taskCount;i++)&#123;</span><br><span class="line">                Integer result = completionService.take().get();</span><br><span class="line">                list.add(result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;list=&quot;</span>+list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程池</span></span><br><span class="line">            exs.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        Integer i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.i=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;任务i=&quot;</span>+i+<span class="string">&quot;,执行完成！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>控制台输出：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程：pool-1-thread-2任务i&#x3D;2,执行完成！</span><br><span class="line">线程：pool-1-thread-3任务i&#x3D;3,执行完成！</span><br><span class="line">线程：pool-1-thread-1任务i&#x3D;1,执行完成！</span><br><span class="line">线程：pool-1-thread-4任务i&#x3D;4,执行完成！</span><br><span class="line">线程：pool-1-thread-1任务i&#x3D;8,执行完成！</span><br><span class="line">线程：pool-1-thread-4任务i&#x3D;9,执行完成！</span><br><span class="line">线程：pool-1-thread-2任务i&#x3D;6,执行完成！</span><br><span class="line">线程：pool-1-thread-3任务i&#x3D;7,执行完成！</span><br><span class="line">线程：pool-1-thread-1任务i&#x3D;10,执行完成！</span><br><span class="line">线程：pool-1-thread-5任务i&#x3D;5,执行完成！</span><br><span class="line">list&#x3D;[2, 3, 1, 4, 8, 9, 6, 7, 10, 5]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="CompleableFuture（重要，很常用）"><a href="#CompleableFuture（重要，很常用）" class="headerlink" title="CompleableFuture（重要，很常用）"></a>CompleableFuture（重要，很常用）</h1><h2 id="为什么会出现CompletableFuture？"><a href="#为什么会出现CompletableFuture？" class="headerlink" title="为什么会出现CompletableFuture？"></a>为什么会出现CompletableFuture？</h2><p>1、使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。</p><p>2、从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><p><strong>优点：</strong></p><ul><li>可以利用结果进行级联的执行</li><li>支持callback会自动回调给调用者</li><li>执行一批任务时，可以按照任务执行的顺序，获得结果</li><li>可以并行的获取结果，只拿最先获取的结果级联的执行</li></ul><h2 id="简介及注意点"><a href="#简介及注意点" class="headerlink" title="简介及注意点"></a>简介及注意点</h2><p>1、CompletableFuture相当于是Future和ExecutorService的结合体，CompleableFuture依然是对Executor的封装，看构造函数的源码，可以知道一般情况下会创建一个ForkJoinPool，同时ThreadFactory<strong>会设置为守护线程</strong>。这就意味着：<code>一旦主线程结束，线程池就会关闭。</code>。可能导致回调函数还未执行, 便停止了。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).whenComplete((v,t)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制台输出：</p><blockquote><p>Done</p></blockquote><p>2、可以改为此方法runAsync(Runnable, Executors), 让线程池去去管理线程. 不会跟随调用线程消失; 但是, 需要注意关闭线程池.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testrunAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;starting&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;, threadPool).whenComplete((v, t) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;All finished!&quot;</span>);</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><blockquote><p>starting<br>All finished!<br>end!<br>Finished!</p><p>Process finished with exit code 0</p></blockquote><h2 id="构造CompleableFuture"><a href="#构造CompleableFuture" class="headerlink" title="构造CompleableFuture"></a>构造CompleableFuture</h2><p>创建<code>CompleableFuture</code>不建议使用构造方法，而是使用静态的工厂方法构建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>                                                                      </span></span><br></pre></td></tr></table></figure><ul><li>  <code>allOf(CompletableFuture&lt;?&gt;... cfs)</code>：这个方法会返回一个全新的CompletableFuture，传递进去的所有CompletableFuture执行完才算是执行完成。</li><li>  <code>anyOf(CompletableFuture&lt;?&gt;... cfs)</code>：这个方法会返回一个全新的CompletableFuture，只要传递进去的有一个CompletableFuture执行完，就算是执行完成</li><li>  <code>completedFuture(U value)</code> ：可以假设一个执行出了一个结果，进行下面的级联操作。</li><li>  <code>runAsync</code>：异步的执行Runnable，没有返回值。</li><li>  <code>supplyAsync</code>：异步的执行Supplier实例，会有返回值。</li></ul><h3 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br></pre></td></tr></table></figure><p>特点就是没有返回值，并且参数是<code>Runnable</code>。比一般的提交一个Runnable相比，可以更加灵活点使用，级联、并联等操作</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_runAsync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main....start....&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行结果:&quot;</span> + i);</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过前面的睡眠5秒，也可以验证出，shutdown会处理已经在阻塞队列里的</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main....start....</span><br><span class="line">当前线程：12</span><br><span class="line">运行结果:5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span> </span></span><br></pre></td></tr></table></figure><p>需要给<code>supplyAsync</code>提供一个Supplier</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_supplyAsync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main....start....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行结果:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executor).whenComplete((res, excption) -&gt; &#123; <span class="comment">//虽然能得到异常信息，但是没法修改返回数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务成功完成了...结果是:&quot;</span> + res + <span class="string">&quot;；异常信息是&quot;</span> + excption);</span><br><span class="line">        &#125;).exceptionally(throwable -&gt; &#123;  <span class="comment">//可以感知异常，同时返回默认值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;); <span class="comment">//成功以后干啥事</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;future获取结果：&quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">4</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行结果:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executor).handle((res, thr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (thr != <span class="keyword">null</span>) &#123;  <span class="comment">//异常不等于空了，就返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;future1获取结果：&quot;</span> + future1.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><pre><code>main....start....当前线程：pool-1-thread-1异步任务成功完成了...结果是:null；异常信息是java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zerofuture获取结果：10当前线程：pool-1-thread-2运行结果:2future1获取结果：4Process finished with exit code 0</code></pre><h3 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_anyOf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; futureImg = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品的图片信息&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello.jpg&quot;</span>;</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureAttr = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品的属性&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;黑色+256G&quot;</span>;</span><br><span class="line">        &#125;,executor);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureDesc = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品的介绍&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">        &#125;,executor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、因为anyOf是等待最早的一个CompletableFuture就能结束，所以返回值是最早执行完的那个任务。</span></span><br><span class="line"><span class="comment">         * 2、直接通过原来的future.get()可能会有空指针异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(futureImg, futureAttr, futureDesc);</span><br><span class="line">        anyOf.get();<span class="comment">//等待所有结果完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最早完成的任务返回值为：&quot;</span>+anyOf.get());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><pre><code>查询商品的介绍最早完成的任务返回值为：华为查询商品的图片信息查询商品的属性</code></pre><p>这个例子中，前两个<code>CompletableFuture</code>都睡了两秒，所以执行最快的肯定是第三个，从结果中也得到了验证。</p><p>需要注意一点，虽然是异步的从一个地方取值，但是其他任务依然会执行完成，而并非不再执行了。</p><h3 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_allOf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; futureImg = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品的图片信息&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello.jpg&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureAttr = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品的属性&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;黑色+256G&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        CompletableFuture&lt;String&gt; futureDesc = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查询商品的介绍&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待Future返回------&quot;</span>);</span><br><span class="line">        <span class="comment">//因为allOf是等待所有CompletableFuture完成才能结束，所以没有返回值，直接通过原来的future.get()就一定会有返回值</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(futureImg, futureAttr, futureDesc);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终得到的结果：&quot;</span> + futureImg.get() + <span class="string">&quot;=&gt;&quot;</span> + futureAttr.get() + <span class="string">&quot;=&gt;&quot;</span> + futureDesc.get());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">等待Future返回------</span><br><span class="line">查询商品的图片信息</span><br><span class="line">查询商品的介绍</span><br><span class="line">查询商品的属性</span><br><span class="line">最终得到的结果：hello.jpg&#x3D;&gt;黑色+256G&#x3D;&gt;华为</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="组合方法"><a href="#组合方法" class="headerlink" title="组合方法"></a>组合方法</h2><h3 id="组合两个任务，同时处理两个结果"><a href="#组合两个任务，同时处理两个结果" class="headerlink" title="组合两个任务，同时处理两个结果"></a>组合两个任务，同时处理两个结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       Executor executor)</span></span></span><br></pre></td></tr></table></figure><p><strong>举例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Accept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;我是任务1&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;我是任务2&quot;</span>);</span><br><span class="line">        completableFuture1.thenAcceptBothAsync(completableFuture2, (s, i) -&gt; &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;==&gt;&quot;</span> + i);</span><br><span class="line">        &#125;, executor);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><pre><code>我是任务1==&gt;我是任务2Process finished with exit code 0</code></pre><p><strong>分析</strong></p><ul><li>  可以看出是两个任务组合，然后同时将两个结果一起处理</li></ul><h3 id="组合两个任务，任务完成后做的操作"><a href="#组合两个任务，任务完成后做的操作" class="headerlink" title="组合两个任务，任务完成后做的操作"></a>组合两个任务，任务完成后做的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            Runnable action)</span>                                            </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Runnable action)</span></span></span><br></pre></td></tr></table></figure><h3 id="当两个任务任意一个执行完成后，执行一个操作"><a href="#当两个任务任意一个执行完成后，执行一个操作" class="headerlink" title="当两个任务任意一个执行完成后，执行一个操作"></a>当两个任务任意一个执行完成后，执行一个操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Runnable action,Executor executor)</span>)</span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_runAfterEither</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是任务1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;,executor);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = completableFuture.runAfterEitherAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我是任务2&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;两个任务执行完，我才执行&quot;</span>),executor);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><pre><code>我是任务1我是任务2end两个任务执行完，我才执行Process finished with exit code 0</code></pre><h3 id="组合两个任务，处理后，返回一个结果"><a href="#组合两个任务，处理后，返回一个结果" class="headerlink" title="组合两个任务，处理后，返回一个结果"></a>组合两个任务，处理后，返回一个结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>​    </p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_thenCombine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Boolean&gt; future = completableFuture.thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; <span class="number">100</span>),</span><br><span class="line">                (s, i) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;s: &quot;</span> + s + <span class="string">&quot; , i : &quot;</span> + i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;, executor);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><pre><code>s: a , i : 100trueProcess finished with exit code 0</code></pre><h3 id="第一个任务的输出是第二个任务的输入"><a href="#第一个任务的输出是第二个任务的输入" class="headerlink" title="第一个任务的输出是第二个任务的输入"></a>第一个任务的输出是第二个任务的输入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>相当于一次级联操作</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_thenCompose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;我是任务1&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;我是任务2&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = completableFuture1.thenComposeAsync(s -&gt; completableFuture2, executor);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是任务2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="中转方法"><a href="#中转方法" class="headerlink" title="中转方法"></a>中转方法</h2><h3 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h3><h4 id="当执行完成时执行的操作"><a href="#当执行完成时执行的操作" class="headerlink" title="当执行完成时执行的操作"></a>当执行完成时执行的操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_whenComplete</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = completableFuture.whenComplete((v, t)</span><br><span class="line">                -&gt; &#123;</span><br><span class="line">            System.out.println(v + <span class="string">&quot; World !&quot;</span>);</span><br><span class="line">            <span class="comment">//这个t是Throwable，只有报错了才会打印</span></span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;future:&quot;</span> + future.get());</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>结果</strong></p><pre><code>Hello World !Hello</code></pre><p><strong>分析</strong></p><ul><li><p>当执行完成时执行的回调方法</p></li><li><p>该方法会接收执行的结果以及异常</p></li><li><p>回调完成会，会把原来任务执行的结果传递回去</p></li><li><p>whenCompleteAsync是异步的；whenComplete是同步的，会卡住主线程</p></li><li><p>需要传递一个<code>BiConsumer</code>接口，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span>l</span>;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure><ul><li>T是执行的结果，U是执行时产生的异常</li></ul><h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn,Executor executor)</span></span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_thenApplyAsync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = completableFuture.thenApplyAsync(t -&gt; &#123;</span><br><span class="line">            String s = t + <span class="string">&quot; World !&quot;</span>;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><pre><code>Hello World !13Process finished with exit code -1</code></pre><p><strong>分析</strong></p><ul><li>  是一个级联操作，即拿着上个任务的结果，做下个任务，同时返回一个新的结果</li></ul><h4 id="处理结果的操作"><a href="#处理结果的操作" class="headerlink" title="处理结果的操作"></a>处理结果的操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T,Throwable,? extends U&gt; fn,Executor executor)</span></span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = completableFuture.handleAsync((s,t) -&gt; &#123;</span><br><span class="line">            String aaa =  t + <span class="string">&quot; World !&quot;</span>;</span><br><span class="line">            System.out.println(aaa);</span><br><span class="line">            <span class="keyword">return</span> aaa.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><pre><code>Hello World !13</code></pre><p><strong>分析</strong>：</p><ul><li>  相比于<code>whenComplete</code>返回值可以自己处理，相当于一次级联</li><li>  相比于<code>thenApply</code>，可以处理异常</li></ul><h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值"></a>无返回值</h3><h4 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = completableFuture.thenAccept(t -&gt; &#123;</span><br><span class="line">            String aaa =  t + <span class="string">&quot; World !&quot;</span>;</span><br><span class="line">            System.out.println(aaa);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><pre><code>Hello World !null</code></pre><p><strong>分析</strong></p><ul><li>  相当于一次级联，但是没有返回值</li></ul><h4 id="执行完全部任务"><a href="#执行完全部任务" class="headerlink" title="执行完全部任务"></a>执行完全部任务</h4><pre><code>public CompletableFuture&lt;Void&gt; thenRun(Runnable action)public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action)public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action,Executor executor)</code></pre><p><strong>分析</strong></p><ul><li>  相较<code>thenAccept</code>，不处理任务的执行结果</li></ul><h2 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h2><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><pre><code>public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_exceptionally</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;World &quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture.exceptionally(Throwable::getMessage).thenAccept(t -&gt; &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line"></span><br><span class="line">Process finished with exit code -1</span><br></pre></td></tr></table></figure><h4 id="立马获取结果"><a href="#立马获取结果" class="headerlink" title="立马获取结果"></a>立马获取结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getNow</span><span class="params">(T valueIfAbsent)</span></span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_getNow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        String now = completableFuture.getNow(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><pre><code>HelloWorldProcess finished with exit code -1</code></pre><p><strong>分析</strong></p><ul><li>  如果结果完成返回结果，如果未完成，返回传入进去的值</li></ul><h4 id="判断结果是否完成，如果未完成则赋予结果"><a href="#判断结果是否完成，如果未完成则赋予结果" class="headerlink" title="判断结果是否完成，如果未完成则赋予结果"></a>判断结果是否完成，如果未完成则赋予结果</h4><pre><code>public boolean complete(T value)</code></pre><h4 id="判断结果是否完成，如果未完成返回异常"><a href="#判断结果是否完成，如果未完成返回异常" class="headerlink" title="判断结果是否完成，如果未完成返回异常"></a>判断结果是否完成，如果未完成返回异常</h4><pre><code>public boolean completeExceptionally(Throwable ex)</code></pre><h4 id="后续获取结果会产生异常"><a href="#后续获取结果会产生异常" class="headerlink" title="后续获取结果会产生异常"></a>后续获取结果会产生异常</h4><pre><code>public void obtrudeException(Throwable ex)</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>  <code>thenAccept</code>()处理正常结果；</li><li>  <code>exceptionally</code>()处理异常结果；</li><li>  <code>thenApplyAsync</code>()用于串行化另一个<code>CompletableFuture</code>；</li><li>  <code>anyOf</code>()和<code>allOf</code>()用于并行化多个<code>CompletableFuture</code>。</li></ul><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>《Java并发编程之美》</p><p><a href="https://www.cnblogs.com/yuandengta/p/12887361.html">https://www.cnblogs.com/yuandengta/p/12887361.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第三阶段-JUC并发包-[1]</title>
      <link href="post/5be45d9e.html"/>
      <url>post/5be45d9e.html</url>
      
        <content type="html"><![CDATA[<h1 id="AtomicXXXFieldUpdater"><a href="#AtomicXXXFieldUpdater" class="headerlink" title="AtomicXXXFieldUpdater"></a>AtomicXXXFieldUpdater</h1><blockquote><p>算是一个小补充</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Test&gt; updater = AtomicIntegerFieldUpdater.newUpdater(Test.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Test ts = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(item -&gt; &#123;            </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> value = updater.getAndIncrement(ts);</span><br><span class="line">                System.out.println(<span class="string">&quot;oldV: &quot;</span> + value);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、以<code>AtomicIntegerFieldUpdater</code>为例，看上面代码。Test类的value属性被volatile修饰了，但是volatile只能保证可见性和有序性。在以往的文章里我们讲过是可以通过volatile+CAS同时解决可见性，有序性，原子性。</p><p>2、JUC提供了一种新的功能来保证原子性，AtomicXXXFieldUpdater修饰的类对应的字段，在进行更新时同样可以保证原子性。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>想让类的属性操作具备原子性，</p></li><li><p>但是不想使用锁。</p></li><li><p>大量需要原子类型修饰的对象，相比较比较耗费内存</p></li></ul><p>举个例子：</p><p>如果你想要保证原子性，一般是使用<code>AtomicStampedReference&lt;Node&gt;</code>来包装Node对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.lucene.util.RamUsageEstimator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/11 16:51</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 计算对象内存大小</span></span><br><span class="line"><span class="comment"> * https://blog.csdn.net/yunqiinsight/article/details/80431831</span></span><br><span class="line"><span class="comment"> * https://www.cnblogs.com/libin6505/p/10648091.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate_Java_Object_Size</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">//计算指定对象本身在堆空间的大小，单位字节</span></span><br><span class="line">        <span class="keyword">long</span> b = RamUsageEstimator.shallowSizeOf(node);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        AtomicStampedReference&lt;Node&gt; nodeAtomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;Node&gt;(node,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> c = RamUsageEstimator.shallowSizeOf(nodeAtomicStampedReference);</span><br><span class="line">        System.out.println(c + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: Api说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Api</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="comment">//下面三个方法参数都是 Object类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算指定对象及其引用树上的所有对象的综合大小，单位字节</span></span><br><span class="line">        <span class="keyword">long</span> a = RamUsageEstimator.sizeOf(o);</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算指定对象本身在堆空间的大小，单位字节</span></span><br><span class="line">        <span class="keyword">long</span> b = RamUsageEstimator.shallowSizeOf(o);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算指定对象及其引用树上的所有对象的综合大小，返回可读的结果，如：2KB</span></span><br><span class="line">        String c = RamUsageEstimator.humanSizeOf(o);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line">    Integer value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>24</p><p>40</p></blockquote><p>可以看出如果用了<code>AtomicStampedReference&lt;Node&gt;</code>，会多出16个字节。如果对象有10000个，那么会多出很多字节。生产过程中的内存都是很贵的。为了减少内存消耗，同时可以保证原子性，就可以使用<code>AtomicXXXFieldUpdater</code>。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li><li>是通过一个 state（相当于计数器）的东西来实现的，计数器的初始值是 <strong>线程的数量或者任务的数量</strong>。</li><li>每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li><li>CountDownLatch的方便之处在于，你可以在一个线程中使用， <strong>也可以在多个线程上使用，一切只依据状态值</strong>，这样便不会受限于任何的场景。</li></ul><h2 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h2><p><strong>需求</strong></p><ul><li>可能刚从数据库读取了一批数据</li><li>利用并发处理这批数据</li><li>当所有的数据处理完成后，再去执行后面的操作</li></ul><p><strong>解决方案</strong></p><ul><li><strong>第一种</strong>：可以利用 join 的方法，但是在线程池中，比较麻烦。</li><li><strong>第二种</strong>：利用线程池的awaitTermination，阻塞一段时间。<ul><li>当使用awaitTermination时，主线程会处于一种等待的状态，等待线程池中所有的线程都运行完毕后才继续运行。</li></ul></li><li><strong>第三种</strong>：利用CountDownLatch，每当任务完成一个，就计数器减一。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _05_AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 10:05</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video32</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\t\t&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;处理完毕~~~&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;非调用者线程-&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;-还可以干点其他事&quot;</span>);</span><br><span class="line">             &#125;, Country.forEach_Country(i + <span class="number">1</span>).getCountryName()).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t 所有任务都已经处理完毕，可以往后执行了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Country</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ONE(<span class="number">1</span>,<span class="string">&quot;1号任务&quot;</span>),</span><br><span class="line">    TWO(<span class="number">2</span>,<span class="string">&quot;2号任务&quot;</span>),</span><br><span class="line">    THREE(<span class="number">3</span>,<span class="string">&quot;3号任务&quot;</span>),</span><br><span class="line">    FOUR(<span class="number">4</span>,<span class="string">&quot;4号任务&quot;</span>),</span><br><span class="line">    FIVE(<span class="number">5</span>,<span class="string">&quot;5号任务&quot;</span>),</span><br><span class="line">    SIX(<span class="number">6</span>,<span class="string">&quot;6号任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line">    <span class="keyword">private</span> String countryName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Country <span class="title">forEach_Country</span><span class="params">(Integer index)</span></span>&#123;</span><br><span class="line">        Country[] values = Country.values();</span><br><span class="line">        <span class="keyword">for</span> (Country c: values) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c.getIndex() == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Country(Integer index, String countryName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.countryName = countryName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountryName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countryName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>号任务处理完毕~~~</span><br><span class="line"><span class="number">5</span>号任务处理完毕~~~</span><br><span class="line">非调用者线程-<span class="number">5</span>号任务-还可以干点其他事</span><br><span class="line"><span class="number">6</span>号任务处理完毕~~~</span><br><span class="line"><span class="number">3</span>号任务处理完毕~~~</span><br><span class="line">非调用者线程-<span class="number">3</span>号任务-还可以干点其他事</span><br><span class="line"><span class="number">4</span>号任务处理完毕~~~</span><br><span class="line"><span class="number">2</span>号任务处理完毕~~~</span><br><span class="line">非调用者线程-<span class="number">4</span>号任务-还可以干点其他事</span><br><span class="line">非调用者线程-<span class="number">6</span>号任务-还可以干点其他事</span><br><span class="line">非调用者线程-<span class="number">1</span>号任务-还可以干点其他事</span><br><span class="line">-----------------------------</span><br><span class="line"> 所有任务都已经处理完毕，可以往后执行了！</span><br><span class="line">非调用者线程-<span class="number">2</span>号任务-还可以干点其他事</span><br></pre></td></tr></table></figure><p>因为countdown只会阻塞调用者，其它线程干完任务就可以干其他事。这里的调用者线程就是main线程。</p><h2 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h2><p><strong>需求</strong></p><ul><li>多个线程协同工作</li><li>多个线程需要等待其他线程的工作之后，再进行其后续工作。</li><li>被唤醒后继续执行其他操作</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Do some initial working.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Do other working.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Do some initial working.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Do other working.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;asyn prepare for some data.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Data prepare for done.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> Do some initial working.</span><br><span class="line">Thread-<span class="number">1</span> Do some initial working.</span><br><span class="line">asyn prepare <span class="keyword">for</span> some data.</span><br><span class="line">Data prepare <span class="keyword">for</span> done.</span><br><span class="line">Thread-<span class="number">0</span> Do other working.</span><br><span class="line">Thread-<span class="number">1</span> Do other working.</span><br></pre></td></tr></table></figure><p>总体来说意思都差不多</p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p><strong>构造方法只有一个</strong></p><ul><li><code>CountDownLatch(int count)</code> ：构造一个以给定计数</li></ul><p><strong>实例方法</strong></p><ul><li><code>public void await()</code><ul><li><strong>当前线程等到锁存器计数到零</strong></li><li>可以被 <strong>打断</strong></li></ul></li><li><code>public boolean await(long timeout,TimeUnit unit)</code><ul><li>等待一段时间</li><li><strong>timeout</strong> - 等待的最长时间 ， <strong>unit</strong> - timeout参数的时间单位</li><li>如果 <strong>指定的等待时间过去</strong>，则返回值false</li><li>如果 <strong>计数达到零</strong>，则方法返回值为true</li></ul></li><li><code>public void countDown()</code><ul><li>减少锁存器的计数， <strong>如果计数达到零，释放所有等待的线程</strong>。</li></ul></li><li><code>public long getCount()</code><ul><li>返回当前计数</li></ul></li></ul><h2 id="给离散的平行任务增加逻辑层次关系"><a href="#给离散的平行任务增加逻辑层次关系" class="headerlink" title="给离散的平行任务增加逻辑层次关系"></a>给离散的平行任务增加逻辑层次关系</h2><p><strong>需求</strong></p><ul><li>并发的从很多的数据库读取大量数据</li><li>在读取数据的过程中，某个表可能会出现： 数据丢失、数据精度丢失、数据大小不匹配。</li><li>需要进行对数据的各个情况进行检测，这个检测是并发的完成的</li><li>所以需要控制如果一个表所有的情况检测完成，再进行后续的操作</li></ul><p><strong>解决</strong></p><ul><li>利用 <code>CountDownLatch</code>的计数器</li><li>每当一个检测完成，计数器减一</li><li>如果计数为0，执行后面操作</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/11 21:05</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//2个事件请求，这里只演示校验数据行，和数据schema</span></span><br><span class="line">        Event[] events = &#123;<span class="keyword">new</span> Event(<span class="number">1</span>), <span class="keyword">new</span> Event(<span class="number">2</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Event event : events) &#123;</span><br><span class="line">            <span class="comment">//2个事件请求中，可能涉及多个表，可以再分成多个表</span></span><br><span class="line">            List&lt;Table&gt; tables = capture(event);</span><br><span class="line">            <span class="keyword">for</span> (Table table : tables) &#123;</span><br><span class="line">                TaskBatch taskBatch = <span class="keyword">new</span> TaskBatch(<span class="number">2</span>);</span><br><span class="line">                TrustSourceColumns sourceColumns = <span class="keyword">new</span> TrustSourceColumns(table, taskBatch);</span><br><span class="line">                TrustSourceRecordCount recordCount = <span class="keyword">new</span> TrustSourceRecordCount(table, taskBatch);</span><br><span class="line">                service.submit(sourceColumns);</span><br><span class="line">                service.submit(recordCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        Event(<span class="keyword">int</span> id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">done</span><span class="params">(Table table)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskBatch</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        TaskBatch(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">            latch.countDown();</span><br><span class="line">            <span class="keyword">if</span> (latch.getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The table &quot;</span> + table.tableName + <span class="string">&quot; finished work , &quot;</span> + table.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">        String tableName;</span><br><span class="line">        <span class="keyword">long</span> sourceRecordCount;</span><br><span class="line">        <span class="keyword">long</span> targetCount;</span><br><span class="line">        String columnSchema = <span class="string">&quot;columnXXXType = varchar&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String targetColumnSchema = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Table</span><span class="params">(String tableName, <span class="keyword">long</span> sourceRecordCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tableName = tableName;</span><br><span class="line">            <span class="keyword">this</span>.sourceRecordCount = sourceRecordCount;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Table&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;tableName=&#x27;&quot;</span> + tableName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, sourceRecordCount=&quot;</span> + sourceRecordCount +</span><br><span class="line">                    <span class="string">&quot;, targetCount=&quot;</span> + targetCount +</span><br><span class="line">                    <span class="string">&quot;, columnSchema=&#x27;&quot;</span> + columnSchema + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, targetColumnSchema=&#x27;&quot;</span> + targetColumnSchema + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Table&gt; <span class="title">capture</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        List&lt;Table&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Table(<span class="string">&quot;table-&quot;</span> + event.id + <span class="string">&quot;-&quot;</span> + i, i * <span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验数据行数是否一致</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustSourceRecordCount</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Table table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TaskBatch taskBatch;</span><br><span class="line"></span><br><span class="line">        TrustSourceRecordCount(Table table, TaskBatch taskBatch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.table = table;</span><br><span class="line">            <span class="keyword">this</span>.taskBatch = taskBatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            table.targetCount = table.sourceRecordCount;</span><br><span class="line"></span><br><span class="line">            taskBatch.done(table);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验数据列属性以及对应的表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrustSourceColumns</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Table table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TaskBatch taskBatch;</span><br><span class="line"></span><br><span class="line">        TrustSourceColumns(Table table, TaskBatch taskBatch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.table = table;</span><br><span class="line">            <span class="keyword">this</span>.taskBatch = taskBatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            table.targetColumnSchema = table.columnSchema;</span><br><span class="line"></span><br><span class="line">            taskBatch.done(table);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The table table-1-1 finished work , Table&#123;tableName&#x3D;&#39;table-1-1&#39;, sourceRecordCount&#x3D;1000, targetCount&#x3D;1000, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-1-0 finished work , Table&#123;tableName&#x3D;&#39;table-1-0&#39;, sourceRecordCount&#x3D;0, targetCount&#x3D;0, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-2-0 finished work , Table&#123;tableName&#x3D;&#39;table-2-0&#39;, sourceRecordCount&#x3D;0, targetCount&#x3D;0, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-1-2 finished work , Table&#123;tableName&#x3D;&#39;table-1-2&#39;, sourceRecordCount&#x3D;2000, targetCount&#x3D;2000, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-1-3 finished work , Table&#123;tableName&#x3D;&#39;table-1-3&#39;, sourceRecordCount&#x3D;3000, targetCount&#x3D;3000, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-2-1 finished work , Table&#123;tableName&#x3D;&#39;table-2-1&#39;, sourceRecordCount&#x3D;1000, targetCount&#x3D;1000, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-2-2 finished work , Table&#123;tableName&#x3D;&#39;table-2-2&#39;, sourceRecordCount&#x3D;2000, targetCount&#x3D;2000, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line">The table table-2-3 finished work , Table&#123;tableName&#x3D;&#39;table-2-3&#39;, sourceRecordCount&#x3D;3000, targetCount&#x3D;3000, columnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;, targetColumnSchema&#x3D;&#39;columnXXXType &#x3D; varchar&#39;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="利用CountDownLatch实现回调函数"><a href="#利用CountDownLatch实现回调函数" class="headerlink" title="利用CountDownLatch实现回调函数"></a>利用CountDownLatch实现回调函数</h2><p><strong>实现：</strong></p><ul><li>在每个线程使计数器减一的时候，利用getCount判断，当前是否所有线程任务执行完成</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCountDownLatch</span> <span class="keyword">extends</span> <span class="title">CountDownLatch</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCountDownLatch</span><span class="params">(<span class="keyword">int</span> count,Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(count);</span><br><span class="line">            <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.countDown();</span><br><span class="line">            <span class="keyword">if</span> (getCount()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MyCountDownLatch latch = <span class="keyword">new</span> MyCountDownLatch(<span class="number">2</span>, ()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;All of work finish done. This is call back.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(getName() +  <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(getName() +  <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><ul><li><p>栅栏类似于闭锁（CountDownLatch），它能阻塞一组线程直到某个事件的发生。栅栏与闭锁的关键区别在于， <strong>所有的线程必须同时到达栅栏位置，才能继续执行</strong>。闭锁用于等待事件，而 <strong>栅栏用于等待其他线程</strong>。</p></li><li><p>CyclicBarrier可以使一定数量的线程反复地在栅栏位置处汇集。 <strong>当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。</strong> 如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _05_AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 10:34</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video33</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,() -&gt; System.out.println(<span class="string">&quot;收集到7颗龙珠,召唤神龙&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> temp = i + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t收集到第&quot;</span> + temp + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">int</span> await = cyclicBarrier.await();</span><br><span class="line">                     System.out.println(<span class="string">&quot;还剩几个:&quot;</span> + await);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,<span class="string">&quot;线程&quot;</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程0收集到第1颗龙珠</span><br><span class="line">线程2收集到第3颗龙珠</span><br><span class="line">线程3收集到第4颗龙珠</span><br><span class="line">线程1收集到第2颗龙珠</span><br><span class="line">线程4收集到第5颗龙珠</span><br><span class="line">线程5收集到第6颗龙珠</span><br><span class="line">线程6收集到第7颗龙珠</span><br><span class="line">收集到7颗龙珠,召唤神龙</span><br><span class="line">还剩几个:0</span><br><span class="line">还剩几个:6</span><br><span class="line">还剩几个:3</span><br><span class="line">还剩几个:4</span><br><span class="line">还剩几个:5</span><br><span class="line">还剩几个:1</span><br><span class="line">还剩几个:2</span><br></pre></td></tr></table></figure><p>可以明显的看到cyclicBarrier会阻塞所有线程，和countdownlatch不一样。</p><h2 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>parties</code> 是参与线程的个数</li><li>第二个构造方法有一个 <code>Runnable</code> 参数，这个参数的意思是 *<em>最后一个到达线程要做的任务</em></li></ul><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br></pre></td></tr></table></figure><ul><li>线程调用 await() <strong>表示自己已经到达栅栏</strong></li><li>BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</li></ul><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>将屏障重置为初始状态。 如果任何一方正在等待屏障，他们将返回 <strong>BrokenBarrierException</strong> 。</li><li>这样就可以重复利用这个屏障</li></ul><h2 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h2><ul><li><code>CountDownLatch</code> 是一次性的。 <code>CyclicBarrier</code> 是可循环利用的</li><li><code>CountDownLatch</code> 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。 <code>CyclicBarrier</code> 参与的线程职责是一样的</li></ul><blockquote><p>牛客-京东2019春招Java开发笔试卷-T27</p></blockquote><blockquote><p><a href="https://blog.csdn.net/liangyihuai/article/details/83106584">https://blog.csdn.net/liangyihuai/article/details/83106584</a></p></blockquote><p>从jdk作者设计的目的来看，javadoc是这么描述它们的：</p><ul><li>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. </li><li>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  </li><li>从javadoc的描述可以得出： CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行； CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。 </li><li>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。 而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须互相等待，然后继续一起执行。 CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。 按照这个题目的描述等所有线程都到达了这一个阀门处，再一起执行，此题强调的是，一起继续执行，我认为 选B 比较合理！  </li></ul><ul><li><p>像上文中CountDownLatch的例子，main线程在等待，其余6个线程任务做完之后，main线程才苏醒干后面的事。因为countdown只会阻塞调用者，其它线程干完任务就可以干其他事。这里的调用者线程就是main线程。</p></li><li><p>像上文中CyclicBarrier的例子，是7个线程互相等待对方，7个任务都完成后，执行注册的回调任务。</p></li></ul><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul><li>用于两个工作线程之间交换数据的封装工具类</li><li>简单说就是一个线程在完成一定的事务后想与另一个线程交换数据，则 *<em>第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据</em></li></ul><p><code>Exchanger&lt;v&gt;&lt;/v&gt;</code> 泛型类型，其中 <strong>V 表示可交换的数据类型</strong></p><h2 id="简单的应用"><a href="#简单的应用" class="headerlink" title="简单的应用"></a>简单的应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/11 21:05</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start . &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果这里睡200ms的话，应该是B线程先拿出数据，然后B线程等待A线程。因为是B先给的数据，</span></span><br><span class="line"><span class="comment">                 * 所以最后A线程会先拿到B给的数据，也就是先打印</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;I am come from T-A&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get value : &quot;</span> + exchange);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end . &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start . &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;I am come from T-B&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get value : &quot;</span> + exchange);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end . &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A start . </span><br><span class="line">B start . </span><br><span class="line">A get value : I am come from T-B</span><br><span class="line">B get value : I am come from T-A</span><br><span class="line">B end . </span><br><span class="line">A end . </span><br></pre></td></tr></table></figure><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><ul><li>等待另一个线程到达此交换点，然后将给定对象传输给它，接收其对象作为回报。</li><li>可以被打断</li><li>如果已经有个线程正在等待了，则直接交换数据</li></ul><h2 id="数据的分析"><a href="#数据的分析" class="headerlink" title="数据的分析"></a>数据的分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/11 21:05</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;Object&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Object Aobj = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;A将会发送：&quot;</span> + Aobj);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object Robj = exchanger.exchange(Aobj);</span><br><span class="line">                System.out.println(<span class="string">&quot;A接收的：&quot;</span> + Robj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Object Bobj = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;B将会发送：&quot;</span> + Bobj);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object Robj = exchanger.exchange(Bobj);</span><br><span class="line">                System.out.println(<span class="string">&quot;B接收的：&quot;</span> + Robj);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A将会发送：java.lang.Object@7be2d776</span><br><span class="line">B将会发送：java.lang.Object@5eca8d3a</span><br><span class="line">B接收的：java.lang.Object@7be2d776</span><br><span class="line">A接收的：java.lang.Object@5eca8d3a</span><br></pre></td></tr></table></figure><p><strong>从这个例子可以看出一个很严重的问题</strong>：发送的对象和接收的对象是同一个对象，可能会用严重的线程安全问题。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>当多个线程需要访问某个公共资源的时候，我们知道需要通过加锁来保证资源的访问不会出问题。java提供了两种方式来加锁：</p><ul><li>一种是关键字： <code>synchronized</code>，一种是concurrent包下的基于API实现的。</li><li>synchronized是 JVM底层支持的，而concurrent包则是 <code>jdk</code>实现。</li></ul><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul><li><p>当有线程竞争锁时，当前线程会首先尝试获得锁而不是在队列中进行排队等候，这对于那些已经在队列中排队的线程来说显得不公平，这也是非公平锁的由来</p></li><li><p>默认情况下为非公平锁。</p></li><li><p>锁的存储结构就两个东西:”双向链表” + “int类型状态”。ReenTrantLock的实现是一种自旋锁， 通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p></li></ul><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>fair</code>：该参数为true时，会尽力维持公平</li></ul><h2 id="获得锁"><a href="#获得锁" class="headerlink" title="获得锁"></a>获得锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span>  <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p><strong>lock</strong></p><ul><li>正常的获取锁，如果没有获得到锁，就会被阻塞</li></ul><p><strong>lockInterruptibly</strong></p><ul><li>获取锁，如果没有获得到锁，就会被阻塞</li><li>可以被打断</li></ul><p><strong>tryLock</strong></p><ul><li>如果获得到锁，返回true</li><li>如果没有获得到锁，返回false</li><li><code>timeout</code>：表示等待的时间</li><li><code>tryLock()</code>在获取的锁的时候，不会考虑此时是否有其他线程在等待，会破坏公平。</li><li>如果你希望遵守公平设置此锁，然后用 <code>tryLock(0, TimeUnit.SECONDS)</code> 这几乎是等效的（它也检测中断）。</li></ul><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>尝试释放此锁。</li><li>必须是锁的持有者才能释放锁</li></ul><h2 id="锁的调试"><a href="#锁的调试" class="headerlink" title="锁的调试"></a>锁的调试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>getOwner</strong></p><ul><li>返回持有锁的线程</li></ul><p><strong>hasQueuedThreads</strong></p><ul><li>是否有线程在等待获取锁</li></ul><p><strong>getQueueLength</strong></p><ul><li>获取等待锁的线程数目</li></ul><p><strong>getQueuedThreads</strong></p><ul><li>返回正在等待的线程集合</li></ul><h2 id="Lock和synchronized的区别"><a href="#Lock和synchronized的区别" class="headerlink" title="Lock和synchronized的区别"></a>Lock和synchronized的区别</h2><p><strong>底层实现</strong>：</p><ul><li>Lock基于 <code>AQS</code>实现，通过state和一个CLH队列来维护锁的获取与释放</li><li>synchronized需要通过 <code>monitor</code>，经历一个从用户态到内核态的转变过程，更加耗时</li></ul><p><strong>其他区别</strong></p><table><thead><tr><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>是java内置关键字，在jvm层面</td><td>是个java类</td></tr><tr><td>无法判断是否获取锁的状态</td><td>可以判断是否获取到锁</td></tr><tr><td>会自动释放锁</td><td>需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁</td></tr><tr><td>线程会一直等待下去</td><td>如果尝试获取不到锁，线程可以不用一直等待就结束</td></tr></tbody></table><p><strong>总结来说</strong><br>synchronized的锁可重入、不可中断、非公平。而Lock锁可重入、可判断、可公平（两者皆可）。</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><ul><li><p>Semaphore是一种在多线程环境下使用的设施，该设施负责协调各个线程，以<strong>保证它们能够正确、合理的使用公共资源的设施</strong>，也是操作系统中用于控制进程同步互斥的量。</p></li><li><p>Semaphore是一种计数信号量，用于管理一组资源，内部是基于AQS的共享模式。<strong>它相当于给线程规定一个量从而控制允许活动的线程数</strong>。</p></li><li><p>Semaphore用于限制可以访问某些资源（物理或逻辑的）的线程数目，他维护了一个许可证集合，有多少资源需要限制就维护多少许可证集合，假如这里有N个资源，那就对应于N个许可证，同一时刻也只能有N个线程访问。</p></li><li><p>一个线程获取许可证就调用acquire方法，用完了释放资源就调用release方法。</p></li></ul><p>除了JDK定义的哪些锁，Semaphore也可以定义锁。Semaphore可以做的功能相当的多，比如秒杀限流</p><h2 id="用Semaphore自定义Lock"><a href="#用Semaphore自定义Lock" class="headerlink" title="用Semaphore自定义Lock"></a>用Semaphore自定义Lock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreLock lock = <span class="keyword">new</span> SemaphoreLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; release the lock.&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>结果</strong></p><blockquote><p>Thread-0 get the lock.<br>Thread-0 release the lock.<br>Thread-1 get the lock.<br>Thread-1 release the lock.</p></blockquote><p><strong>跟synchronized的区别</strong></p><ul><li>  可以看出最大的区别就是可以控制多个线程访问多份资源，而不是只用一个线程访问一份资源</li></ul><h2 id="用Semaphore做限流"><a href="#用Semaphore做限流" class="headerlink" title="用Semaphore做限流"></a>用Semaphore做限流</h2><p>Semaphore可以控制多个线程访问多份资源，而不是只用一个线程访问一份资源，所以在限流方面也有应用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _05_AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 10:58</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video34</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     semaphore.acquire();</span><br><span class="line">                     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 进入抢购秒杀页面，准备抢小米9&quot;</span>);</span><br><span class="line">                     <span class="comment">//停3秒后离开</span></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                         e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line">                     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 离开抢购秒杀页面，成功抢到小米9&quot;</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                     semaphore.release();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,<span class="string">&quot;用户&quot;</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户0 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户2 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户1 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户1 离开抢购秒杀页面，成功抢到小米9</span><br><span class="line">用户2 离开抢购秒杀页面，成功抢到小米9</span><br><span class="line">用户0 离开抢购秒杀页面，成功抢到小米9</span><br><span class="line">用户4 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户3 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户5 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户3 离开抢购秒杀页面，成功抢到小米9</span><br><span class="line">用户4 离开抢购秒杀页面，成功抢到小米9</span><br><span class="line">用户6 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户8 进入抢购秒杀页面，准备抢小米9</span><br><span class="line">用户5 离开抢购秒杀页面，成功抢到小米9</span><br><span class="line">用户7 进入抢购秒杀页面，准备抢小米9</span><br></pre></td></tr></table></figure><p>代码里限制了资源为3个，所以同一时间段只能有3个线程进来抢购小米9手机。</p><h2 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits , <span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure><ul><li>  <code>permits</code>：同一时间可以访问资源的线程数目</li><li>  <code>fair</code>：尽可能的保证公平</li></ul><h3 id="重要方法-1"><a href="#重要方法-1" class="headerlink" title="重要方法"></a>重要方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>acquire()</code>：<strong>获取一个许可证</strong>，如果许可证用完了，则陷入阻塞。可以被打断。</p></li><li><p><code>release()</code>：<strong>释放一个许可证</strong></p><p><code>acquire(int permits)</code><br><code>public void release(int permits)</code></p></li></ul><p><strong>acquire多个时，如果没有足够的许可证可用，那么当前线程将被禁用以进行线程调度</strong>，并且处于休眠状态，直到发生两件事情之一：</p><ul><li>  一些其他线程调用此信号量的一个release方法，当前线程旁边将分配许可证，并且可用许可证的数量满足此请求;</li><li>  要么一些其他线程interrupts当前线程。</li></ul><p><strong>release多个时，会使许可证增多，最终可能超过初始值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                   <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><ul><li>  尝试去拿，<strong>拿到返回true</strong></li></ul><h3 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li><p>返回此信号量中当前可用的许可数。</p><p><code>protected Collection&lt;Thread&gt; getQueuedThreads()</code><br>public final int getQueueLength()</p></li><li><p><code>getQueuedThreads</code>返回正在阻塞的线程集合</p></li><li><p><code>getQueueLength</code>返回阻塞获取的线程数</p><p><code>public void acquireUninterruptibly()</code><br><code>public void acquireUninterruptibly(int permits)</code></p></li><li><p>可以<code>不被打断</code>获取许可证</p><p><code>public int drainPermits()</code></p></li><li><p>获取当前全部的许可证目标</p></li></ul><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><ul><li>Condition主要是用于线程通信的，也就是和Object类的wait，notify有同样的功能。不过Condition的功能更加多样，Conditon可以绑定锁，实现选择性唤醒。</li><li>Condition和Lock搭配使用; condition必须使用<code>lock.newCondition();</code>来创建condition。必须存放在Lock中。否则抛出异常。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _07_LockAndCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 15:41</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: A线程打印3次,B线程打印6次,C线程9次，持续两轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                shareResource.print3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                shareResource.print6();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                shareResource.print9();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以前是一个lock只有一个钥匙,现在是一个lock多个钥匙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span></span>&#123;</span><br><span class="line">    <span class="comment">//标志位,可取值为1,2,3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">1</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            c2.signal();<span class="comment">//唤醒2号线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">2</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            c3.signal();<span class="comment">//唤醒3号线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print9</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">3</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            c1.signal();<span class="comment">//唤醒1号线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A1</span><br><span class="line">A2</span><br><span class="line">A3</span><br><span class="line">B1</span><br><span class="line">B2</span><br><span class="line">B3</span><br><span class="line">B4</span><br><span class="line">B5</span><br><span class="line">B6</span><br><span class="line">C1</span><br><span class="line">C2</span><br><span class="line">C3</span><br><span class="line">C4</span><br><span class="line">C5</span><br><span class="line">C6</span><br><span class="line">C7</span><br><span class="line">C8</span><br><span class="line">C9</span><br><span class="line">A1</span><br><span class="line">A2</span><br><span class="line">A3</span><br><span class="line">B1</span><br><span class="line">B2</span><br><span class="line">B3</span><br><span class="line">B4</span><br><span class="line">B5</span><br><span class="line">B6</span><br><span class="line">C1</span><br><span class="line">C2</span><br><span class="line">C3</span><br><span class="line">C4</span><br><span class="line">C5</span><br><span class="line">C6</span><br><span class="line">C7</span><br><span class="line">C8</span><br><span class="line">C9</span><br></pre></td></tr></table></figure><h2 id="Condition版生产者消费者"><a href="#Condition版生产者消费者" class="headerlink" title="Condition版生产者消费者"></a>Condition版生产者消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 15:03</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: 使用Lock和Condition实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer_04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer4 consumer = <span class="keyword">new</span> Consumer4();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者线程A</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer4</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + num);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantReadWriteLock读写锁"><a href="#ReentrantReadWriteLock读写锁" class="headerlink" title="ReentrantReadWriteLock读写锁"></a>ReentrantReadWriteLock读写锁</h1><p>读写锁的目的是为了让读 — 读之间不加锁</p><table><thead><tr><th>冲突</th><th>策略</th></tr></thead><tbody><tr><td>读 — 读</td><td>并行化</td></tr><tr><td>读 — 写</td><td>串行化</td></tr><tr><td>写 — 读</td><td>串行化</td></tr><tr><td>写 — 写</td><td>串行化</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _05_AQS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: youthlql-吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/26 10:58</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video34</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;write(),<span class="string">&quot;write-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">&quot;read-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;read(),<span class="string">&quot;read-2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            data.add(<span class="string">&quot;数据XXX&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;写锁释放&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            readLock.lock();</span><br><span class="line">            <span class="keyword">for</span> (String datum : data) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读入：&quot;</span>+datum);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读锁释放&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写锁释放</span><br><span class="line">read-1 读入：数据XXX</span><br><span class="line">read-2 读入：数据XXX</span><br><span class="line">读锁释放</span><br><span class="line">读锁释放</span><br></pre></td></tr></table></figure><p>可以看到读写-串行化，读读可以并发。</p><h1 id="StampedLock读写锁"><a href="#StampedLock读写锁" class="headerlink" title="StampedLock读写锁"></a>StampedLock读写锁</h1><h2 id="ReadWriteLock出现的问题"><a href="#ReadWriteLock出现的问题" class="headerlink" title="ReadWriteLock出现的问题"></a>ReadWriteLock出现的问题</h2><p>1、深入分析ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写线程去抢锁，这是一种悲观的读锁，会出现写饥饿。</p><p>2、有100个线程访问某个资源，如果有99线程个需要读锁，1个线程需要写锁，此时，写的线程很难得到执行。</p><h2 id="StampedLock改进"><a href="#StampedLock改进" class="headerlink" title="StampedLock改进"></a>StampedLock改进</h2><p>3、StampedLock和ReadWriteLock相比，改进之处在于：<code>读的过程中也允许获取写锁后写入</code> 。这样一来，我们读的数据就可能不一致，所以，<strong>需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁</strong>。</p><p>4、乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><h2 id="用StampedLock去悲观的读"><a href="#用StampedLock去悲观的读" class="headerlink" title="用StampedLock去悲观的读"></a>用StampedLock去悲观的读</h2><p>StampedLock可以完全实现ReadWriteLock的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer DATA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = stampedLock.writeLock();<span class="comment">// 获取写锁</span></span><br><span class="line">            DATA++;</span><br><span class="line">            System.out.println(<span class="string">&quot;写--&gt;&quot;</span> + DATA);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = stampedLock.readLock();<span class="comment">// 获取悲观读锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读--&gt;&quot;</span> + DATA);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//写任务</span></span><br><span class="line">        Runnable writeTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//读任务</span></span><br><span class="line">        Runnable readTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个线程写，9个线程读</span></span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(writeTask);<span class="comment">//写线程要写最后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>独线程一旦先执行，写线程很难再获得锁</p><blockquote><p>输出结果：</p><p>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>读–&gt;0<br>写–&gt;1</p></blockquote><h2 id="用StampedLock去乐观的读"><a href="#用StampedLock去乐观的读" class="headerlink" title="用StampedLock去乐观的读"></a>用StampedLock去乐观的读</h2><p>只需要改一下read()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer DATA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = stampedLock.writeLock();<span class="comment">// 获取写锁</span></span><br><span class="line">            DATA++;</span><br><span class="line">            System.out.println(<span class="string">&quot;写--&gt;&quot;</span> + DATA);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这块可能会有写锁抢锁，修改数据，所以用validate检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、在这块可能会有写锁抢锁，修改数据，所以用validate检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line"><span class="comment">         * 判断执行读操作期间,是否存在写操作,如果存在则validate返回false</span></span><br><span class="line"><span class="comment">         * 2、如果有写锁抢锁，修改了数据，那么就要获取悲观锁。因为写锁在修改数据的过程中，你不能直接</span></span><br><span class="line"><span class="comment">         * 去读，只能老老实实拿到读锁再去读，才不会发生线程安全问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;<span class="comment">//检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stamp = stampedLock.readLock();<span class="comment">// 获取悲观读锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;悲观读--&gt;&quot;</span> + DATA);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;乐观读--&gt;&quot;</span> + DATA);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//写任务</span></span><br><span class="line">        Runnable writeTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//读任务</span></span><br><span class="line">        Runnable readTask = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个线程写，9个线程读</span></span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(readTask);</span><br><span class="line">        executor.submit(writeTask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>悲观读–&gt;704<br>写–&gt;705<br>写–&gt;706<br>写–&gt;707<br>悲观读–&gt;707<br>写–&gt;708<br>悲观读–&gt;708<br>写–&gt;709<br>写–&gt;710<br>悲观读–&gt;710<br>乐观读–&gt;710<br>乐观读–&gt;690<br>乐观读–&gt;690<br>乐</p></blockquote><h1 id="ForkJoin框架"><a href="#ForkJoin框架" class="headerlink" title="ForkJoin框架"></a>ForkJoin框架</h1><p>思想：分而治之。将一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><p><strong>举例说明</strong></p><p>1、我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p><p>2、还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p><p>3、如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p><p>这就是Fork/Join任务的原理：判断一个任务是否足够小。如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p><p><strong>编码实现</strong></p><p><strong>整个任务流程如下所示</strong>：</p><ul><li>首先继承任务，覆写任务的执行方法</li><li>通过判断阈值，判断该线程是否可以执行</li><li>如果不能执行，则将任务继续递归分配，利用fork方法，并行执行</li><li>如果是有返回值的，才需要调用join方法，汇集数据。</li></ul><p><strong>主要的两个类：</strong></p><ul><li><code>RecursiveAction</code> 一个递归无结果的ForkJoinTask（没有返回值）</li><li><code>RecursiveTask</code> 一个递归有结果的ForkJoinTask（有返回值）</li></ul><h2 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinRecursiveTask</span>  </span>&#123;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   1、分到哪种程度可以不用分了</span></span><br><span class="line"><span class="comment">   2、也就是设置一个任务处理最大的阈值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRESHOLD = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool joinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future = joinPool.submit(<span class="keyword">new</span> CalculatedRecursiveTask(<span class="number">0</span>, <span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer integer = future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;执行结果：&quot;</span> + integer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatedRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;<span class="comment">//任务开始的上标</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;<span class="comment">//任务开始的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CalculatedRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= MAX_THRESHOLD) &#123;<span class="comment">//如果自己能处理，就自己计算</span></span><br><span class="line">                <span class="keyword">return</span> IntStream.rangeClosed(start, end).sum();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//自己处理不了，拆分任务</span></span><br><span class="line">                <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">                CalculatedRecursiveTask leftTask = <span class="keyword">new</span> CalculatedRecursiveTask(start, middle);</span><br><span class="line">                CalculatedRecursiveTask rightTask = <span class="keyword">new</span> CalculatedRecursiveTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//分别去执行</span></span><br><span class="line">                leftTask.fork();</span><br><span class="line">                rightTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把返回结果合起来</span></span><br><span class="line">                <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是有返回值的</p><h2 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h2><p>这个是没有返回值的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinRecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRESHOLD = <span class="number">3</span>;<span class="comment">//设置一个任务处理最大的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger SUM = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        forkJoinPool.submit(<span class="keyword">new</span> CalculateRecursiveAction(<span class="number">0</span>,<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务执行需要事件，这里可以等一下</span></span><br><span class="line">        forkJoinPool.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果为：&quot;</span> + SUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateRecursiveAction</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CalculateRecursiveAction</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((end-start)&lt;=MAX_THRESHOLD)&#123;</span><br><span class="line">                SUM.addAndGet(IntStream.rangeClosed(start,end).sum());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">                CalculateRecursiveAction leftAction = <span class="keyword">new</span> CalculateRecursiveAction(start,middle);</span><br><span class="line">                CalculateRecursiveAction rightAction = <span class="keyword">new</span> CalculateRecursiveAction(middle+<span class="number">1</span>,end);</span><br><span class="line">                leftAction.fork();</span><br><span class="line">                rightAction.fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>整个流程需要三个类完成</strong>：</p><p>1、<strong>ForkJoinPool</strong></p><ul><li><p>既然任务是被逐渐的细化的，那就需要把这些任务存在一个池子里面，这个池子就是ForkJoinPool。</p></li><li><p>它与其它的ExecutorService区别主要在于它使用**”工作窃取”**，那什么是工作窃取呢？</p></li><li><p>工作窃取：一个大任务会被划分成无数个小任务，这些任务被分配到不同的队列，这些队列有些干活干的块，有些干得慢。于是干得快的，一看自己没任务需要执行了，就去隔壁的队列里面拿去任务执行。</p></li></ul><p>2、<strong>ForkJoinTask</strong></p><p>ForkJoinTask就是ForkJoinPool里面的每一个任务。他主要有两个子类：<code>RecursiveAction</code>和<code>RecursiveTask</code>。然后通过fork()方法去分配任务执行任务，通过join()方法汇总任务结果。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Third_stage/0001.png"><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</li><li>ForkJoinPool线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自RecursiveTask或RecursiveAction。</li><li>使用Fork/Join模式可以进行并行计算以提高效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第二阶段-锁与同步-[3]</title>
      <link href="post/113a3931.html"/>
      <url>post/113a3931.html</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized保证三大特性"><a href="#synchronized保证三大特性" class="headerlink" title="synchronized保证三大特性"></a>synchronized保证三大特性</h1><p><strong>synchronized保证原子性的原理</strong></p><p>对num++;增加同步代码块后，保证同一时间只有一个线程操作num++;。就不会出现安全问题。</p><p><strong>synchronized保证可见性的原理</strong></p><p>synchronized保证可见性的原理，执行synchronized时，会对应lock原子操作会刷新工作内存中共享变 量的值。</p><p><strong>synchronized保证有序性的原理</strong></p><p>我们加synchronized后，依然会发生重排序，只不过我们有同步 代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性。</p><h1 id="synchronized的特性"><a href="#synchronized的特性" class="headerlink" title="synchronized的特性"></a>synchronized的特性</h1><h2 id="可重入特性"><a href="#可重入特性" class="headerlink" title="可重入特性"></a>可重入特性</h2><p>意思就是一个线程可以多次执行synchronized,重复获取同一把锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示synchronized可重入</span></span><br><span class="line"><span class="comment">        1.自定义一个线程类</span></span><br><span class="line"><span class="comment">        2.在线程类的run方法中使用嵌套的同步代码块</span></span><br><span class="line"><span class="comment">        3.使用两个线程来执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name + <span class="string">&quot;进入了同步代码块2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.自定义一个线程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;进入了同步代码块1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Demo01.test01();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可重入原理</strong></p><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁.。在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。可重入的好处</p><ol><li>可以避免死锁</li><li>可以让我们更好的来封装代码</li></ol><h2 id="不可中断特性"><a href="#不可中断特性" class="headerlink" title="不可中断特性"></a>不可中断特性</h2><p><strong>什么是不可中断</strong></p><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第 二个线程会一直阻塞或等待，不可被中断。</p><h3 id="synchronized不可中断演示"><a href="#synchronized不可中断演示" class="headerlink" title="synchronized不可中断演示"></a>synchronized不可中断演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.定义一个Runnable</span></span><br><span class="line">        Runnable run = () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2.在Runnable定义同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;进入同步代码块&quot;</span>);</span><br><span class="line">                <span class="comment">// 保证不退出同步代码块</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.先开启一个线程来执行同步代码块</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 4.后开启一个线程来执行同步代码块(阻塞状态)</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.停止第二个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><blockquote><p>Thread-0进入同步代码块<br>停止线程前<br>停止线程后<br>TIMED_WAITING<br>BLOCKED</p></blockquote><h3 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        test01();</span></span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Lock可中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable run = () -&gt; &#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;获得锁,进入锁执行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;在指定时间没有得到锁做其他操作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Lock不可中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable run = () -&gt; &#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;获得锁,进入锁执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><blockquote><p>Thread-0获得锁,进入锁执行<br>停止t2线程前<br>停止t2线程后<br>java.lang.InterruptedException </p><p>atjava.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireNanos(AbstractQueuedSynchronizer.java:1245)<br>    at java.util.concurrent.locks.ReentrantLock.tryLock(ReentrantLock.java:442)<br>    at Test.lambda$test02$0(Test.java:24)<br>    at java.lang.Thread.run(Thread.java:748)<br>TIMED_WAITING<br>TERMINATED</p></blockquote><p>关于ReentranLock锁中断的原理，在AQS里讲。</p><h1 id="synchronized简单原理"><a href="#synchronized简单原理" class="headerlink" title="synchronized简单原理"></a>synchronized简单原理</h1><blockquote><p>我相信这个原理大部分人应该都知道，很多资料都讲过，我这里简单描述一下。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap对其进行反汇编，部分信息如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter   <span class="comment">// monitorenter指令进入同步块</span></span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit  <span class="comment">// monitorexit指令退出同步块</span></span><br><span class="line">        <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">        <span class="number">17</span>: astore_2</span><br><span class="line">        <span class="number">18</span>: aload_1</span><br><span class="line">        <span class="number">19</span>: monitorexit  <span class="comment">// monitorexit指令退出同步块</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: athrow</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">            <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED      <span class="comment">//添加了ACC_SYNCHRONIZED标记</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #5                  // String hello method</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized修饰代码块时"><a href="#synchronized修饰代码块时" class="headerlink" title="synchronized修饰代码块时"></a>synchronized修饰代码块时</h2><h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><p>首先我们来看一下JVM规范中对于monitorenter的描述： <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p><blockquote><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref， as follows: • If the entry count of the monitor associated with objectref is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. • If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count. • If another thread already owns the monitor associated with objectref， the thread blocks until the monitor’s entry count is zero， then tries again to gain ownership.</p></blockquote><p>翻译过来： 每一个对象都会和一个监视器monitor关联。监视器被占用时会被锁住，其他线程无法来获 取该monitor。 当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应 的monitor的所有权。其过程如下：</p><ol><li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为 monitor的owner（所有者）</li><li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直 到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ol><p>monitorenter小结: synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个 同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有 这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待</p><h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><p>首先我们来看一下JVM规范中对于monitorexit的描述： <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p><blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p>翻译过来：</p><p>1.能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。</p><ol><li>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出 monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个 monitor的所有权</li></ol><p>monitorexit释放锁。 monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit。</p><p><strong>总结</strong>：synchronized在修饰代码块时，是通过<code>monitorenter</code> 和 <code>monitorexit</code>来保证并发安全。</p><h2 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h2><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h1 id="Java对象的布局（C-代码层面）"><a href="#Java对象的布局（C-代码层面）" class="headerlink" title="Java对象的布局（C++代码层面）"></a>Java对象的布局（C++代码层面）</h1><blockquote><p>在学习synchronized最底层的C++源码级别前，我们需要先了解这个知识点，不然后面的可能看不懂</p></blockquote><p>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a> 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0021.png"><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是 存在锁对象的对象头中的。 HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型。instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp </p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0022.png"><p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot 源码中的 oop.hpp 文件中。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0023.png"><ul><li><p>在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark 和 _metadata</p></li><li><p>_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息</p></li><li><p>_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示 普通指针、 _compressed_klass 表示压缩类指针。</p></li><li><p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指 针，及对象指向它的类元数据的指针。</p></li></ul><blockquote><p>关于Klass，Class这些JVM的东西，推荐去看《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》。强调一点，是第三版。第三版相比第二版改了太多东西了，我看第二版的时候总感觉讲的不够深入缺点什么东西，不过第三版补齐了很多东西。</p></blockquote><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word对应的类 型是 markOop 。源码位于 markOop.hpp 中。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0024.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0025.png"><p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0026.png"><p>在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0027.png"><p>再加一个图对比一下，有一丁点的补充</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0028.png"><h3 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h3><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的 实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 如果应用的对 象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内 存。为了节约内存可以使用选项**-XX:+UseCompressedOops** 开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：</p><ol><li>每个Class的属性指针（即静态变量）</li><li>每个对象的属性指针（即对象变量）</li><li>普通对象数组的每个元素指针</li></ol><p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对 象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。 对象头 = Mark Word + 类型指针（未开启指针压缩的情况下） 在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits； 在64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>就是类中定义的成员变量。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的 自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是<strong>8字节的 整数倍</strong>。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充 来补全。</p><h2 id="查看Java对象布局的方法"><a href="#查看Java对象布局的方法" class="headerlink" title="查看Java对象布局的方法"></a>查看Java对象布局的方法</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    </span><br><span class="line">&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;    </span><br><span class="line">&lt;artifactId&gt;jol-core&lt;/artifactId&gt;    </span><br><span class="line">&lt;version&gt;0.9&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="Lock-Record"><a href="#Lock-Record" class="headerlink" title="Lock Record"></a>Lock Record</h1><p>字面意思就是锁记录。通过对Java对象头的介绍可以看到锁信息也是存在于对象的<code>mark word</code>中的。当对象状态为偏向锁（biasable）时，<code>mark word</code>存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p><h2 id="Lock-Record的结构"><a href="#Lock-Record的结构" class="headerlink" title="Lock Record的结构"></a>Lock Record的结构</h2><p>线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个<code>Lock Record</code>，其包括一个用于存储对象头中的 <code>mark word</code>（官方称之为<code>Displaced Mark Word</code>）以及一个指向对象的指针。下图右边的部分就是一个<code>Lock Record</code>。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0029.png"><h1 id="synchronized偏向锁原理（C-源码层面）"><a href="#synchronized偏向锁原理（C-源码层面）" class="headerlink" title="synchronized偏向锁原理（C++源码层面）"></a>synchronized偏向锁原理（C++源码层面）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1、偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。 偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对 象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID即可。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>Java是支持多线程的语言，因此在很多基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如<code>synchronized</code>这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo Demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            Demo.add(<span class="string">&quot;Demo---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个demo中为了保证对list操纵时线程安全，对add方法加了<code>synchronized</code>的修饰，但实际使用时却只有一个线程调用到该方法。对于轻量级锁而言，每次调用add时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的一个和多个 只是针对该demo，并不适用于所有场景）。</p><h2 id="对象的Mark-Word"><a href="#对象的Mark-Word" class="headerlink" title="对象的Mark Word"></a>对象的Mark Word</h2><ul><li>偏向锁在Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用-XX:BiasedLockingStartupDelay=0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争 状态，可以通过 XX:-UseBiasedLocking=false 参数关闭偏向锁。</li><li>当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的），那新创建对象的<code>mark word</code>将是可偏向状态，此时<code>mark word中</code>的thread id（参见上文偏向状态下的<code>mark word</code>格式）为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</li></ul><h2 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h2><blockquote><p>偏向锁加锁的C++代码过于复杂，这里只是用文字描述了几种情况。正常面试的时候，也不会让你说C++代码执行过程。</p></blockquote><p>加锁过程分为几种情况（case），注意下面的不是顺序，只是加锁的几种情况。</p><p>case 1：当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将<code>mark word</code>中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</p><p>case 2：当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后，会往当前线程的栈中添加一条<code>Displaced Mark Word</code>为空的<code>Lock Record</code>中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，<code>synchronized</code>关键字带来的性能开销基本可以忽略。</p><p>case 3：当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到<strong>撤销偏向锁</strong>的逻辑里，一般来说，会在<code>safepoint</code>中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（unlocked），之后再升级为轻量级锁。</p><h2 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h2><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的<strong>最近一条</strong><code>lock record</code>的<code>obj</code>字段设置为null。偏向锁的解锁步骤中<strong>并不会修改对象头中的thread id。</strong></p><h2 id="偏向锁升级时机"><a href="#偏向锁升级时机" class="headerlink" title="偏向锁升级时机"></a>偏向锁升级时机</h2><p>一般来说（批量重偏向除外），偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。</p><h2 id="偏向锁撤销过程"><a href="#偏向锁撤销过程" class="headerlink" title="偏向锁撤销过程"></a>偏向锁撤销过程</h2><p>这里说的撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程。</p><blockquote><p>撤销逻辑有很多，我们只分析最常见的情况：假设锁已经偏向线程A，这时B线程尝试获得锁。</p></blockquote><ol><li>查看偏向的线程是否存活，如果已经不存活了，则直接撤销偏向锁。JVM维护了一个集合存放所有存活的线程，通过遍历该集合判断某个线程是否存活。</li><li>偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。我们回顾一下偏向锁的加锁流程：每次进入同步块（即执行<code>monitorenter</code>）的时候都会以从高往低的顺序在栈中找到第一个可用的<code>Lock Record</code>，将其obj字段指向锁对象。每次解锁（即执行<code>monitorexit</code>）的时候都会将最低的一个相关<code>Lock Record</code>移除掉。所以可以通过遍历线程栈中的<code>Lock Record</code>来判断线程是否还在同步块中。</li><li>将偏向线程所有相关<code>Lock Record</code>的<code>Displaced Mark Word</code>设置为null，然后将最高位的<code>Lock Record</code>的<code>Displaced Mark Word</code> 设置为无锁状态，最高位的<code>Lock Record</code>也就是第一次获得锁时的<code>Lock Record</code>（这里的第一次是指重入获取锁时的第一次），然后将对象头指向最高位的<code>Lock Record</code>，这里不需要用CAS指令，因为是在<code>safepoint</code>。 执行完后，就升级成了轻量级锁。原偏向线程的所有Lock Record都已经变成轻量级锁的状态。【轻量级锁加锁过程会在下文讲到，不要慌】</li></ol><p>触发时机：<br>释放：对应的就是synchronized方法的退出或synchronized块的结束。<br>撤销：笼统的说就是多个线程竞争导致不能再使用偏向模式的时候。</p><h1 id="synchronized轻量级锁原理（C-源码层面）"><a href="#synchronized轻量级锁原理（C-源码层面）" class="headerlink" title="synchronized轻量级锁原理（C++源码层面）"></a>synchronized轻量级锁原理（C++源码层面）</h1><h2 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h2><p>1.在线程栈中创建一个<code>Lock Record</code>，将其<code>obj</code>（即Object reference）字段指向锁对象。</p><p>2.会把锁的Mark Word复制到自己的Lock Record的Displaced Mark Word里面。然后线程尝试直接通过CAS指令将<code>Lock Record</code>的地址存储在对象头的<code>mark word</code>中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</p><p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置<code>Lock Record</code>第一部分（<code>Displaced Mark Word</code>）为null，起到了一个重入计数器的作用。然后结束。</p><p>4.如果都失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，需要膨胀为重量级锁。【这就是轻量级锁升级为重量级锁的时机】</p><h2 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h2><p>1.遍历线程栈,找到所有<code>obj</code>字段等于当前锁对象的<code>Lock Record</code>。</p><p>2.如果<code>Lock Record</code>的<code>Displaced Mark Word</code>为null，代表这是一次重入，将<code>obj</code>设置为null后continue。</p><p>3.如果<code>Lock Record</code>的<code>Displaced Mark Word</code>不为null，则利用CAS指令将对象头的<code>mark word</code>恢复成为<code>Displaced Mark Word</code>。如果成功，则continue，否则膨胀为重量级锁。</p><h2 id="轻量级锁重入示例图"><a href="#轻量级锁重入示例图" class="headerlink" title="轻量级锁重入示例图"></a>轻量级锁重入示例图</h2><p>我们看个demo，在该demo中重复3次获得锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0030.png"><h2 id="轻量级锁什么时候升级为重量级锁？"><a href="#轻量级锁什么时候升级为重量级锁？" class="headerlink" title="轻量级锁什么时候升级为重量级锁？"></a>轻量级锁什么时候升级为重量级锁？</h2><blockquote><p>其实在加锁的时候已经说过了，这里再以一个具体场景说下</p></blockquote><ul><li><p>线程1获取轻量级锁时会把锁的Mark Word复制到自己的Lock Record的Displaced Mark Word里面。然后线程尝试直接通过CAS指令将<code>Lock Record</code>的地址存储在对象头的<code>mark word</code>中</p></li><li><p>如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2在CAS的时候，发现线程1已经把对象头换了，<strong>线程2的CAS失败</strong>。那么此时就代表发生了锁竞争，准备升级为重量级锁</p></li></ul><h2 id="轻量级锁CAS的问题"><a href="#轻量级锁CAS的问题" class="headerlink" title="轻量级锁CAS的问题"></a>轻量级锁CAS的问题</h2><p>1、<strong>结论：</strong>没有自旋这回事，只有重量级锁获取失败才会自旋，网上的文章好多都是错的，我个人认为轻量级锁的意义就是在没有线程争用锁时不用创建monitor。<strong>【源码得到的结论，实践才是硬道理】</strong></p><p>2、<strong>轻量级锁和偏向锁区别：</strong>只要存在竞争就会升级重量级。<strong>轻量级锁的存在就是用于线程之间交替获取锁的场景</strong>，但是和偏向锁是有区别的啊。一个线程获取偏向锁之后，那么这个锁自然而然就属于这个线程（就算该线程释放了偏向锁也不会改变这把锁偏向这个线程的【也就是之前说的不会修改Thread ID】，这个前提是没有发生过批量重偏向使锁的epoch与其对应class类的epoch不相等）。所以说偏向锁的场景是用于一个线程不断的获取锁，如果把它放在轻量级锁的场景下线程之间交替获取的话会发生偏向锁的撤销的。也就是说在偏向锁的情况下，线程1之前释放了锁，线程2再获取锁，即使此时没有<strong>同时锁竞争</strong>的情况，依然是要升级为轻量级锁的。而轻量级锁只要没有同时去获取锁，就可以不升级为重量级锁，也就代表你可以不同线程交替获取这个锁。<br>3、效率上来看偏向锁只有在获取的时候进行一次CAS，以后的释放和获取只需要简单的一些判断操作。而轻量级锁的获取和释放都要都要CAS，单纯的看效率还是偏向锁效率高。</p><h1 id="synchronized重量级锁原理（C-源码层面）"><a href="#synchronized重量级锁原理（C-源码层面）" class="headerlink" title="synchronized重量级锁原理（C++源码层面）"></a>synchronized重量级锁原理（C++源码层面）</h1><blockquote><p>重量级锁面试可能问的多，就多写了点C++代码</p></blockquote><p>当出现多个线程<strong>同时竞争</strong>锁时，如果不是<strong>同时竞争</strong>，轻量级锁依然可以实现线程交替运行。</p><h2 id="Monitor监视器锁"><a href="#Monitor监视器锁" class="headerlink" title="Monitor监视器锁"></a>Monitor监视器锁</h2><ul><li><p>重量级锁通过对象的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的互斥量（mutex） 实现的实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。这也是为什么重量级锁效率不高的原因。</p></li><li><p>重量级锁的状态下，对象的<code>mark word</code>为指向一个堆中monitor对象的指针。一个monitor对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0031.png"><p>在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。其源码是用c++来实现的，位于HotSpot虚 拟机源码ObjectMonitor.hpp文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor主 要数据结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;    </span><br><span class="line">_header       = <span class="literal">NULL</span>;    </span><br><span class="line">_count        = <span class="number">0</span>;   </span><br><span class="line">    _waiters      = <span class="number">0</span>，    </span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">// 线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>; <span class="comment">// 存储该monitor的对象    </span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">// 标识拥有该monitor的线程    </span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet    </span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;    </span><br><span class="line">    _Responsible  = <span class="literal">NULL</span>;    </span><br><span class="line">    _succ         = <span class="literal">NULL</span>;    </span><br><span class="line">    _cxq          = <span class="literal">NULL</span>; <span class="comment">// 多线程竞争锁时的单向列表    </span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span>;    </span><br><span class="line">    _EntryList    = <span class="literal">NULL</span>; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表   </span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span>;   </span><br><span class="line">    _SpinClock    = <span class="number">0</span>;    </span><br><span class="line">    OwnerIsThread = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Contention List：所有请求锁的线程将被首先放置到该竞争队列<br>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List<br>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set<br>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck<br>Owner：获得锁的线程称为Owner<br>!Owner：释放锁的线程</p></blockquote><p>1、当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到Contention List的队列的队首，然后调用<code>park</code>函数挂起当前线程。</p><p>2、当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人，假定继承人【Ready线程】被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平。</p><p>3、如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p><p>4、<strong>关于Contention List（cxq）和EntryList的区别：</strong>cxq是单向链表，指的是如果已经有t1线程获取到monitor对象拿到锁后，t2和t3没有竞争到，t2、t3线程会进行到cxq队列，先自己尝试竞争锁，如果竞争不到则自旋再去挣扎一下获取锁，当t1执行完同步代码块，释放锁后，由t1、t2、t3再去争抢锁，如果t1再次抢到锁，那么t2、t3会进行到EntryList阻塞队列，如果此时又有t4、t5线程过来会被放到cxq队列，t2,t3,t4,t5，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当 前线程挂起，等待被唤醒。如果t1被释放， 根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作终由unpark完成，被唤醒的线程，继续执行monitor 的竞争。当获取锁的线程释放后，EntryList中的线程和WaitSet中的线程被唤醒都可能去获取锁变成owner的拥有者。</p><ul><li><p>每一个Java对象都可以与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象 对应的monitor。 我们的Java代码里不会显示地去创造这么一个monitor对象，我们也无需创建，事实上可以这么理解： monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉JVM需要为我们的某个对 象创建关联的monitor对象。每个线程都存在两个ObjectMonitor对象列表，分别为free和used列表。 同时JVM中也维护着global locklist。当线程需要ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从global list中分配一批<code>monitor</code>到free中。</p></li><li><p>free对应C++代码：omFreeList</p></li><li><p>global locklist对应C++代码：gFreeList</p></li></ul><h2 id="monitor竞争"><a href="#monitor竞争" class="headerlink" title="monitor竞争"></a>monitor竞争</h2><p>1、执行monitorenter时，会调用InterpreterRuntime.cpp (位于：src/share/vm/interpreter/interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter函 数。具体代码可参见HotSpot源码。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0032.png"><p>2、对于重量级锁，monitorenter函数中会调用 ObjectSynchronizer::slow_enter 3.终调用 ObjectMonitor::enter（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line">  <span class="comment">// owner为null代表无锁状态，如果能CAS设置成功，则当前线程直接获得锁</span></span><br><span class="line">  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是重入的情况，_recursions++</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  1、当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">    assert (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    <span class="comment">// 重入计数重置为1</span></span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// 设置owner字段为当前线程（之前owner是指向Lock Record的指针）</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//自旋的过程中获得了锁，则直接返回</span></span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;set_suspend_equivalent();</span><br><span class="line">      <span class="comment">// 在该方法中调用系统同步操作。也就是获得锁或阻塞</span></span><br><span class="line">      EnterI (THREAD) ;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;set_current_pending_monitor(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Monitor等待或获取锁"><a href="#Monitor等待或获取锁" class="headerlink" title="Monitor等待或获取锁"></a>Monitor等待或获取锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 尝试获得锁</span></span><br><span class="line">    <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DeferredInitialize () ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">if</span> (TrySpin (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程被封装成ObjectWaiter对象node</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过CAS将node节点插入到_cxq队列的头部，cxq是一个单向链表</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己</span></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TEVENT (Inflated enter - Contention) ;</span><br><span class="line">    <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//线程在被挂起前再做一下挣扎，看能不能获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        assert (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 当前线程是_Responsible时，调用的是带时间参数的park</span></span><br><span class="line">            TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则直接调用park挂起当前线程</span></span><br><span class="line">            TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; TrySpin (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">        <span class="comment">// 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::fence() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 走到这里说明已经获得锁了</span></span><br><span class="line"></span><br><span class="line">    assert (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    assert (object() != <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将当前线程的node从cxq或EntryList中移除</span></span><br><span class="line">    UnlinkAfterAcquire (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"><span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::fence();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方 法实现如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">void</span> * own = _owner ;</span><br><span class="line"><span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (Atomic::cmpxchg_ptr (Self， &amp;_owner， <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">assert (_recursions == <span class="number">0</span>， <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">assert (_owner == Self， <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"><span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The lock had been free momentarily， but we lost the race to the lock.</span></span><br><span class="line"><span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line"><span class="comment">// We can either return -1 or retry.</span></span><br><span class="line"><span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的具体流程概括如下：</p><ol><li>当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。</li><li>在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node 节点push到_cxq列表中。</li><li>node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当 前线程挂起，等待被唤醒。</li><li>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li></ol><h2 id="monitor释放"><a href="#monitor释放" class="headerlink" title="monitor释放"></a>monitor释放</h2><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor的exit方法中。（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所 示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   <span class="comment">// 如果_owner不是当前线程</span></span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">     <span class="comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀后还没调用过enter方法，_owner会是指向Lock Record的指针。</span></span><br><span class="line">     <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">       assert (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       _recursions = <span class="number">0</span> ;</span><br><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 异常情况:当前不是持有锁的线程</span></span><br><span class="line">       TEVENT (Exit - Throw IMSX) ;</span><br><span class="line">       assert(<span class="literal">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit!&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">          THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 重入计数器还不为0，则计数器-1后返回</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">     TEVENT (Inflated <span class="built_in">exit</span> - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// _Responsible设置为null</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      assert (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Knob_ExitPolicy默认为0</span></span><br><span class="line">      <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// code 1：先释放锁，这时如果有其他线程进入同步块则能获得锁</span></span><br><span class="line">         OrderAccess::release_store_ptr (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">         OrderAccess::storeload() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">         <span class="comment">// code 2：如果没有等待的线程或已经有假定继承人</span></span><br><span class="line">         <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>(_EntryList)|<span class="keyword">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TEVENT (Inflated <span class="built_in">exit</span> - simple egress) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         TEVENT (Inflated <span class="built_in">exit</span> - <span class="built_in">complex</span> egress) ;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// code 3：要执行之后的操作需要重新获得锁，即设置_owner为当前线程</span></span><br><span class="line">         <span class="keyword">if</span> (Atomic::cmpxchg_ptr (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         TEVENT (Exit - Reacquired) ;</span><br><span class="line">      &#125; </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="comment">// code 4：根据QMode的不同会有不同的唤醒策略，默认为0</span></span><br><span class="line">      <span class="keyword">int</span> QMode = Knob_QMode ;</span><br><span class="line">  <span class="comment">// QMode == 2 : cxq中的线程有更高优先级，直接绕过EntryList队列，唤醒cxq的队首线程</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         </span><br><span class="line">          w = _cxq ;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          assert (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">// QMode == 3 将cxq中的元素插入到EntryList的末尾</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          </span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Append the RATs to the EntryList</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span></span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// QMode == 4，将cxq插入到EntryList的队首</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          </span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Prepend the RATs to the EntryList</span></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          _EntryList = w ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果EntryList不为空，则直接唤醒EntryList的队首元素</span></span><br><span class="line">          assert (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// EntryList为null，则处理cxq中的元素</span></span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为之后要将cxq的元素移动到EntryList，所以这里将cxq字段设置为null</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line">      TEVENT (Inflated <span class="built_in">exit</span> - drain cxq into EntryList) ;</span><br><span class="line"></span><br><span class="line">      assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      assert (_EntryList  == <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : 将cxq中的元素转移到EntryList，并反转顺序</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         assert (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2‘</span></span><br><span class="line">         <span class="comment">// 将cxq中的元素转移到EntryList</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// _succ不为null，说明已经有个继承人了，所以不需要当前线程去唤醒，减少上下文切换的比率</span></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="comment">// 唤醒EntryList第一个元素</span></span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行必要的锁重入判断以及自旋优化后，进入到主要逻辑：</p><p><code>code 1</code> 设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；</p><p><code>code 2</code> 如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。或者如果说succ不为null，代表当前已经有个”醒着的”继承人线程，那当前线程不需要唤醒任何线程；</p><p><code>code 3</code> 当前线程重新获得锁，因为之后要操作cxq和EntryList队列以及唤醒线程；</p><p><code>code 4</code>根据QMode的不同，会执行不同的唤醒策略；</p><p>根据QMode的不同，有不同的处理方式：</p><ol><li>QMode = 2且cxq非空：取cxq队列队首的ObjectWaiter对象，调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回，后面的代码不会执行了；</li><li>QMode = 3且cxq非空：把cxq队列插入到EntryList的尾部；</li><li>QMode = 4且cxq非空：把cxq队列插入到EntryList的头部；</li><li>QMode = 0：暂时什么都不做，继续往下看；</li></ol><p>只有QMode=2的时候会提前返回，等于0、3、4的时候都会继续往下执行：</p><p>1.如果EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回；<br>2.如果EntryList的首元素为空，就将cxq的所有元素放入到EntryList中，然后再从EntryList中取出来队首元素执行ExitEpilog方法，然后立即返回；</p><ol><li>退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。</li><li>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作终由unpark完成，实现 如下：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectMonitor::ExitEpilog (Thread * Self， ObjectWaiter * Wakee) &#123;</span><br><span class="line"><span class="keyword">assert</span> (_owner == Self， <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">_succ = Knob_SuccEnabled ? Wakee-&gt;_thread : NULL ;</span><br><span class="line">P</span><br><span class="line">arkEvent * Trigger = Wakee-&gt;_event ;</span><br><span class="line">Wakee = NULL ;</span><br><span class="line"><span class="comment">// Drop the lock</span></span><br><span class="line">OrderAccess::release_store_ptr (&amp;_owner， NULL) ;</span><br><span class="line">OrderAccess::fence() ; <span class="comment">// ST _owner vs LD in unpark()</span></span><br><span class="line"><span class="keyword">if</span> (SafepointSynchronize::do_call_back()) &#123;</span><br><span class="line">TEVENT (unpark before SAFEPOINT) ;</span><br><span class="line">&#125;</span><br><span class="line">DTRACE_MONITOR_PROBE(contended__exit， <span class="keyword">this</span>， object()， Self);</span><br><span class="line">Trigger-&gt;unpark() ; <span class="comment">// 唤醒之前被pack()挂起的线程.</span></span><br><span class="line"><span class="comment">// Maintain stats and report events to JVMTI</span></span><br><span class="line"><span class="keyword">if</span> (ObjectMonitor::_sync_Parks != NULL) &#123;</span><br><span class="line">ObjectMonitor::_sync_Parks-&gt;inc() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// park self</span></span><br><span class="line"><span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line"><span class="comment">// Increase the RecheckInterval， but clamp the value.</span></span><br><span class="line">RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line"><span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br></pre></td></tr></table></figure><h2 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h2><p>可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数， 执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就 会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语 言中是一个重量级(Heavyweight)的操作。 用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0033.png"><p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。 内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。 用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存 储资源、I/O资源等。 系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执 行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内 核态）。 系统调用的过程可以简单理解为：</p><ol><li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提供的服务。</li><li>用户态程序执行系统调用。</li><li>CPU切换到内核态，并跳到位于内存指定位置的指令。</li><li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。</li><li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。 由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在 synchronized未优化之前，效率低的原因。</li></ol><h1 id="锁降级的争论"><a href="#锁降级的争论" class="headerlink" title="锁降级的争论"></a>锁降级的争论</h1><p>1、先说结论，<strong>在openjdk的hotsopt jdk8u里是有锁降级的机制的</strong>，锁降级是什么时候加入到hotspot的这个我没去关注，所以我只说看过代码的jdk8u版本，另外根据R大的这个<a href="https://www.zhihu.com/question/19882320">回答</a>，我相信sunj dk也一样。</p><p>2、然后再详细说：</p><ul><li><p>锁降级的代码在<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9ce27f0a4683/src/share/vm/runtime/synchronizer.cpp#l1503"><code>deflate_idle_monitors</code></a>方法中，其调用点在进入SafePoint的方法<code>SafepointSynchronize::begin()</code>中。<br>在<code>deflate_idle_monitors</code>中会找到已经<code>idle</code>的monitor(也就是重量级锁的对象)，然后调用<code>deflate_monitor</code>方法将其降级。</p></li><li><p>因为锁降级是发生在safepoint的，所以如果降级时间过长会导致程序一直处于STW的阶段。在<a href="http://openjdk.java.net/jeps/8183909">这里</a>有篇文章讨论了优化机制。jdk8中本身也有个<code>MonitorInUseLists</code>的开关，其影响了寻找<code>idle monitor</code>的方式，对该开关的一些讨论看<a href="https://bugs.openjdk.java.net/browse/JDK-8149442">这里</a>。</p></li><li><p>至于为什么《java并发编程的艺术》中说锁不能降级，我<strong>猜测</strong>可能该书作者看的jdk版本还没有引入降级机制。</p></li></ul><h1 id="细节-容易混淆的地方"><a href="#细节-容易混淆的地方" class="headerlink" title="细节/容易混淆的地方"></a>细节/容易混淆的地方</h1><h2 id="java语言规范"><a href="#java语言规范" class="headerlink" title="java语言规范"></a>java语言规范</h2><p>1、java语言规范里面，<code>int i = 0，resource = loadedResoures，flag = true</code>，各种变量的简单的赋值操作，规定都是原子的包括引用类型的变量的赋值写操作，也是原子的。</p><p>2、但是很多复杂的一些操作，i++，先读取i的值，再跟新i的值，i = y + 2，先读取y的值，再更新i的值，这种复杂操作，不是简单赋值写，他是有计算的过程在里面的，此时java语言规范默认是不保证原子性的。</p><h2 id="32位Java虚拟机中的long和double变量写操作为何不是原子的？"><a href="#32位Java虚拟机中的long和double变量写操作为何不是原子的？" class="headerlink" title="32位Java虚拟机中的long和double变量写操作为何不是原子的？"></a>32位Java虚拟机中的long和double变量写操作为何不是原子的？</h2><p>原子性这块，特例，32位虚拟机里的long/double类型的变量的简单赋值写操作，不是原子的，long i = 30，double c = 45.0，在32位虚拟机里就不是原子的，因为long和double是64位的</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>如果多个线程同时并发的执行long i = 30，long是64位的，就会导致有的线程在修改i的高32位，有的线程在修改i的低32位，多线程并发给long类型的变量进行赋值操作，在32位的虚拟机下，是有问题的</p><p> 就可能会导致多线程给long i = 30赋值之后，导致i的值不是30，可能是-3333344429，乱码一样的数字，就是因为高低32位赋值错了，就导致二进制数字转换为十进制之后是一个很奇怪的数字</p><h2 id="volatile保不保证原子性？"><a href="#volatile保不保证原子性？" class="headerlink" title="volatile保不保证原子性？"></a>volatile保不保证原子性？</h2><p>1、volatile对原子性保障的语义，在java里很有限的，几乎可以忽略不计。32位的java虚拟机里面，对long/double变量的赋值写是不原子的，此时如果对变量加上了volatile，就可以保证在32位java虚拟机里面，对long/double变量的赋值写是原子的了。（这是一个特列，可以通过volatile来保证原子性）但总体来说volatiel不保证原子性</p><p>例子：</p><p><code>volatile long i;</code> 多个线程执行：<code>i = 30</code>，此时就不要紧了，因为volatile修饰了，就可以保证这个赋值操作是原子的了。</p><p>2、<code>int i = 0</code>，这种原子性的保证，不是靠volatile，java语言规范本身就规定了这种操作是原子性的。</p><p><strong>结论：volatile不保证原子性</strong></p><h1 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h1><h2 id="为什么要出现咋同步代码块中"><a href="#为什么要出现咋同步代码块中" class="headerlink" title="为什么要出现咋同步代码块中"></a>为什么要出现咋同步代码块中</h2><blockquote><p>通过前面对monitor的C++源码讲解，答案应该很明显了。</p></blockquote><p>1、如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><p>2、注意，如果没有获取到监视器锁，wait 方法是会抛异常的，而且注意这个异常是IllegalMonitorStateException 异常。这是重要知识点，要考。</p><p>3、如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中。而WaitSet这个结构是在Monitor对象里，如果你没有获取到监视器锁，你就没有Monitor。那就无法加入到WaitSet里。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><p>《Java并发编程的艺术》</p></li><li><p>《Java并发编程之美》</p></li><li><p>b站一些机构的视频</p></li><li><p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p></li><li><p><a href="https://github.com/farmerjohngit/myblog">https://github.com/farmerjohngit/myblog</a></p></li><li><p>公总号：儒猿技术窝</p></li></ul><h1 id="题外话："><a href="#题外话：" class="headerlink" title="题外话："></a>题外话：</h1><p>1、《Java并发编程的艺术》这本书非常好。不过我第一遍看的时候，就属于云里雾里的，就是感觉抓不到重点。直到我秋招结束之后，再次回顾的时候才开始有点感觉了。这本书从硬件层面，从设计层面讲的一些内容讲的很好，给了我很大的帮助。这本书结合《Java并发编程之美》可能会有更好的阅读体验和理解（仅仅是个人觉得）。读者有时间还是尽量要看下这两本书，我的博客只是总结了面试经常会问到的一些内容，以及一些很难找到的一些资料。</p><p>2、相信大家也能明显的感觉到写这篇博客的时候，涉及到了很多<strong>操作系统</strong>的知识。其实越往后学，你就越能发现<strong>操作系统</strong>对你理解很多东西的原理会有很大帮助。比如说这篇博客的内存屏障，MESI缓存一致性协议，cpu指令；还有netty的一些通信原理，还有mysql,redis与操作系统的交互，rokcetmq的零拷贝，消息储存机制等等。希望读者有时间能够好好看一下<strong>计算机网络和操作系统</strong>，真的是很重要，并且校招和社招面试大厂问的都比较多。</p><p>3、因为东西写的比较多，略微有点乱，写了3万多字。所以可能目录顺序不是那么的好，敬请读者见谅。</p><p>4、感谢各个博主的博客，对我都有很大的帮助。笔者能力有限，总结的博客可能有错误。如果有错误请及时联系我，谢谢~。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第二阶段-锁与同步-[2]</title>
      <link href="post/8210870.html"/>
      <url>post/8210870.html</url>
      
        <content type="html"><![CDATA[<h1 id="可见性设计的硬件"><a href="#可见性设计的硬件" class="headerlink" title="可见性设计的硬件"></a>可见性设计的硬件</h1><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0016.png"><p>从硬件的级别来考虑一下可见性的问题</p><p><strong>1、第一个可见性的场景：</strong>每个处理器都有自己的寄存器（register），所以多个处理器各自运行一个线程的时候，可能导致某个变量给放到寄存器里去，接着就会导致各个线程没法看到其他处理器寄存器里的变量的值修改了，就有可能在寄存器的级别，导致变量副本的更新，无法让其他处理器看到。</p><p><strong>2、第二个可见性的场景：</strong>然后一个处理器运行的线程对变量的写操作都是针对写缓冲来的（store buffer）并不是直接更新主内存，所以很可能导致一个线程更新了变量，但是仅仅是在写缓冲区里罢了，没有更新到主内存里去。这个时候，其他处理器的线程是没法读到他的写缓冲区的变量值的，所以此时就是会有可见性的问题。</p><p> <strong>3、第三个可见性的场景：</strong>然后即使这个时候一个处理器的线程更新了写缓冲区之后，将更新同步到了自己的高速缓存里（cache，或者是主内存），然后还把这个更新通知给了其他的处理器，但是其他处理器可能就是把这个更新放到无效队列里去，没有更新他的高速缓存。此时其他处理器的线程从高速缓存里读数据的时候，读到的还是过时的旧值。【处理器是优先从自己的高速缓存里取读取变量副本】</p><p>可见性发生的问题</p><p>​     如果要实现可见性的话，其中一个方法就是通过MESI协议，这个MESI协议实际上有很多种不同的时间，因为他不过就是一个协议罢了，具体的实现机制要靠具体底层的系统如何实现。</p><p>​    根据具体底层硬件的不同，MESI协议的实现是有区别的。比如说MESI协议有一种实现，就是一个处理器将另外一个处理器的高速缓存中的更新后的数据拿到自己的高速缓存中来更新一下，这样大家的缓存不就实现同步了，然后各个处理器的线程看到的数据就一样了。</p><h1 id="MESI-缓存一致性协议（简介）"><a href="#MESI-缓存一致性协议（简介）" class="headerlink" title="MESI-缓存一致性协议（简介）"></a>MESI-缓存一致性协议（简介）</h1><p>1、为了实现MESI协议，有两个配套的专业机制要给大家说一下：flush处理器缓存、refresh处理器缓存。</p><ul><li><p>flush处理器缓存，他的意思就是把自己更新的值刷新到高速缓存里去（或者是主内存），因为必须要刷到高速缓存（或者是主内存）里，才有可能在后续通过一些特殊的机制让其他的处理器从自己的高速缓存（或者是主内存）里读取到更新的值</p></li><li><p>除了flush以外，他还会发送一个消息到总线（bus），通知其他处理器，某个变量的值被他给修改了</p></li><li><p>refresh处理器缓存，他的意思就是说，处理器中的线程在读取一个变量的值的时候，如果发现其他处理器的线程更新了变量的值，必须从其他处理器的高速缓存（或者是主内存）里，读取这个最新的值，更新到自己的高速缓存中</p></li></ul><p>2、所以说，为了保证可见性，在底层是通过MESI协议、flush处理器缓存和refresh处理器缓存，这一整套机制来保障的</p><p>3、要记住，flush和refresh，这两个操作，flush是强制刷新数据到高速缓存（主内存），不要仅仅停留在写缓冲器里面；refresh，是从总线嗅探发现某个变量被修改，必须强制从其他处理器的高速缓存（或者主内存）加载变量的最新值到自己的高速缓存里去。【不同的硬件，实现可能略有不同】</p><p>4、内存屏障的使用，在底层硬件级别的原理，其实就是在执行flush和refresh，MESI协议是如何与内存屏障搭配使用的（flush、refresh）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">isRunning = <span class="keyword">false</span>; =&gt; 写<span class="keyword">volatile</span>变量，就会通过执行一个内存屏障，在底层会触发flush处理器缓存的操作；<span class="keyword">while</span>(isRunning) &#123;&#125;，读<span class="keyword">volatile</span>变量，也会通过执行一个内存屏障，在底层触发refresh操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="内存屏障的相关讲解"><a href="#内存屏障的相关讲解" class="headerlink" title="内存屏障的相关讲解"></a>内存屏障的相关讲解</h1><blockquote><p>上面的文章可能已经把读者搞混了，其实可见性和有序性最主要的就是内存屏障，下面来介绍下内存屏障帮读者梳理一下。</p></blockquote><p>​    内存屏障是被插入两个CPU指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将写缓冲器的值写入高速缓存，清空无效队列，实现可见性。</p><p>​    举例：将写缓冲器数据写入高速缓存，能够避免不同处理器之间不能访问写缓冲器而导致的可见性问题，以及有效地避免了存储转发问题；清空无效队列保证该处理器上高速缓存中不存在旧的副本，进而拿到最新数据</p><h2 id="基本内存屏障"><a href="#基本内存屏障" class="headerlink" title="基本内存屏障"></a>基本内存屏障</h2><ul><li><p>LoadLoad屏障： 对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 </p></li><li><p>StoreStore屏障：对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 </p></li><li><p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。 </p></li><li><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p><p>以上的四种屏障主要依据不同处理器支持的重排序（读写，读读，写写，写读）来确定的，比如某些处理器只支持写读重排序，因此只需要StoreLoad屏障</p><p>下面对上述的基本屏障进行利用，以针对不同的目的用相应的屏障。</p></li></ul><h2 id="可见性保障"><a href="#可见性保障" class="headerlink" title="可见性保障"></a>可见性保障</h2><p>  主要分为加载屏障（Load Barrier）和存储屏障（Store Barrier）</p><ul><li><p>加载屏障：StoreLoad屏障作为万能屏障，作用是冲刷写缓冲器，清空无效化队列，这样处理器在读取共享变量时，因为本高速缓存中的数据是无效的，因此先从主内存或其他处理器的高速缓存中读取相应变量，更新到自己的缓存中 </p></li><li><p>存储屏障：同样使用StoreLoad屏障，作用是将写缓冲器内容写入高速缓存中，使处理器对共享变量的更新写入高速缓存或者主内存中 ，同时解决存储转发问题，使得写缓冲器中的数据不存在旧值</p><p>以上两种屏障解决可见性问题。</p></li></ul><h2 id="有序性保障"><a href="#有序性保障" class="headerlink" title="有序性保障"></a>有序性保障</h2><p>  主要分为获取屏障（Acquire Barrier）和释放屏障（Release Barrier）</p><ul><li>获取屏障：相当于LoadLoad屏障和LoadStore屏障的组合，它能禁止该屏障之前的任何读操作与该屏障之后的任何读、写操作之间进行重排序； </li><li>释放屏障：相当于StoreLoad屏障与StoreStore屏障的组合，它能够禁止该屏障之前的任何读、写操作与该屏障之后的任何写操作之间进行重排序</li></ul><p>对于其实大家记住volatile修饰的字段和普通修饰的字段同样不可以重排序，因此只要存在读写、写写、写读、读读等操作，包含了volatile关键字，都会在操作指令之间插入屏障的，具体插入什么屏障可以根据对应的操作插入。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结论: </span><br><span class="line">（1）原子性：加锁和释放锁，ObjectMonitor</span><br><span class="line"></span><br><span class="line">（2）可见性：加了Load屏障和Store屏障，释放锁flush数据，加锁会refresh数据</span><br><span class="line"></span><br><span class="line">（3）有序性：Acquire屏障和Release屏障，保证同步代码块内部的指令可以重排，但是同步代码块内部的指令和外面的指令是不能重排的</span><br></pre></td></tr></table></figure><p>举个例子说明加屏障的顺序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; -&gt; monitorenter</span><br><span class="line"></span><br><span class="line"><span class="comment">//Load内存屏障</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Acquire内存屏障</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = b;</span><br><span class="line"></span><br><span class="line">c = <span class="number">1</span>; <span class="comment">// synchronized代码块里面还是可能会发生指令重排</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Release内存屏障</span></span><br><span class="line"></span><br><span class="line">&#125; -&gt; monitorexit</span><br><span class="line"></span><br><span class="line"><span class="comment">//Store内存屏障</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、java的并发技术底层很多都对应了内存屏障的使用，包括synchronized，他底层也是依托于各种不同的内存屏障来保证可见性和有序性的</p><p>2、按照可见性来划分的话，内存屏障可以分为Load屏障和Store屏障。</p><ul><li>Load屏障的作用是执行refresh处理器缓存的操作，说白了就是对别的处理器更新过的变量，从其他处理器的高速缓存（或者主内存）加载数据到自己的高速缓存来，确保自己看到的是最新的数据。</li><li>Store屏障的作用是执行flush处理器缓存的操作，说白了就是把自己当前处理器更新的变量的值，都刷新到高速缓存（或者主内存）里去</li></ul><ul><li>在monitorexit指令之后，会有一个Store屏障，让线程把自己在同步代码块里修改的变量的值都执行flush处理器缓存的操作，刷到高速缓存（或者主内存）里去；然后在monitorenter指令之后会加一个Load屏障，执行refresh处理器缓存的操作，把别的处理器修改过的最新值加载到自己高速缓存里来</li><li>所以说通过Load屏障和Store屏障，就可以让synchronized保证可见性。</li></ul><p>3、按照有序性保障来划分的话，还可以分为Acquire屏障和Release屏障。</p><ul><li>在monitorenter指令之后，Load屏障之后，会加一个Acquire屏障，这个屏障的作用是禁止读操作和读写操作之间发生指令重排序。在monitorexit指令之前，会加一个Release屏障，这个屏障的作用是禁止写操作和读写操作之间发生重排序。</li><li>所以说，通过 Acquire屏障和Release屏障，就可以让synchronzied保证有序性，只有synchronized内部的指令可以重排序，但是绝对不会跟外部的指令发生重排序。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前面讲过，lock前缀指令相当于一个内存屏障，lock前缀指令同时保证可见性和有序性</span><br><span class="line"></span><br><span class="line">（1）可见性：加了Load屏障和Store屏障，释放锁flush数据，加锁会refresh数据</span><br><span class="line"></span><br><span class="line">（2）有序性：Acquire屏障和Release屏障，保证同步代码块内部的指令可以重排，但是同步代码块内部的指令和外面的指令是不能重排的</span><br><span class="line"></span><br><span class="line">（3）不保证原子性</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、volatile对原子性的保证真的是非常的有限，其实主要就是32位jvm中的long/double类型变量的赋值操作是不具备原子性的，加上volatile就可以保证原子性了。但是总体上就说不保证原子性。</p><p>2、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">Release屏障</span><br><span class="line"></span><br><span class="line">isRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Store屏障 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">线程<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">Load屏障</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(isRunning) &#123;</span><br><span class="line"></span><br><span class="line">Acquire屏障</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在volatile变量写操作的前面会加入一个Release屏障，然后在之后会加入一个Store屏障，这样就可以保证volatile写跟Release屏障之前的任何读写操作都不会指令重排，然后Store屏障保证了，写完数据之后，立马会执行flush处理器缓存的操作</li><li>在volatile变量读操作的前面会加入一个Load屏障，这样就可以保证对这个变量的读取时，如果被别的处理器修改过了，必须得从其他处理器的高速缓存（或者主内存）中加载到自己本地高速缓存里，保证读到的是最新数据；在之后会加入一个Acquire屏障，禁止volatile读操作之后的任何读写操作会跟volatile读指令重排序</li></ul><p>跟之前讲解的volatie读写内存屏障的知识对比一下，其实你看一下是类似的意思的。</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><ul><li><p>其实不要对内存屏障这个东西太较真，因为说句实话，不同版本的JVM，不同的底层硬件，都可能会导致加的内存屏障有一些区别，所以这个本来就没完全一致的。你只要知道内存屏障是如何保证volatile的可见性和有序性的就可以了</p></li><li><p>看各种并发相关的书和文章，对内存屏障到底是加的什么屏障，莫衷一是，没有任何一个官方权威的说法，因为这个内存屏障太底层了，底层到了涉及到了硬件，硬件不同对内存屏障的实现是不一样的</p></li><li><p>内存屏障这个东西，大概来说，其实就是大概的给你说一下这个意思，尤其是Release屏障，Store屏障和Load屏障还好理解一些，比较简单，Acqurie屏障，莫衷一是，我也没法给你一个官方的定论</p></li><li><p>如果你一定 要了解清除，到底加的准确的屏障是什么？到底是如何跟上下的指令避免重排的，你自己去研究吧。【我也看过很多的资料，做过很多的研究，硬件对这个东西的实现和承诺，莫衷一是，没有标准和官方定论。—–这句话是某BAT大佬说的】</p></li></ul><p>内存屏障对应的底层的一些基本的硬件级别的原理，也都讲清楚了</p><h1 id="MESI-缓存一致性协议（进阶）"><a href="#MESI-缓存一致性协议（进阶）" class="headerlink" title="MESI-缓存一致性协议（进阶）"></a>MESI-缓存一致性协议（进阶）</h1><h2 id="MESI-初步"><a href="#MESI-初步" class="headerlink" title="MESI-初步"></a>MESI-初步</h2><p>1、处理器高速缓存的底层数据结构实际是一个拉链散列表的结构，就是有很多个bucket，每个bucket挂了很多的cache entry，每个cache entry由三个部分组成：tag、cache line和flag，其中的cache line【缓存行】就是缓存的数据。tag指向了这个缓存数据在主内存中的数据的地址，flag标识了缓存行的状态，另外要注意的一点是，cache line中可以包含多个变量的值</p><p>2、处理器会操作一些变量，怎么在高速缓存里定位到这个变量呢？</p><ul><li>那么处理器在读写高速缓存的时候，实际上会根据变量名执行一个内存地址解码的操作，解析出来3个东西，index、tag和offset。index用于定位到拉链散列表中的某个bucket，tag是用于定位cache entry，offset是用于定位一个变量在cache line中的位置</li><li>如果说可以成功定位到一个高速缓存中的数据，而且flag还标志着有效，则缓存命中；否则不满足上述条件，就是缓存未命中。如果是读数据未命中的话，会从主内存重新加载数据到高速缓存中，现在处理器一般都有三级高速缓存，L1、L2、L3，越靠前面的缓存读写速度越快</li></ul><p>3、因为有高速缓存的存在，所以就导致各个处理器可能对一个变量会在自己的高速缓存里有自己的副本，这样一个处理器修改了变量值，别的处理器是看不到的，所以就是为了这个问题引入了缓存一致性协议（MESI协议）</p><p>4、MESI协议规定：对一个共享变量的读操作可以是多个处理器并发执行的，但是如果是对一个共享变量的写操作，只有一个处理器可以执行，其实也会通过排他锁的机制保证就一个处理器能写</p><p> 之前说过那个cache entry的flag代表了缓存数据的状态，MESI协议中划分为：</p><ul><li>invalid：无效的，标记为I，这个意思就是当前cache entry无效，里面的数据不能使用</li><li>shared：共享的，标记为S，这个意思是当前cache entry有效，而且里面的数据在各个处理器中都有各自的副本，但是这些副本的值跟主内存的值是一样的，各个处理器就是并发的在读而已</li><li>exclusive：独占的，标记为E，这个意思就是当前处理器对这个数据独占了，只有他可以有这个副本，其他的处理器都不能包含这个副本</li><li>modified：修改过的，标记为M，只能有一个处理器对共享数据更新，所以只有更新数据的处理器的cache entry，才是exclusive状态，表明当前线程更新了这个数据，这个副本的数据跟主内存是不一样的</li></ul><p>MESI协议规定了一组消息，就说各个处理器在操作内存数据的时候，都会往总线发送消息，而且各个处理器还会不停的从总线嗅探最新的消息，通过这个总线的消息传递来保证各个处理器的协作</p><p><strong>下面来详细的图解MESI协议的工作原理：</strong></p><p>1、处理器0读取某个变量的数据时，首先会根据index、tag和offset从高速缓存的拉链散列表读取数据，如果发现状态为I，也就是无效的，此时就会发送read消息到总线</p><p>2、接着主内存会返回对应的数据给处理器0，处理器0就会把数据放到高速缓存里，同时cache entry的flag状态是S</p><p>3、在处理器0对一个数据进行更新的时候，如果数据状态是S，则此时就需要发送一个invalidate消息到总线，尝试让其他的处理器的高速缓存的cache entry全部变为I，以获得数据的独占锁。</p><p>4、其他的处理器1会从总线嗅探到invalidate消息，此时就会把自己的cache entry设置为I，也就是过期掉自己本地的缓存，然后就是返回invalidate ack消息到总线，传递回处理器0，处理器0必须收到所有处理器返回的ack消息</p><p>5、接着处理器0就会将cache entry先设置为E，独占这条数据，在独占期间，别的处理器就不能修改数据了，因为别的处理器此时发出invalidate消息，这个处理器0是不会返回invalidate ack消息的，除非他先修改完再说</p><p>6、接着处理器0就是修改这条数据，接着将数据设置为M，也有可能是把数据此时强制写回到主内存中，具体看底层硬件实现</p><p>7、然后其他处理器此时这条数据的状态都是I了，那如果要读的话，全部都需要重新发送read消息，从主内存（或者是其他处理器）来加载，这个具体怎么实现要看底层的硬件了，都有可能的</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0017.jpg"><h2 id="MESI-优化"><a href="#MESI-优化" class="headerlink" title="MESI-优化"></a>MESI-优化</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0018.png"><p>​    MESI协议如果每次写数据的时候都要发送invalidate消息等待所有处理器返回ack，然后获取独占锁后才能写数据，那可能就会导致性能很差了，因为这个对共享变量的写操作，实际上在硬件级别变成串行的了。所以为了解决这个问题，硬件层面引入了写缓冲器和无效队列</p><p>1、</p><pre><code> 写缓冲器的作用是，一个处理器写数据的时候，直接把数据写入缓冲器，同时发送invalidate消息，然后就认为写操作完成了，接着就干别的事儿了，不会阻塞在这里。接着这个处理器如果之后收到其他处理器的ack消息之后才会把写缓冲器中的写结果拿出来，通过对cache entry设置为E加独占锁，同时修改数据，然后设置为M。</code></pre><p>​    其实写缓冲器的作用，就是处理器写数据的时候直接写入缓冲器，不需要同步阻塞等待其他处理器的invalidate ack返回，这就大大提升了硬件层面的执行效率了</p><pre><code> 包括查询数据的时候，会先从写缓冲器里查，因为有可能刚修改的值在这里，然后才会从高速缓存里查，这个就是存储转发</code></pre><p>2、</p><p>​    引入无效队列，就是说其他处理器在接收到了invalidate消息之后，不需要立马过期本地缓存，直接把消息放入无效队列，就返回ack给那个写处理器了，这就进一步加速了性能，然后之后从无效队列里取出来消息，过期本地缓存即可</p><p>​    通过引入写缓冲器和无效队列，一个处理器要写数据的话，这个性能其实很高的，他直接写数据到写缓冲器，发送一个validate消息出去，就立马返回，执行别的操作了；其他处理器收到invalidate消息之后直接放入无效队列，立马就返回invalidate ack</p><h2 id="硬件层面的MESI协议为何会引发有序性和可见性的问题？"><a href="#硬件层面的MESI协议为何会引发有序性和可见性的问题？" class="headerlink" title="硬件层面的MESI协议为何会引发有序性和可见性的问题？"></a>硬件层面的MESI协议为何会引发有序性和可见性的问题？</h2><p>MESI协议在硬件层面的原理其实大家都已经了解的很清晰了。</p><p>讲了这么多，再来看一下MESI-协议为何会引发可见性和有序性的问题</p><ul><li><p>可见性：写缓冲器和无效队列导致的，写数据不一定立马写入自己的高速缓存（或者主内存），是因为可能写入了写缓冲器；读数据不一定立马从别人的高速缓存（或者主内存）刷新最新的值过来，invalidate消息在无效队列里面</p></li><li><p>有序性：</p></li></ul><p> 简单的举两个例子</p><p>（1）StoreLoad重排序</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;  <span class="comment">//Store操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = c;  <span class="comment">//因为要读C的值，所以这个是load操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个很简单吧，第一个是Store，第二个是Load。但是可能处理器对store操作先写入了写缓冲器，此时这个写操作相当于没执行。然后就执行了第二行代码，第二行代码的b是局部变量，那这个操作等于是读取c的值，是load操作。</p><ul><li><p>第一个store操作写到写缓冲器里去了，导致其他的线程是读不到的，看不到的，好像是第一个写操作没执行一样；第二个load操作成功的执行了</p></li><li><p>这就导致好像第二行代码的load先执行了，第一行代码的store后执行</p></li></ul><p>StoreLoad重排，明明Store先执行，Load后执行；看起来好像Load先执行，Store后执行</p><p>（2）StoreStore重排序</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resource = loadResource();</span><br><span class="line"></span><br><span class="line">loaded = <span class="keyword">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>两个写操作，但是可能第一个写操作写入了写缓冲器，然后第二个写操作是直接修改的高速缓存【可能此时第二个数据的状态是m】，这个时候不就导致了两个写操作顺序颠倒了？诸如此类的重排序，都可能会因为MESI的机制发生</li><li>可见性问题也是一样的，写入写缓冲器之后，没刷入高速缓存，导致别人读不到；读数据的时候，可能invalidate消息在无效队列里，导致没法立马感知到过期的缓存，立马加载最新的数据</li></ul><h2 id="内存屏障在硬件层面的实现原理"><a href="#内存屏障在硬件层面的实现原理" class="headerlink" title="内存屏障在硬件层面的实现原理"></a>内存屏障在硬件层面的实现原理</h2><p>1、可见性问题：</p><blockquote><p>Store屏障 + Load屏障</p></blockquote><p>​    如果加了Store屏障之后，就会强制性要求你对一个写操作必须阻塞等待到其他的处理器返回invalidate ack之后，对数据加锁，然后修改数据到高速缓存中，必须在写数据之后，强制执行flush操作。</p><p>​    他的效果，要求一个写操作必须刷到高速缓存（或者主内存），不能停留在写缓冲里</p><p>​    如果加了Load屏障之后，在从高速缓存中读取数据的时候，如果发现无效队列里有一个invalidate消息，此时会立马强制根据那个invalidate消息把自己本地高速缓存的数据，设置为I（过期），然后就可以强制从其他处理器的高速缓存中加载最新的值了。这就是refresh操作</p><p>2、有序性问题</p><blockquote><p>内存屏障，Acquire屏障，Release屏障，但是都是由基础的StoreStore屏障,StoreLoad屏障，可以避免指令重排序的效果</p></blockquote><p>StoreStore屏障，会强制让写数据的操作全部按照顺序写入写缓冲器里，他不会让你第一个写到写缓冲器里去，第二个写直接修改高速缓存了。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resource = loadResource();</span><br><span class="line"></span><br><span class="line">StoreStore屏障</span><br><span class="line"></span><br><span class="line">loaded = <span class="keyword">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>StoreLoad屏障，他会强制先将写缓冲器里的数据写入高速缓存中，接着读数据的时候强制清空无效队列，对里面的validate消息全部过期掉高速缓存中的条目，然后强制从主内存里重新加载数据</p><p>a = 1; // 强制要求必须直接写入高速缓存，不能停留在写缓冲器里，清空写缓冲器里的这条数据  store</p><p>int b = c; //load</p><blockquote><p>java内存模型是对底层的硬件模型，cpu缓存模型，做了大幅度的简化，提供一个抽象和统一的模型给java程序员易于理解，很多时候如果要理解一些技术的本质，还是要深入到底层去研究的。</p></blockquote><h1 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h1><p>原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0019.png"><h2 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h2><p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操 作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 </p><h3 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h3><p><strong>第一个机制是通过总线锁保证原子性。</strong>如果多个处理器同时对共享变量进行读改写操作 （i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操 作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行 两次i++操作，我们期望的结果是3，但是有可能结果是2，如图所示。 </p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0020.png"><p>​    原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入 系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享 变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。 </p><p>​    处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 </p><h3 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h3><p>​    <strong>第二个机制是通过缓存锁定来保证原子性</strong>。在同一时刻，我们只需保证对某个内存地址 的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处 理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。 </p><p>​    频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存 行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。 </p><p><strong>但是有两种情况下处理器不会使用缓存锁定。</strong> </p><p>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。 </p><p>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。例如，位测试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p><h2 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h2><p>（1）使用循环CAS实现原子操作 </p><p>（2）使用锁机制实现原子操作</p><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><p>传统的锁（也就是下文要说的重量级锁）依赖于系统的同步函数，在linux上使用<code>mutex</code>互斥锁，最底层实现依赖于<code>futex</code>，这些同步函数都涉及到用户态和内核态的切换、进程的上下文切换，成本较高。对于加了<code>synchronized</code>关键字但<strong>运行时并没有多线程竞争，或两个线程接近于交替执行的情况</strong>，使用传统锁机制无疑效率是会比较低的。</p><p>​    futex由一个内核层的队列和一个用户空间层的atomic integer构成。当获得锁时，尝试cas更改integer，如果integer原始值是0，则修改成功，该线程获得锁，否则就将当期线程放入到 wait queue中（即操作系统的等待队列）。【及其类似于AQS的设计思想，可能AQS就参考了futex的思想】</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第二阶段-锁与同步-[1]</title>
      <link href="post/230c5bb3.html"/>
      <url>post/230c5bb3.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本阶段文章讲的略微深入，一些基础性问题不会讲解，如有基础性问题不懂，可自行查看我前面的文章，或者自行学习。</li><li>本篇文章比较适合校招和社招的面试，笔者在2020年面试的过程中，也确实被问到了下面的一些问题。</li></ul></blockquote><h1 id="并发编程中的三个问题"><a href="#并发编程中的三个问题" class="headerlink" title="并发编程中的三个问题"></a>并发编程中的三个问题</h1><blockquote><p>由于这个东西，和这篇文章比较配。所以虽然在第一阶段写过了，这里再回顾一遍。</p></blockquote><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><p>可见性（Visibility）：是指一个线程对共享变量进行修改，另一个先立即得到修改后的新值。</p><h3 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 笔记</span></span><br><span class="line"><span class="comment"> * 1.当没有加Volatile的时候,while循环会一直在里面循环转圈</span></span><br><span class="line"><span class="comment"> * 2.当加了之后Volatile,由于可见性,一旦num改了之后,就会通知其他线程</span></span><br><span class="line"><span class="comment"> * 3.还有注意的时候不能用if,if不会重新拉回来再判断一次。(也叫做虚假唤醒)</span></span><br><span class="line"><span class="comment"> * 4.案例演示:一个线程对共享变量的修改,另一个线程不能立即得到新值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video04_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//睡3秒之后再修改num,防止A线程先修改了num,那么到while循环的时候就会直接跳出去了</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come out&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//只有当num不等于0的时候,才会跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出，并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性（Atomicity）：在一次或多次操作中，要么所有的操作都成功执行并且不会受其他因素干扰而中 断，要么所有的操作都不执行或全部执行失败。不会出现中间状态</p><h3 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h3><p>案例演示:5个线程各执行1000次 i++;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/23 15:50</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: volatile不保证原子性的代码验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video05_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData03 myData03 = <span class="keyword">new</span> MyData03();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                     myData03.increment();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,<span class="string">&quot;线程&quot;</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要等待上面的20个线程计算完之后再查看计算结果</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;20个线程执行完之后num:\t&quot;</span> + myData03.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData03</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、控制台输出：（由于并发不安全，每次执行的结果都可能不一样）</p><blockquote><p>20个线程执行完之后num:    19706</p></blockquote><p>正常来说，如果保证原子性的话，20个线程执行完，结果应该是20000。控制台输出的值却不是这个，说明出现了原子性的问题。</p><p>2、使用javap反汇编class文件，对于num++可以得到下面的字节码指令：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">9: getstatic     #12                 // Field number:I   取值操作</span><br><span class="line"><span class="number">12</span>: iconst_1 </span><br><span class="line"><span class="number">13</span>: iadd </span><br><span class="line">14: putstatic     #12                 // Field number:I  赋值操作</span><br></pre></td></tr></table></figure><p>由此可见num++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多线程情况下就可能会出现问题。</p><p>比如num刚开始值是7。A线程在执行13: iadd时得到num值是8，B线程又执行9: getstatic得到前一个值是7。马上A线程就把8赋值给了num变量。但是B线程已经拿到了之前的值7，B线程是在A线程真正赋值前拿到的num值。即使A线程最终把值真正的赋给了num变量，但是B线程已经走过了getstaitc取值的这一步，B线程会继续在7的基础上进行++操作，最终的结果依然是8。本来两个线程对7进行分别进行++操作，得到的值应该是9，因为并发问题，导致结果是8。</p><p>3、并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共 享变量，干扰了前一个线程的操作。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化（重排序）来加快速度，会导致程序终的执行顺序不一定就是我们编写代码时的顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> SingletonDemo() 是被分成以下 <span class="number">3</span> 步完成</span><br><span class="line"> memory = allocate();     分配对象内存空间</span><br><span class="line"> instance(memory);        初始化对象</span><br><span class="line"> instance = memory;   设置 instance 指向刚分配的内存地址，此时 instance != <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>步骤2 和 步骤3 不存在数据依赖关系，重排与否的执行结果单线程中是一样的。这种指令重排是被 Java 允许的。当 3 在前时，instance 不为 null，但实际上初始化工作还没完成，会变成一个返回 null 的getInstance。这时候数据就出现了问题。</p><h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p>jcstress是java并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a> 修改pom文件，添加依赖：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;   </span><br><span class="line"> &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt;    </span><br><span class="line">&lt;artifactId&gt;jcstress-core&lt;/artifactId&gt;    </span><br><span class="line">&lt;version&gt;$&#123;jcstress.version&#125;&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="comment">// @Outcome: 如果输出结果是1或4，我们是接受的(ACCEPTABLE)，并打印ok</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="comment">//如果输出结果是0，我们是接受的并且感兴趣的，并打印danger</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span> <span class="comment">//@Actor：表示会有多个线程来执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、实际上上面两个方法会有很多线程来执行，为了讲解方便，我们只提出线程1和线程2来讲解。</p><p>2、I_Result 是一个保存int类型数据的对象，有一个属性 r1 用来保存结果，在多线程情况下可能出现几种结果？</p><p>情况1：线 程1先执行actor1，这时ready = false，所以进入else分支结果为1。</p><p>情况2：线程2执行到actor2，执行了num = 2;和ready = true，线程1执行，这回进入 if 分支，结果为 4。</p><p>情况3：线程2先执行actor2，只执行num = 2；但没来得及执行 ready = true，线程1执行，还是进入 else分支，结果为1。 </p><p>情况4：0，发生了指令重排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程2执行的代码</span></span><br><span class="line">   <span class="comment">// @Actor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;    <span class="comment">//pos_1</span></span><br><span class="line">       ready = <span class="keyword">true</span>;<span class="comment">//pos_2</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>pos_1处代码和pos_2处代码没有什么数据依赖关系，或者说没有因果关系。Java可能对其进行指令重排，排成下面的顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程2执行的代码</span></span><br><span class="line">   <span class="comment">// @Actor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">   ready = <span class="keyword">true</span>;<span class="comment">//pos_2</span></span><br><span class="line">       num = <span class="number">2</span>;    <span class="comment">//pos_1</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此时如果线程2先执行到<code>ready = true;</code>还没来得及执行 <code>num = 2;</code> 。线程1执行，直接进入if分支，此时num默认值为0。 得到的结果也就是0。</p><h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p><h2 id="为什么指令重排序可以提高性能？"><a href="#为什么指令重排序可以提高性能？" class="headerlink" title="为什么指令重排序可以提高性能？"></a>为什么指令重排序可以提高性能？</h2><p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。</p><p>但是，流水线技术最害怕<strong>中断</strong>，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。</p><p>我们分析一下下面这个代码的执行情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line">d = e - f ;</span><br></pre></td></tr></table></figure><p>先加载b、c（<strong>注意，即有可能先加载b，也有可能先加载c</strong>），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p><p>为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。</p><p>综上所述，<strong>指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</strong></p><p>指令重排一般分为以下三种：</p><ul><li><p><strong>编译器优化重排</strong></p><p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令并行重排</strong></p><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p></li><li><p><strong>内存系统重排</strong></p><p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0001.png"><p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。 以下数据有依赖关系，不能重排序。</p><p>写后读：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1; </span><br><span class="line">int b &#x3D; a;</span><br></pre></td></tr></table></figure><p>写后写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1; </span><br><span class="line">int a &#x3D; 2;</span><br></pre></td></tr></table></figure><p>读后写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1; </span><br><span class="line">int b &#x3D; a; </span><br><span class="line">int a &#x3D; 2;</span><br></pre></td></tr></table></figure><p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 1; </span><br><span class="line">int b &#x3D; 2; </span><br><span class="line">int c &#x3D; a + b;</span><br></pre></td></tr></table></figure><h1 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h1><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。</p><h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><h3 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h3><p>冯诺依曼，提出计算机由五大组成部分，输入设备，输出设备存储器，控制器，运算器。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0002.png"><p>输入设备：鼠标，键盘等等</p><p>输出设备：显示器，打印机等等</p><p>存储器：内存条</p><p>运算器和控制器组成CPU</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器，是计算机的控制和运算的核心，我们的程序终都会变成指令让CPU去执行，处理程序中 的数据。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>我们的程序都是在内存中运行的，内存会保存程序运行时的数据，供CPU处理。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内 存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0003.png"><p>CPU Cache分成了三个级别: L1， L2， L3。级别越小越接近CPU，速度也更快，同时也代表着容量越小。速度越快的价格越贵。</p><p>1、L1是接近CPU的，它容量小，例如32K，速度快，每个核上都有一个L1 Cache。</p><p>2、L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。</p><p>3、L3 Cache是三级缓存中大的一级，例如12MB，同时也是缓存中慢的一级，在同一个CPU插槽 之间的核共享一个L3 Cache。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0004.png"><p>上面的图中有一个Latency指标。比如Memory这个指标为59.4ns，表示CPU在操作内存的时候有59.4ns的延迟，一级缓存最快只有1.2ns。</p><p><strong>CPU处理数据的流程</strong></p><p>Cache的出现是为了解决CPU直接访问内存效率低下问题的。</p><p>1、程序在运行的过程中，CPU接收到指令 后，它会先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写人，当运算结束之后，再将CPUCache中的新数据刷新 到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能 力。</p><p>2、但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二 级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>1、Java Memory Molde (Java内存模型/JMM)，千万不要和Java内存结构（JVM划分的那个堆，栈，方法区）混淆。关于“Java内存模型”的权威解释，参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf%E3%80%82">https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf。</a></p><p>2、 Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。 Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，具体如下。</p><p>3、Java内存模型根据官方的解释，主要是在说两个关键字，一个是<code>volatile</code>，一个是<code>synchronized</code>。</p><p><strong>主内存</strong></p><p>主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</p><p><strong>工作内存</strong></p><p>每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0005.png"><p>Java的线程不能直接在主内存中操作共享变量。而是首先将主内存中的共享变量赋值到自己的工作内存中，再进行操作，操作完成之后，刷回主内存。</p><p><strong>Java内存模型的作用</strong></p><p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。 synchronized,volatile</p><h2 id="CPU缓存，内存与Java内存模型的关系"><a href="#CPU缓存，内存与Java内存模型的关系" class="headerlink" title="CPU缓存，内存与Java内存模型的关系"></a>CPU缓存，内存与Java内存模型的关系</h2><ul><li>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行终都会映射到硬件处理器上进行执行。 但Java内存模型和硬件内存架构并不完全一致。</li><li>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响， 因为JMM只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬 件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说， Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</li></ul><p>JMM内存模型与CPU硬件内存架构的关系：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0006.png"><p>工作内存：可能对应CPU寄存器，也可能对应CPU缓存，也可能对应内存。</p><ul><li>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量 存储到内存和从内存中读取变量这样的底层细节，Java内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</li></ul><h2 id="再谈可见性"><a href="#再谈可见性" class="headerlink" title="再谈可见性"></a>再谈可见性</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0008.png"><p>1、图中所示是 个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的1级缓存，在有些架构里面还有1个所有 CPU 共享的2级缓存。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 或者 L2 存或者 CPU 寄存器。</p><p>2、一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，然后对工作内存里的变量进行处理，处理完后将变量值更新到主内存。 </p><p>3、那么假如线程A和线程B同时处理一个共享变量，会出现什么情况?我们使用图所示CPU架构，假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空，那么这时候由于Cache的存在，将会导致内存不可见问题，具体看下面的分析。</p><ul><li> 线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值，假如为0。然后把X=0的值缓存到两级缓存，线程A修改X的值为1，然后将其写入两级Cache，并且刷新到主内存。线程A操作完毕后，线程A所在的CPU的两级Cache 内和主内存里面的X的值都是1。</li><li> 线程B获取X的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了，所以返回X=1;到这里一切都是正常的，因为这时候主内存中也是X=1。然后线程B修改X的值为2，并将其存放到线程2所在的一级Cache和共享二级Cache中，最后更新主内存中X 的值为2;到这里一切都是好的。</li><li> 线程A 这次又需要修改X的值，获取时一级缓存命中，并且X=1，到这里问题就出现了，明明线程B已经把X的值修改为了2，为何线程A获取的还是1呢?这就是共享变量的内存不可见问题，也就是线程B写入的值对线程A不可见。那么如何解决共享变量内存不可见问题?使用Java中的volatile和synchronized关键字就可以解决这个问题，下面会有讲解。</li></ul><h1 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h1><p>为了保证数据交互时数据的正确性，Java内存模型中定义了8种操作来完成这个交互过程，这8种操作本身都是原子性的。虚拟机实现时必须保证下面 提及的每一种操作都是原子的、不可再分的。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0009.png"><blockquote><p>(1)lock:作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</p><p>(2)unlock:作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</p><p>(3)read:作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p><p>(4)load:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p>(5)use:作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时都会执行这个操作。</p><p>(6)assign:作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p>(7)store:作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write使用。</p><p>(8)write:作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p></blockquote><p>注意:</p><ol><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中</li><li>lock和unlock操作只有加锁才会有。synchronized就是通过这样来保证可见性的。</li></ol><p>如果没有synchronized，那就是下面这样的</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0010.png"><h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><h2 id="什么是happens-before"><a href="#什么是happens-before" class="headerlink" title="什么是happens-before?"></a>什么是happens-before?</h2><p>一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p><p>JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong></p><p>而对于程序员，JMM提供了<strong>happens-before规则</strong>（JSR-133规范），满足了程序员的需求——<strong>简单易懂，并且提供了足够强的内存可见性保证。</strong>换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。</p><p>JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。</p><p>happens-before关系的定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li><strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></li></ol><p>happens-before关系本质上和as-if-serial语义是一回事。</p><p>as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。</p><p>总之，<strong>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</strong></p><h2 id="天然的happens-before关系"><a href="#天然的happens-before关系" class="headerlink" title="天然的happens-before关系"></a>天然的happens-before关系</h2><p>在Java中，有以下天然的happens-before关系：</p><ul><li><p>1、程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p></li><li><p>2、锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作，比如说在代码里有先对一个lock.lock()，lock.unlock()，lock.lock()</p></li><li><p>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，volatile变量写，再是读，必须保证是先写，再读</p></li><li><p>4、传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p></li><li><p>5、线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作，thread.start()，thread.interrupt()</p></li><li><p>6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>7、线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li><p>8、对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p></li></ul><p>上面这8条原则的意思很显而易见，就是程序中的代码如果满足这个条件，就一定会按照这个规则来保证指令的顺序。</p><p><strong>举例1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// A操作</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">// B操作</span></span><br><span class="line"><span class="keyword">int</span> sum = a + b;<span class="comment">// C 操作</span></span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>根据以上介绍的happens-before规则，假如只有一个线程，那么不难得出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&gt; A happens-before B </span><br><span class="line">2&gt; B happens-before C </span><br><span class="line">3&gt; A happens-before C</span><br></pre></td></tr></table></figure><p>注意，真正在执行指令的时候，其实JVM有可能对操作A &amp; B进行重排序，因为无论先执行A还是B，他们都对对方是可见的，并且不影响执行结果。</p><p>如果这里发生了重排序，这在视觉上违背了happens-before原则，但是JMM是允许这样的重排序的。</p><p>所以，我们只关心happens-before规则，不用关心JVM到底是怎样执行的。只要确定操作A happens-before操作B就行了。</p><p>重排序有两类，JMM对这两类重排序有不同的策略：</p><ul><li>会改变程序执行结果的重排序，比如 A -&gt; C，JMM要求编译器和处理器都禁止这种重排序。</li><li>不会改变程序执行结果的重排序，比如 A -&gt; B，JMM对编译器和处理器不做要求，允许这种重排序。</li></ul><p><strong>举例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    prepare();</span><br><span class="line"></span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于准备好的资源进行操作</span></span><br><span class="line">    execute();</span><br></pre></td></tr></table></figure><p>这8条原则是避免说出现乱七八糟扰乱秩序的指令重排，要求是这几个重要的场景下，比如是按照顺序来，但是8条规则之外，可以随意重排指令。</p><p>比如这个例子，如果用volatile来修饰flag变量，一定可以让prepare()指令在flag = true之前先执行，这就禁止了指令重排。</p><p>因为volatile要求的是，volatile前面的代码一定不能指令重排到volatile变量操作后面，volatile后面的代码也不能指令重排到volatile前面。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile不保证原子性，只保证可见性和禁止指令重排</p><h2 id="CPU术语介绍"><a href="#CPU术语介绍" class="headerlink" title="CPU术语介绍"></a>CPU术语介绍</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0011.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 执行单例构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo(); <span class="comment">//pos_1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>pos_1处的代码转换成汇编代码如下</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);</span><br><span class="line">0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure><h2 id="volatile保证可见性原理"><a href="#volatile保证可见性原理" class="headerlink" title="volatile保证可见性原理"></a>volatile保证可见性原理</h2><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架 构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。 </p><p>1）将当前处理器缓存行的数据写回到系统内存。 </p><p>2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 </p><p>​    为了提高处理速度，处理器不直接和主内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的 变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现MESI缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 </p><blockquote><p>注意：lock前缀指令是同时保证可见性和有序性（也就是禁止指令重排）的</p></blockquote><blockquote><p>注意：lock前缀指令相当于一个内存屏障【后文讲】</p></blockquote><h2 id="volatile禁止指令重排的原理"><a href="#volatile禁止指令重排的原理" class="headerlink" title="volatile禁止指令重排的原理"></a>volatile禁止指令重排的原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// step 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// step 3</span></span><br><span class="line">            System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JSR-133之前的旧的Java内存模型中，是允许volatile变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行：</p><ol><li>线程A写volatile变量，step 2，设置flag为true；</li><li>线程B读同一个volatile，step 3，读取到flag为true；</li><li>线程B读普通变量，step 4，读取到 a = 0；</li><li>线程A修改普通变量，step 1，设置 a = 1；</li></ol><p>可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p><p>所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的<strong>线程间的通信机制</strong>，<strong>JSR-133</strong>专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。</p><p>编译器还好说，JVM是怎么还能限制处理器的重排序的呢？它是通过<strong>内存屏障</strong>来实现的。</p><p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p><ol><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li></ol><blockquote><p>注意这里的缓存主要指的是上文说的CPU缓存，如L1，L2等</p></blockquote><h3 id="保守策略下"><a href="#保守策略下" class="headerlink" title="保守策略下"></a>保守策略下</h3><ul><li><p>在每个volatile写操作的前面插入一个StoreStore屏障。 </p></li><li><p>在每个volatile写操作的后面插入一个StoreLoad屏障。 </p></li><li><p>在每个volatile读操作的前面插入一个LoadLoad屏障。 </p></li><li><p>在每个volatile读操作的后面插入一个LoadStore屏障。</p></li></ul><p>编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的JMM内存屏障插入策略</strong>，但它可以保证在任意处理器平台，任意的程序中都能 得到正确的volatile内存语义。 </p><blockquote><p>再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作</p><p><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，这个屏障会吧Store1强制刷新到内存，保证Store1的写入操作对其它处理器可见。<br><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p></blockquote><p>对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：</p><blockquote><p>第一个volatile读;</p><p>LoadLoad屏障；</p><p>第二个volatile读；</p><p>LoadStore屏障</p></blockquote><p><strong>1、下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0012.png"><blockquote><p>图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任 意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与 后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面 是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确 实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile 读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时， 选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率</p></blockquote><p><strong>2、下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0013.png"><blockquote><p>图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。 LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。 上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p></blockquote><p><strong>优化举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = v1; <span class="comment">// 第一个volatile读</span></span><br><span class="line">            <span class="keyword">int</span> j = v2; <span class="comment">// 第二个volatile读</span></span><br><span class="line">            a = i + j; <span class="comment">// 普通写</span></span><br><span class="line">            v1 = i + <span class="number">1</span>; <span class="comment">// 第一个volatile写</span></span><br><span class="line">            v2 = j * <span class="number">2</span>; <span class="comment">// 第二个 volatile写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他方法 &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0014.png"><p>​    注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插入一个StoreLoad屏障。 </p><p>​    上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，图中除最后的StoreLoad屏障外，其他的屏障都会被省略。</p><h3 id="X86处理器优化"><a href="#X86处理器优化" class="headerlink" title="X86处理器优化"></a>X86处理器优化</h3><p>前面保守策略下的volatile读和写，在X86处理器平台可以优化成如下图所示。 </p><p>X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作 做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。 </p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/Second_stage/0015.png"><h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><blockquote><p>下面的代码在前面可能已经写过了，这里总结一下</p></blockquote><p>从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。</p><p>在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。所以<strong>在功能上，锁比volatile更强大；在性能上，volatile更有优势</strong>。</p><p>在禁止重排序这一点上，volatile也是非常有用的。比如我们熟悉的单例模式，其中有一种实现方式是“双重锁检查”，比如这样的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// 不使用volatile关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 第7行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 第10行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 第10行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以分解为以下三个步骤</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br></pre></td></tr></table></figure><p>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</p><p>所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发体系-第一阶段-多线程基础知识</title>
      <link href="post/efc79183.html"/>
      <url>post/efc79183.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序、进程、线程的理解"><a href="#程序、进程、线程的理解" class="headerlink" title="程序、进程、线程的理解"></a>程序、进程、线程的理解</h1><p>1、程序(programm)<br>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p><p>2、进程(process)<br>概念：程序的一次执行过程，或是正在运行的一个程序。<br>说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p><p>3、线程(thread)<br>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。<br>说明：线程作为CPU调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0001.png"><p>补充：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0002.png"><p>进程可以细化为多个线程。<br>每个线程，拥有自己独立的：栈、程序计数器<br>多个线程，共享同一个进程中的结构：方法区、堆。</p><h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><h2 id="单核CPU与多核CPU的理解"><a href="#单核CPU与多核CPU的理解" class="headerlink" title="单核CPU与多核CPU的理解"></a>单核CPU与多核CPU的理解</h2><ul><li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。</li><li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li><li>一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li></ul><h2 id="并行与并发的理解"><a href="#并行与并发的理解" class="headerlink" title="并行与并发的理解"></a>并行与并发的理解</h2><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。<br>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事</p><h1 id="创建线程的几种方法"><a href="#创建线程的几种方法" class="headerlink" title="创建线程的几种方法"></a>创建线程的几种方法</h1><h2 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h2><p>多线程的创建，方式一：继承于Thread类</p><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()</li></ol><ul><li>例子：遍历100以内的所有的偶数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//问题一：我们不能通过直接调用run()的方式启动线程。</span></span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。</span></span><br><span class="line"><span class="comment">        会报IllegalThreadStateException</span></span><br><span class="line"><span class="comment">        */</span>    </span><br><span class="line"><span class="comment">//        t1.start();</span></span><br><span class="line">        <span class="comment">//我们需要重新创建一个线程的对象</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下操作仍然是在main线程中执行的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i + <span class="string">&quot;***********main()************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h2><p>1、创建多线程的方式二：实现Runnable接口</p><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><p>2、 比较创建线程的两种方式。<br> 开发中：优先选择：实现Runnable接口的方式<br> 原因：实现的方式没有类的单继承性的局限性，实现的方式更适合来处理多个线程有共享数据的情况。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;</span></span><br><span class="line"><span class="comment">        调用了Runnable类型的target的run()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h2><p> 联系：public class Thread implements Runnable<br> 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p><h3 id="Runnable接口构造线程源码"><a href="#Runnable接口构造线程源码" class="headerlink" title="Runnable接口构造线程源码"></a>Runnable接口构造线程源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面是Thread类的部分源码*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.用Runnable接口创建线程时会进入这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接着调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.再调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="comment">//4.最后在这里将Runnable接口(target)赋值给Thread自己的target成员属性     </span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果你是实现了runnable接口，那么在上面的代码中target便不会为null，那么最终就会通过重写的</span></span><br><span class="line"><span class="comment">规则去调用真正实现了Runnable接口(你之前传进来的那个Runnable接口实现类)的类里的run方法*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、多线程的设计之中，使用了代理设计模式的结构，用户自定义的线程主体只是负责项目核心功能的实现，而所有的辅助实现全部交由Thread类来处理。<br>2、在进行Thread启动多线程的时候调用的是start()方法，而后找到的是run()方法，但通过Thread类的构造方法传递了一个Runnable接口对象的时候，那么该接口对象将被Thread类中的target属性所保存，在start()方法执行的时候会调用Thread类中的run()方法。而这个run()方法去调用实现了Runnable接口的那个类所重写过run()方法，进而执行相应的逻辑。多线程开发的本质实质上是在于多个线程可以进行同一资源的抢占，那么Thread主要描述的是线程，而资源的描述是通过Runnable完成的。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0003.png"><h3 id="Thread类构造线程源码"><a href="#Thread类构造线程源码" class="headerlink" title="Thread类构造线程源码"></a>Thread类构造线程源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread t2 = <span class="keyword">new</span> MyThread(); <span class="comment">//这个构造函数会默认调用Super();也就是Thread类的无参构造</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码从上往下顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*由于这里是通过继承Thread类来实现的线程，那么target这个东西就是Null。但是因为你继承</span></span><br><span class="line"><span class="comment">了Runnable接口并且重写了run()，所以最终还是调用子类的run()*/</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最直观的代码描述"><a href="#最直观的代码描述" class="headerlink" title="最直观的代码描述"></a>最直观的代码描述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;：卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window t1 = <span class="keyword">new</span> Window();</span><br><span class="line">        Window t2 = <span class="keyword">new</span> Window();</span><br><span class="line">        Window t3 = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:卖票，票号为：&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window1 w = <span class="keyword">new</span> Window1();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、继承Thread类的方式，new了三个Thread，实际上是有300张票。</p><p>2、实现Runnable接口的方式，new了三个Thread，实际上是有100张票。</p><p>3、也就是说实现Runnable接口的线程中，成员属性是所有线程共有的。但是继承Thread类的线程中，成员属性是各个线程独有的，其它线程看不到，除非采用static的方式才能使各个线程都能看到。</p><p>4、就像上面说的Runnable相当于资源，Thread才是线程。用Runnable创建线程时，new了多个Thread，但是传进去的参数都是同一个Runnable（资源）。用Thread创建线程时，就直接new了多个线程，每个线程都有自己的Runnable（资源）。在Thread源码中就是用target变量（这是一个Runnable类型的变量）来表示这个资源。</p><p>5、同时因为这两个的区别，在并发编程中，继承了Thread的子类在进行线程同步时不能将成员变量当做锁，因为多个线程拿到的不是同一把锁，不过用static变量可以解决这个问题。而实现了Runnable接口的类在进行线程同步时没有这个问题。</p><h2 id="实现Callable接口创建线程"><a href="#实现Callable接口创建线程" class="headerlink" title="实现Callable接口创建线程"></a>实现Callable接口创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Callable实现多线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;<span class="comment">//线程的主体类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*******线程执行，x=&quot;</span> + x + <span class="string">&quot;********&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程执行完毕&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回数据&quot;</span> + task.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable最主要的就是提供带有返回值的call方法来创建线程。不过Callable要和Future实现类连着用，关于Future的一系列知识会在后面几个系列讲到。</p><h1 id="策略模式在Thread和Runnable中的应用"><a href="#策略模式在Thread和Runnable中的应用" class="headerlink" title="策略模式在Thread和Runnable中的应用"></a>策略模式在Thread和Runnable中的应用</h1><p>Runnable接口最重要的方法—–run方法，使用了<strong>策略者模式</strong>将执行的逻辑(run方法)和程序的执行单元(start0方法)分离出来，使用户可以定义自己的程序处理逻辑，更符合面向对象的思想。</p><h1 id="Thread的构造方法"><a href="#Thread的构造方法" class="headerlink" title="Thread的构造方法"></a>Thread的构造方法</h1><ul><li><p>创建线程对象Thread，<code>默认有一个线程名，以Thread-开头，从0开始计数</code>，如“Thread-0、Thread-1、Thread-2 …”</p></li><li><p>如果没有传递Runnable或者没有覆写Thread的run方法，<code>该Thread不会调用任何方法</code></p></li><li><p>如果传递Runnable接口的实例或者覆写run方法，则<code>会执行该方法的逻辑单元</code>（逻辑代码）</p></li><li><p>如果构造线程对象时，未传入ThreadGroup，<code>Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup</code>，此时子线程和父线程会在同一个ThreadGroup中</p></li><li><p>stackSize可以<code>提高线程栈的深度</code>，放更多栈帧，但是会<code>减少能创建的线程数目</code></p></li><li><p>stackSize默认是0，<code>如果是0，代表着被忽略，该参数会被JNI函数调用</code>，但是注意某些平台可能会失效，<code>可以通过“-Xss10m”设置</code></p></li></ul><p>具体的介绍可以看Java的API文档</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面是Thread 的部分源码*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓ ↓↓</span><br><span class="line">         ↓ ↓</span><br><span class="line">          ↓</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">↓ ↓↓</span><br><span class="line">         ↓ ↓</span><br><span class="line">          ↓</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//中间源码省略</span></span><br><span class="line">    <span class="keyword">this</span>.target = target;<span class="comment">//①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target; <span class="comment">//Thread类中的target属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123; <span class="comment">//②</span></span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>源码标记解读：</p><p>1、如果Thread类的构造方法传递了一个Runnable接口对象</p><p>①那么该接口对象将被Thread类中的target属性所保存。</p><p>②在start()方法执行的时候会调用Thread类中的run()方法。因为target不为null， target.run()就去调用实现Runnable接口的子类重写的run()。</p><p>2、如果Thread类的构造方传没传Runnable接口对象</p><p>①Thread类中的target属性保存的就是null。</p><p>②在start()方法执行的时候会调用Thread类中的run()方法。因为target为null，只能去调用继承Thread的子类所重写的run()。</p></blockquote><p>JVM一旦启动，虚拟机栈的大小已经确定了。但是如果你创建Thread的时候传了stackSize（该线程占用的stack大小），该参数会被JNI函数去使用。如果没传这个参数，就默认为0，表示忽略这个参数。注：stackSize在有一些平台上是无效的。</p><h1 id="start-源码"><a href="#start-源码" class="headerlink" title="start()源码"></a>start()源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();<span class="comment">//①</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>源码标记解读：</p><p>①当多次调用start()，会抛出throw new IllegalThreadStateException()异常。也就是每一个线程类的对象只允许启动一次，如果重复启动则就抛出此异常。</p></blockquote><h2 id="为什么线程的启动不直接使用run-而必须使用start-呢"><a href="#为什么线程的启动不直接使用run-而必须使用start-呢" class="headerlink" title="为什么线程的启动不直接使用run()而必须使用start()呢?"></a>为什么线程的启动不直接使用run()而必须使用start()呢?</h2><p>1、如果直接调用run()方法，相当于就是简单的调用一个普通方法。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0004.png"><p>2、run()的调用是在start0()这个Native C++方法里调用的</p><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态，这几个状态在Java源码中用枚举来表示。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0005.png"><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0006.png"><blockquote><p> 图中 wait到 runnable状态的转换中，<code>join</code>实际上是<code>Thread</code>类的方法，但这里写成了<code>Object</code>。</p></blockquote><p>1、由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>2、操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p><p>3、调用sleep()方法，会进入Blocked状态。sleep()结束之后，Blocked状态首先回到的是Runnable状态中的Ready（也就是可运行状态，但并未运行）。只有拿到了cpu的时间片才会进入Runnable中的Running状态。</p><h1 id="Thread常用API"><a href="#Thread常用API" class="headerlink" title="Thread常用API"></a>Thread常用API</h1><ul><li>获取当前存活的线程数：<code>public int activeCount()</code></li><li>获取当前线程组的线程的集合：<code>public int enumerate(Thread[] list)</code></li></ul><h1 id="一个Java程序有哪些线程？"><a href="#一个Java程序有哪些线程？" class="headerlink" title="一个Java程序有哪些线程？"></a>一个Java程序有哪些线程？</h1><p>1、当你调用一个线程start()方法的时候，此时至少有两个线程，一个是调用你的线程，还有一个是被你创建出来的线程。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面就是一个调用你的线程（main线程），一个被你创建出来的线程（t1，名字可能是Thread-0）</p><p>2、当JVM启动后，实际有多个线程，但是至少有一个非守护线程（比如main线程）。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0007.png"><ul><li><p>Finalizer：GC守护线程</p></li><li><p>RMI：Java自带的远程方法调用（秋招面试，有个面试官问过）</p></li><li><p>Monitor ：是一个守护线程，负责监听一些操作，也在main线程组中</p></li><li><p>其它：我用的是IDEA，其它的应该是IDEA的线程，比如鼠标监听啥的。</p></li></ul><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">100000</span>);<span class="comment">//①</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; done.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">//new</span></span><br><span class="line">    </span><br><span class="line">    t.setDaemon(<span class="keyword">true</span>);<span class="comment">//②</span></span><br><span class="line">t.start();</span><br><span class="line">    Thread.sleep(<span class="number">5_000</span>);   <span class="comment">//JDK1.7</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>源码标记解读：</p><p>①变量名为t的线程Thread-0，睡眠100秒。</p><p>②但是在主函数里Thread-0设置成了main线程的守护线程。所以5秒之后main线程结束了，即使在①这里守护线程还是处于睡眠100秒的状态，但由于他是守护线程，非守护线程main结束了，守护线程也必须结束。</p><p>1、但是如果Thread-0线程不是守护线程，即使main线程结束了，Thread-0线程仍然会睡眠100秒再结束。</p><ul><li>当主线程死亡后，守护线程会跟着死亡</li><li>可以帮助做一些辅助性的东西，如“心跳检测”</li><li>设置守护线程：<code>public final void setDaemon(boolean on)</code></li></ul></blockquote><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>A和B之间有一条网络连接，可以用守护线程来进行发送心跳，一旦A和B连接断开，非守护线程就结束了，守护线程（也就是心跳没有必要再发送了）也刚好断开。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread innerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Do some thing for health check.&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  innerThread.setDaemon(true);</span></span><br><span class="line">        innerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;T thread finish done.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//t.setDaemon(true);</span></span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置该线程为守护线程必须在启动它之前。如果t.start()之后，再t.setDaemon(true);</span></span><br><span class="line"><span class="comment">会抛出IllegalThreadStateException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>Do some thing for health check.<br>Do some thing for health check.<br>T thread finish done.          //此时main线程已经结束，但是由于innerThread还在发送心跳，应用不会关闭<br>Do some thing for health check.<br>Do some thing for health check.<br>Do some thing for health check.<br>Do some thing for health check.</p></blockquote><blockquote><p>守护线程还有其它很多用处，在后面的文章里还会有出现。</p></blockquote><h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><p><strong>例子1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i));</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    Optional.of(<span class="string">&quot;All of tasks finish done.&quot;</span>).ifPresent(System.out::println);</span><br><span class="line">    IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认传入的数字为0，这里是在main线程里调用了两个线程的join()，所以main线程会等到Thread-0和Thread-1线程执行完再执行它自己。</li><li>join必须在start方法之后，并且join()是对wait()的封装。（源码中可以清楚的看到）</li></ul><ul><li>也就是说，t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING或WAITING 状态。直到线程t完成，此线程再继续。</li><li>join也有人理解成插队，比如在main线程中调用t.join()，就是t线程要插main线程的队，main线程要去等待。</li></ul><p><strong>例子2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i));</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"><span class="comment">//        t1.join();</span></span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        Optional.of(<span class="string">&quot;All of tasks finish done.&quot;</span>).ifPresent(System.out::println);</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这里是在t2（<span style="color:red;font-weight:bold">我们以后就都用变量名来称呼线程了</span>）线程了。t1.join()了。所以t2线程会等待t1线程打印完，t2自己才会打印。然后t2.join()，main线程也要等待t2线程。总体执行顺序就是t1–&gt;t2–&gt;main</li><li>通过上方例子可以用join实现类似于CompletableFuture的异步任务编排。（后面会讲）</li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>1、Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p><p>2、记住中断只是一个状态，Java的方法可以选择对这个中断进行响应，也可以选择不响应。响应的意思就是写相对应的代码执行相对应的操作，不响应的意思就是什么代码都不写。</p><h2 id="几个方法"><a href="#几个方法" class="headerlink" title="几个方法"></a>几个方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span><br><span class="line"><span class="comment">2、注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span><br><span class="line"><span class="comment">如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="小tip"><a href="#小tip" class="headerlink" title="小tip"></a>小tip</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span><span class="comment">//这个会清除中断状态</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>为什么要这么设置呢？原因在于：</p><ul><li>interrupted()是一个静态方法，可以在Runnable接口实例中使用</li><li>isInterrupted()是一个Thread的实例方法，在重写Thread的run方法时使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.interrupted());</span><br><span class="line">        &#125;);  <span class="comment">//这个new Thread用的是runnable接口那个构造函数</span></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//这个new Thread用的就是Thread的空参构造</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说接口中不能调用Thread的实例方法，只能通过静态方法来判断是否发生中断</p><h2 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h2><p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p><blockquote><p>初学者肯定以为 thread.interrupt() 方法是用来暂停线程的，主要是和它对应中文翻译的“中断”有关。中断在并发中是常用的手段，请大家一定好好掌握。可以将中断理解为线程的状态，它的特殊之处在于设置了中断状态为 true 后，这几个方法会感知到：</p><ol><li><p>wait(), wait(long), wait(long, int), join(), join(long), join(long, int), sleep(long), sleep(long, int)</p><p>这些方法都有一个共同之处，方法签名上都有<code>throws InterruptedException</code>，这个就是用来响应中断状态修改的。</p></li><li><p>如果线程阻塞在 InterruptibleChannel 类的 IO 操作中，那么这个 channel 会被关闭。</p></li><li><p>如果线程阻塞在一个 Selector 中，那么 select 方法会立即返回。</p></li></ol><p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。然后执行相应的操作（通常就是跳到 catch 异常处）。</p><p>如果不是以上3种情况，那么，线程的 interrupt() 方法被调用，会将线程的中断状态设置为 true。</p><p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p></blockquote><blockquote><p>资料:  <a href="https://docs.oracle.com/javase/specs/index.html">Oracle官方文档</a>    —&gt;   <a href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html"> The Java® Language Specification Java SE 8 Edition</a>   —&gt;   第17章 Threads and Locks</p></blockquote><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p><p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p><p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。 </p><p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能<strong>感知</strong>到线程中断了。</p><h2 id="wait-中断测试"><a href="#wait-中断测试" class="headerlink" title="wait()中断测试"></a>wait()中断测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        MONITOR.wait(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;wait响应中断&quot;</span>);<span class="comment">//pos_1</span></span><br><span class="line">                        e.printStackTrace();<span class="comment">//pos_2</span></span><br><span class="line">                        System.out.println(isInterrupted());<span class="comment">//pos_3</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep响应中断&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(t.isInterrupted());<span class="comment">//pos_4</span></span><br><span class="line">    t.interrupt();</span><br><span class="line">    System.out.println(t.isInterrupted());<span class="comment">//pos_5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注释掉e.printStackTrace();的输出</p><p>false                        //pos_4<br>true                         //pos_5<br>wait响应中断            //pos_1<br>false                         //pos_3        </p></blockquote><h2 id="join中断测试"><a href="#join中断测试" class="headerlink" title="join中断测试"></a>join中断测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread main = Thread.currentThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        main.interrupt();  <span class="comment">//pos_1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    t.join();  <span class="comment">//pos_2</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、pos_2这里join的是main线程，所以pos_1这里需要中断main线程，才能收到中断信息。</p><h1 id="关闭线程"><a href="#关闭线程" class="headerlink" title="关闭线程"></a>关闭线程</h1><h2 id="优雅的关闭-通过一个Boolean"><a href="#优雅的关闭-通过一个Boolean" class="headerlink" title="优雅的关闭(通过一个Boolean)"></a>优雅的关闭(通过一个Boolean)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start) &#123;</span><br><span class="line">           <span class="comment">//执行相应的工作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">    worker.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过判断中断状态"><a href="#通过判断中断状态" class="headerlink" title="通过判断中断状态"></a>通过判断中断状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//pos_1    </span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">    worker.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、但是如果pos_1位置有一个很费时的IO操作，就没有机会执行到if判断那里，也就不能关闭线程。所以就需要下面的暴力方法</p><h2 id="暴力关闭（守护线程）"><a href="#暴力关闭（守护线程）" class="headerlink" title="暴力关闭（守护线程）"></a>暴力关闭（守护线程）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread executeThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        executeThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Thread runner = <span class="keyword">new</span> Thread(task);</span><br><span class="line">                runner.setDaemon(<span class="keyword">true</span>);<span class="comment">//创建一个守护线程，让守护线程来执行工作</span></span><br><span class="line"></span><br><span class="line">                runner.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、要让executeThread等守护线程执行完，才能执行executeThread自己的逻辑。不然守护线程</span></span><br><span class="line"><span class="comment"> * 可能就来不及执行真正的工作就死了。所以这里要join</span></span><br><span class="line"><span class="comment"> * 2、runner.join()，所以实际上等待的是executeThread       //pos_1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                    runner.join();</span><br><span class="line">                    finished = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        executeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">long</span> mills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!finished) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((System.currentTimeMillis() - currentTime) &gt;= mills) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务超时，需要结束他!&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * pos_1那里，由于实际等待的是executeThread，所以这里中断executeThread。</span></span><br><span class="line"><span class="comment">                 * pos_1就可以捕获到中断，执行线程(executeThread)就结束了，进而真正执行任务的</span></span><br><span class="line"><span class="comment">                 * 守护线程runner也结束了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                executeThread.interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executeThread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行线程被打断!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCloseForce</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadService service = <span class="keyword">new</span> ThreadService();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//load a very heavy resource. 模拟任务超时</span></span><br><span class="line">            <span class="comment">/*while (true) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：分布式文件拷贝，如果拷贝的时间过长，则关闭该程序，防止程序一直阻塞。或者其他执行耗时很长的任务</p><p>守护线程的应用场景有很多</p><h1 id="并发编程中的三个问题"><a href="#并发编程中的三个问题" class="headerlink" title="并发编程中的三个问题"></a>并发编程中的三个问题</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><p>可见性（Visibility）：是指一个线程对共享变量进行修改，另一个先立即得到修改后的新值。</p><h3 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 笔记</span></span><br><span class="line"><span class="comment"> * 1.当没有加Volatile的时候,while循环会一直在里面循环转圈</span></span><br><span class="line"><span class="comment"> * 2.当加了之后Volatile,由于可见性,一旦num改了之后,就会通知其他线程</span></span><br><span class="line"><span class="comment"> * 3.还有注意的时候不能用if,if不会重新拉回来再判断一次。(也叫做虚假唤醒)</span></span><br><span class="line"><span class="comment"> * 4.案例演示:一个线程对共享变量的修改,另一个线程不能立即得到新值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video04_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//睡3秒之后再修改num,防止A线程先修改了num,那么到while循环的时候就会直接跳出去了</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come out&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//只有当num不等于0的时候,才会跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出，并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性（Atomicity）：在一次或多次操作中，要么所有的操作都成功执行并且不会受其他因素干扰而中 断，要么所有的操作都不执行或全部执行失败。不会出现中间状态</p><h3 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h3><p>案例演示:5个线程各执行1000次 i++;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/23 15:50</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: volatile不保证原子性的代码验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video05_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData03 myData03 = <span class="keyword">new</span> MyData03();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                     myData03.increment();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;,<span class="string">&quot;线程&quot;</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要等待上面的20个线程计算完之后再查看计算结果</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;20个线程执行完之后num:\t&quot;</span> + myData03.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData03</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、控制台输出：（由于并发不安全，每次执行的结果都可能不一样）</p><blockquote><p>20个线程执行完之后num:    19706</p></blockquote><p>正常来说，如果保证原子性的话，20个线程执行完，结果应该是20000。控制台输出的值却不是这个，说明出现了原子性的问题。</p><p>2、使用javap反汇编class文件，对于num++可以得到下面的字节码指令：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">9: getstatic     #12                 // Field number:I   取值操作</span><br><span class="line"><span class="number">12</span>: iconst_1 </span><br><span class="line"><span class="number">13</span>: iadd </span><br><span class="line">14: putstatic     #12                 // Field number:I  赋值操作</span><br></pre></td></tr></table></figure><p>由此可见num++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多线程情况下就可能会出现问题。</p><p>比如num刚开始值是7。A线程在执行13: iadd时得到num值是8，B线程又执行9: getstatic得到前一个值是7。马上A线程就把8赋值给了num变量。但是B线程已经拿到了之前的值7，B线程是在A线程真正赋值前拿到的num值。即使A线程最终把值真正的赋给了num变量，但是B线程已经走过了getstaitc取值的这一步，B线程会继续在7的基础上进行++操作，最终的结果依然是8。本来两个线程对7进行分别进行++操作，得到的值应该是9，因为并发问题，导致结果是8。</p><p>3、并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共 享变量，干扰了前一个线程的操作。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化（重排序）来加快速度，会导致程序终的执行顺序不一定就是我们编写代码时的顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> SingletonDemo() 是被分成以下 <span class="number">3</span> 步完成</span><br><span class="line"> memory = allocate();     分配对象内存空间</span><br><span class="line"> instance(memory);        初始化对象</span><br><span class="line"> instance = memory;   设置 instance 指向刚分配的内存地址，此时 instance != <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>步骤2 和 步骤3 不存在数据依赖关系，重排与否的执行结果单线程中是一样的。这种指令重排是被 Java 允许的。当 3 在前时，instance 不为 null，但实际上初始化工作还没完成，会变成一个返回 null 的getInstance。这时候数据就出现了问题。</p><h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p>jcstress是java并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a> 修改pom文件，添加依赖：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;   </span><br><span class="line"> &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt;    </span><br><span class="line">&lt;artifactId&gt;jcstress-core&lt;/artifactId&gt;    </span><br><span class="line">&lt;version&gt;$&#123;jcstress.version&#125;&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="comment">// @Outcome: 如果输出结果是1或4，我们是接受的(ACCEPTABLE)，并打印ok</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="comment">//如果输出结果是0，我们是接受的并且感兴趣的，并打印danger</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span> <span class="comment">//@Actor：表示会有多个线程来执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、实际上上面两个方法会有很多线程来执行，为了讲解方便，我们只提出线程1和线程2来讲解。</p><p>2、I_Result 是一个保存int类型数据的对象，有一个属性 r1 用来保存结果，在多线程情况下可能出现几种结果？</p><p>情况1：线 程1先执行actor1，这时ready = false，所以进入else分支结果为1。</p><p>情况2：线程2执行到actor2，执行了num = 2;和ready = true，线程1执行，这回进入 if 分支，结果为 4。</p><p>情况3：线程2先执行actor2，只执行num = 2；但没来得及执行 ready = true，线程1执行，还是进入 else分支，结果为1。 </p><p>情况4：0，发生了指令重排</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程2执行的代码</span></span><br><span class="line">   <span class="comment">// @Actor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;    <span class="comment">//pos_1</span></span><br><span class="line">       ready = <span class="keyword">true</span>;<span class="comment">//pos_2</span></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>pos_1处代码和pos_2处代码没有什么数据依赖关系，或者说没有因果关系。Java可能对其进行指令重排，排成下面的顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程2执行的代码</span></span><br><span class="line">   <span class="comment">// @Actor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">   ready = <span class="keyword">true</span>;<span class="comment">//pos_2</span></span><br><span class="line">       num = <span class="number">2</span>;    <span class="comment">//pos_1</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此时如果线程2先执行到<code>ready = true;</code>还没来得及执行 <code>num = 2;</code> 。线程1执行，直接进入if分支，此时num默认值为0。 得到的结果也就是0。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><blockquote><p>1、关于可见性，重排序等等的硬件原理，MESI缓存一致性，内存屏障，JMM等等这些，请看我的后面文章。第一阶段只是介绍下用法，不涉及原理。</p><p>2、如果你在第一篇文章没有找到你想要的内容，请看我后面的内容。并发的体系，我自认为讲的还是比较全面的。</p></blockquote><h2 id="volatile保证可见性代码"><a href="#volatile保证可见性代码" class="headerlink" title="volatile保证可见性代码"></a>volatile保证可见性代码</h2><blockquote><p>读者可以把两个代码运行一下，就能明显看到不加volatile的死循环（就是程序一直显示没结束）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 笔记</span></span><br><span class="line"><span class="comment"> * 1.当没有加Volatile的时候,while循环会一直在里面转圈</span></span><br><span class="line"><span class="comment"> * 2.当加了之后Volatile,由于可见性,一旦num改了之后,就会通知其他线程</span></span><br><span class="line"><span class="comment"> * 3.还有注意的时候不能用if,if不会重新拉回来再判断一次</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video04_02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData2 myData = <span class="keyword">new</span> MyData2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//睡3秒之后再修改num,防止A线程先修改了num,那么到while循环的时候就会直接跳出去了</span></span><br><span class="line">            myData.addTo60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come out&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(myData.num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//只有当num不等于0的时候,才会跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile保证有序性代码"><a href="#volatile保证有序性代码" class="headerlink" title="volatile保证有序性代码"></a>volatile保证有序性代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="comment">// @Outcome: 如果输出结果是1或4，我们是接受的(ACCEPTABLE)，并打印ok</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="comment">//如果输出结果是0，我们是接受的并且感兴趣的，并打印danger</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span> <span class="comment">//@Actor：表示会有多个线程来执行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以将运行结果对比着来看，就能发现区别。</p><p>volatile只能保证可见性和有序性（禁止指令重排），无法保证原子性。</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>volatile自己虽然不能保证原子性，但是和CAS结合起来就可以保证原子性了。CAS+volatile一起用就可以同时解决<strong>并发编程中的三个问题</strong>了，保证并发安全。</p><h2 id="CAS-是什么？"><a href="#CAS-是什么？" class="headerlink" title="CAS 是什么？"></a>CAS 是什么？</h2><ul><li><p>CAS：比较并交换compareAndSet,它是一条 CPU 并发原语，它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子性的。</p></li><li><p>例: AtomicInteger 的 compareAndSet(‘期望值’,’设置值’) 方法，期望值与目标值一致时，修改目标变量为设置值，期望值与目标值不一致时，返回 false 和最新主存的变量值</p></li><li><p>CAS 的底层原理</p><pre><code>例: AtomicInteger.getAndIncrement()  调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令      这是一种完全依赖于硬件的功能，通过它实现原子操作。      原语的执行必须是连续的，在执行过程中不允许被中断，CAS 是 CUP 的一条原子指令。</code></pre></li><li><p>CAS的思想就是乐观锁的思想</p></li></ul><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>在JUC并发包中，CAS和AtomicInteger（原子类的value值都被volatile修饰了）一起保证了并发安全。下面我们以AtomicInteger.getAndIncrement() 方法讲一下。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0009.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unsafe: rt.jar/sun/misc/Unsafe.class</span></span><br><span class="line"><span class="comment"> *   Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地&lt;native&gt;方法来访问</span></span><br><span class="line"><span class="comment"> * Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据</span></span><br><span class="line"><span class="comment"> * Unsafe 其内部方法都是 native 修饰的，可以像 C 的指针一样直接操作内存</span></span><br><span class="line"><span class="comment"> * Java 中的 CAS 操作执行依赖于 Unsafe 的方法，直接调用操作系统底层资源执行程序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this: 当前对象</span></span><br><span class="line"><span class="comment"> * 变量 value 由 volatile 修饰，保证了多线程之间的内存可见性、禁止重排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * valueOffset: 内存地址</span></span><br><span class="line"><span class="comment"> * 表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1: 固定写死，原值加1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>,valueOffset,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unsafe.getAndAddInt()</span></span><br><span class="line"><span class="comment"> * getIntVolatile: 通过内存地址去主存中取对应数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * while(!this.compareAndSwapInt(var1,var2,var5,var5 + var4)):</span></span><br><span class="line"><span class="comment"> *  将本地 value 与主存中取出的数据对比，如果相同，对其作运算，</span></span><br><span class="line"><span class="comment"> * 此时返回 true，取反后 while 结束，返回最终值。</span></span><br><span class="line"><span class="comment"> *  如果不相同，此时返回 false，取反后 while 循环继续运行，此时为自旋锁&lt;重复尝试&gt;</span></span><br><span class="line"><span class="comment"> *由于 value 是被 volatile 修饰的，所以拿到主存中最新值，再循环直至成功。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1,<span class="keyword">long</span> var2,<span class="keyword">int</span> var4)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1,var2); <span class="comment">// 从主存中拷贝变量到本地内存</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1,var2,var5,var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS-代码演示"><a href="#CAS-代码演示" class="headerlink" title="CAS 代码演示"></a>CAS 代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        System.out.println(num.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">&quot;\t current num&quot;</span> + num.get());</span><br><span class="line">        System.out.println(num.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current num&quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CAS三大问题"><a href="#CAS三大问题" class="headerlink" title="CAS三大问题"></a>CAS三大问题</h2><ul><li><p>如果 CAS 长时间一直不成功，会给 CPU 带来很大的开销，在Java的实现中是一只通过while循环自旋CAS获取锁。</p></li><li><p>只能保证一个共享变量的原子操作</p></li><li><p>引出了 ABA 问题</p></li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h3 id="什么是ABA问题？"><a href="#什么是ABA问题？" class="headerlink" title="什么是ABA问题？"></a>什么是ABA问题？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/24 16:43</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: CAS引发的ABA问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video19_01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; num = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            num.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            num.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="comment">//保证A线程已经修改完</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> b = num.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>);</span><br><span class="line">            System.out.println(b + <span class="string">&quot;\t 当前最新值&quot;</span> + num.get().toString());</span><br><span class="line">        &#125;,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CAS 会导致 ABA 问题：</strong></p><p>例: A、B线程从主存取出变量 value</p><p>-&gt; A 在 N次计算中改变 value 的值<br>-&gt; A 最终计算结果还原 value 最初的值<br>-&gt; B 计算后，比较主存值与自身 value 值一致，修改成功</p><p>尽管各个线程的 CAS 都操作成功，但是并不代表这个过程就是没有问题的。</p><h3 id="ABA问题的解决"><a href="#ABA问题的解决" class="headerlink" title="ABA问题的解决"></a>ABA问题的解决</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 吕</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/24 16:49</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 功能描述: ABA问题的解决</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video19_02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; num = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stamp = num.getStamp();<span class="comment">//初始版本号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            num.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,num.getStamp(),num.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 版本号&quot;</span> + num.getStamp());</span><br><span class="line">            num.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,num.getStamp(),num.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 版本号&quot;</span> + num.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> b = num.compareAndSet(<span class="number">100</span>, <span class="number">209</span>, stamp, num.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(b + <span class="string">&quot;\t 当前版本号: \t&quot;</span> + num.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;当前最新值 \t&quot;</span> + num.getReference().toString());</span><br><span class="line">        &#125;,<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想很简单，可以很明显的看出来用版本号的方式解决了ABA的问题。</p><ul><li>除了对象值，AtomicStampedReference内部还维护了一个“状态戳”。</li><li>状态戳可类比为时间戳，是一个整数值，每一次修改对象值的同时，也要修改状态戳，从而区分相同对象值的不同状态。</li><li>当AtomicStampedReference设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功。</li></ul><h2 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h2><ul><li>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个方法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i=2,j=a合并一下ij=2a，然后用CAS来操作ij。从java1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li><li>所以一般来说为了同时解决ABA问题和只能保证一个共享变量，原子类使用时大部分使用的是<code>AtomicStampedReference</code></li></ul><h1 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h1><p>Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。</p><p>Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域，不能像C++中那样可以自己申请内存和释放内存。 <strong>Java中的Unsafe类为我们提供了类似C++手动管理内存的能力，同时也有了指针的问题。</strong></p><p>首先，Unsafe类是”final”的，不允许继承。且构造函数是private的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_FIELD_OFFSET = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此我们无法在外部对Unsafe进行实例化。</strong></p><h2 id="获取Unsafe"><a href="#获取Unsafe" class="headerlink" title="获取Unsafe"></a>获取Unsafe</h2><p>Unsafe无法实例化，那么怎么获取Unsafe呢？答案就是通过反射来获取Unsafe：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unsafe的功能如下图：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Java_concurrency/Source_code/First_stage/0008.png"><h2 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h2><p>JUC中大量运用了CAS操作，可以说CAS操作是JUC的基础，因此CAS操作是非常重要的。Unsafe中提供了int,long和Object的CAS操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="偏移量相关"><a href="#偏移量相关" class="headerlink" title="偏移量相关"></a>偏移量相关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>staticFieldOffset方法用于获取静态属性Field在对象中的偏移量，读写静态属性时必须获取其偏移量。</li><li>objectFieldOffset方法用于获取非静态属性Field在对象实例中的偏移量，读写对象的非静态属性时会用到这个偏移量</li></ul><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String var1, <span class="keyword">byte</span>[] var2, <span class="keyword">int</span> var3, <span class="keyword">int</span> var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, <span class="keyword">byte</span>[] var2, Object[] var3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; var1)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>defineClass方法定义一个类，用于动态地创建类。</li><li>defineAnonymousClass用于动态的创建一个匿名内部类。</li><li><code>allocateInstance</code>方法用于创建一个类的实例，但是不会调用这个实例的构造方法，如果这个类还未被初始化，则初始化这个类。</li><li>shouldBeInitialized方法用于判断是否需要初始化一个类。</li><li>ensureClassInitialized方法用于保证已经初始化过一个类。</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFooTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">geUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.l = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被初始化了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Unsafe unsafe = geUnsafe();</span><br><span class="line"></span><br><span class="line">        Simple s = (Simple) unsafe.allocateInstance(Simple.class);</span><br><span class="line">        System.out.println(s.getL());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><blockquote><p>0</p></blockquote><ul><li>可以发现，利用Unsafe获取实例，不会调用构造方法</li></ul><h2 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h2><p>通过Unsafe可以读写一个类的属性，即使这个属性是私有的，也可以对这个属性进行读写。</p><p>读写一个Object属性的相关方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>getInt用于从对象的指定偏移地址处读取一个int。</li><li>putInt用于在对象指定偏移地址处写入一个int。其他的primitive type也有对应的方法。</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFooTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">geUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Guard</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ACCESS_ALLOWED = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allow</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span> == ACCESS_ALLOWED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (allow())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我被允许工作....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Unsafe unsafe = geUnsafe();</span><br><span class="line">        Guard guard = <span class="keyword">new</span> Guard();</span><br><span class="line"></span><br><span class="line">        Field f = guard.getClass().getDeclaredField(<span class="string">&quot;ACCESS_ALLOWED&quot;</span>);</span><br><span class="line"></span><br><span class="line">        unsafe.putInt(guard,unsafe.objectFieldOffset(f),<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;强行赋值...&quot;</span>);</span><br><span class="line">        guard.work();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><blockquote><p>强行赋值…</p></blockquote><p>我被允许工作…</p><h2 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String var1, <span class="keyword">byte</span>[] var2, <span class="keyword">int</span> var3, <span class="keyword">int</span> var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, <span class="keyword">byte</span>[] var2, Object[] var3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; var1)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>defineClass方法定义一个类，用于动态地创建类。</li><li>defineAnonymousClass用于动态的创建一个匿名内部类。</li><li>allocateInstance方法用于创建一个类的实例，但是不会调用这个实例的构造方法，如果这个类还未被初始化，则初始化这个类。</li><li>shouldBeInitialized方法用于判断是否需要初始化一个类。</li><li>ensureClassInitialized方法用于保证已经初始化过一个类。</li></ul><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>loadFence：保证在这个屏障之前的所有读操作都已经完成。</li><li>storeFence：保证在这个屏障之前的所有写操作都已经完成。</li><li>fullFence：保证在这个屏障之前的所有读写操作都已经完成。</li></ul><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>park方法和unpark方法相信看过LockSupport类的都不会陌生，这两个方法主要用来挂起和唤醒线程。</li><li>LockSupport中的park和unpark方法正是通过Unsafe来实现的：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>monitorEnter方法和monitorExit方法用于加锁，Java中的synchronized锁就是通过这两个指令来实现的。</strong></p><h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><blockquote><p>synchronized可以同时保证可见性，有序性，原子性。这个东西就不讲了</p></blockquote><p>从JDk 1.6开始，JVM就对synchronized锁进行了很多的优化。synchronized说是锁，但是他的底层加锁的方式可能不同，偏向锁的方式来加锁，自旋锁的方式来加锁，轻量级锁的方式来加锁</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是JIT编译器对synchronized锁做的优化，在编译的时候，JIT会通过逃逸分析技术，来分析synchronized锁对象，是不是只可能被一个线程来加锁，没有其他的线程来竞争加锁，这个时候编译就不用加入monitorenter和monitorexit的指令。这就是，仅仅一个线程争用锁的时候，就可以消除这个锁了，提升这段代码的执行的效率，因为可能就只有一个线程会来加锁，不涉及到多个线程竞争锁</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个意思就是，JIT编译器如果发现有代码里连续多次加锁释放锁的代码，会给合并为一个锁，就是锁粗化，把一个锁给搞粗了，避免频繁多次加锁释放锁</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>这个意思就是说，monitorenter和monitorexit是要使用CAS操作加锁和释放锁的，开销较大，因此如果发现大概率只有一个线程会主要竞争一个锁，那么会给这个锁维护一个偏好（Bias），后面他加锁和释放锁，基于Bias来执行，不需要通过CAS，性能会提升很多。但是如果有偏好之外的线程来竞争锁，就要收回之前分配的偏好。可能只有一个线程会来竞争一个锁，但是也有可能会有其他的线程来竞争这个锁，但是其他线程唉竞争锁的概率很小。如果有其他的线程来竞争这个锁，此时就会收回之前那个线程分配的那个Bias偏好</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果偏向锁没能成功实现，就是因为不同线程竞争锁太频繁了，此时就会尝试采用轻量级锁的方式来加锁，就是将对象头的Mark Word里有一个轻量级锁指针，尝试指向持有锁的线程，然后判断一下是不是自己加的锁，如果是自己加的锁，那就执行代码就好了。如果不是自己加的锁，那就是加锁失败，说明有其他人加了锁，这个时候就是升级为重量级锁</p><h2 id="适应性锁"><a href="#适应性锁" class="headerlink" title="适应性锁"></a>适应性锁</h2><p>这是JIT编译器对锁做的另外一个优化，如果各个线程持有锁的时间很短，那么一个线程竞争锁不到，就会暂停，发生上下文切换，让其他线程来执行。但是其他线程很快释放锁了，然后暂停的线程再次被唤醒。也就是说在这种情况下，线程会频繁的上下文切换，导致开销过大。所以对这种线程持有锁时间很短的情况，是可以采取忙等策略的，也就是一个线程没竞争到锁，进入一个while循环不停等待，不会暂停不会发生线程上下文切换，等到机会获取锁就继续执行好了</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://blog.csdn.net/qq_43040688/article/details/103979628">https://blog.csdn.net/qq_43040688/article/details/103979628</a></li><li>《Java 并发编程艺术》</li><li>B站汪文君系列并发</li></ul><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>1、第一阶段只是简单的讲一下，在后面的系列里，会从硬件，C++源码层面讲解volatile，synchronized，内存屏障，MESI-缓存一致性等等进行讲解。</p><p>2、还有一些问题，在基础阶段可能不太好讲。比如中断这个东西，可能理解的云里雾里的，后面的系列讲到AQS的时候，结合Java源码再讲的话，你会非常好理解。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hugo简单搭建博客</title>
      <link href="post/9c420976.html"/>
      <url>post/9c420976.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo和Hugo"><a href="#Hexo和Hugo" class="headerlink" title="Hexo和Hugo"></a>Hexo和Hugo</h1><p>1、Hexo我个人认为最大的优点目前就是主题多，缺点就是生成静态文件 (hexo g) 速度慢。Hexo是基于Nodejs的，有很多插件，但是加载费时。并且当md文档成百的时候，可能hexo g一次几分钟，体验感不好（不过几分钟也还好，不是特别长），Hexo目前貌似也是在进行优化</p><p>2、Hugo使用自带的Go html模板实现， 速度快，基本上在 Hexo 上面几分钟，使用 Hugo 只需要十几秒钟。然而Hugo目前主题太少，找不到什么满意的主题。</p><p>3、我个人搭建博客比较喜欢漂亮的主题，所以目前用的Hexo。</p><h1 id="安装Hugo（Windows）"><a href="#安装Hugo（Windows）" class="headerlink" title="安装Hugo（Windows）"></a>安装Hugo（Windows）</h1><h2 id="二进制安装（推荐：简单、快速）"><a href="#二进制安装（推荐：简单、快速）" class="headerlink" title="二进制安装（推荐：简单、快速）"></a>二进制安装（推荐：简单、快速）</h2><p>到 <a href="https://github.com/gohugoio/hugo/releases">Hugo Releases</a> 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）</p><p>Mac下直接使用 <code>Homebrew</code> 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install hugo</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>1、二进制下载完成后是一个hugo.exe文件，然后配置到PATH环境变量中</p><p>2、<code>hugo version</code>验证是否安装成功</p><h2 id="创建站点"><a href="#创建站点" class="headerlink" title="创建站点"></a>创建站点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hugo new site Hugo_blog</span><br></pre></td></tr></table></figure><p>第四个命令自定义，就是生成的hugo文件夹名字。自此Hugo站点生成完毕，后面的主题配置我都会以我的Hugo_Blog为例说明。<strong>切记Hugo_Blog就是我的站点目录，路径千万别搞错了</strong></p><h1 id="主题安装（以Even为例）"><a href="#主题安装（以Even为例）" class="headerlink" title="主题安装（以Even为例）"></a>主题安装（以Even为例）</h1><p>1、在生成的<code>Hugo_blog</code>目录下执行以下命令。没有用过Git的可以先去简单安装一下，很简单。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/olOwOlo/hugo-theme-even themes/even</span><br></pre></td></tr></table></figure><p><strong>重要:</strong> 在主题的 <a href="https://github.com/olOwOlo/hugo-theme-even/tree/master/exampleSite"><code>exampleSite</code></a> 目录下有一个 <a href="https://github.com/olOwOlo/hugo-theme-even/blob/master/exampleSite/config.toml"><code>config.toml</code></a> 文件，<strong>将这个 <a href="https://github.com/olOwOlo/hugo-theme-even/blob/master/exampleSite/config.toml"><code>config.toml</code></a> 文件复制到你的站点目录下覆盖即可</strong>，根据自己的需求更改。</p><p><strong>重要:</strong> 本主题用到了 <a href="https://gohugo.io/hugo-pipes/introduction/">Hugo Pipes</a> 功能。如需修改 <code>assets</code> 目录下的文件，请安装 extended 版。</p><p><strong>注意:</strong> 对于这个主题，你应该使用 <strong>post</strong> 而不是 <strong>posts</strong>，即 <code>hugo new post/some-content.md</code>。</p><p>2、测试一下是否成功</p><p>站点目录下git命令输入 <code>hugo new post/some-content.md</code>  ，站点目录下此时会出现一个post文件夹。然后hugo server运行，浏览器地址栏输入localhost:1313，查看主题是否安装成功</p><p>3、坑</p><p>主题的文件路径是这样的<code>Hugo_blog\themes\even</code>，路径不要弄错了</p><h1 id="文章显示"><a href="#文章显示" class="headerlink" title="文章显示"></a>文章显示</h1><h2 id="巨坑"><a href="#巨坑" class="headerlink" title="巨坑!!!"></a>巨坑!!!</h2><p>在Hugo_Blog目录下创建一个content文件夹，content文件夹下再创建一个post文件夹。post文件夹里才是真正放md文档的地方。如果路径放错了，文章显示不出来。</p><h1 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">languageCode</span> <span class="string">=</span> <span class="string">&quot;zh-cn&quot;</span></span><br><span class="line"><span class="string">defaultContentLanguage</span> <span class="string">=</span> <span class="string">&quot;zh-cn&quot;</span>  </span><br></pre></td></tr></table></figure><p>这两行配置改一下就行了。注意就是小写，不是大写</p><h1 id="关于作者【菜单】"><a href="#关于作者【菜单】" class="headerlink" title="关于作者【菜单】"></a>关于作者【菜单】</h1><p>在这个目录下<code>Hugo_blog\content</code>直接创建md文档编写即可，文档里的title就是菜单名。even这个主题里的exampleSite文件夹里有示例。</p><h1 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[params.social]                                         # 社交链接</span><br><span class="line">  a-email &#x3D; &quot;mailto:youthlql@foxmail.com&quot;</span><br><span class="line">  b-stack-overflow &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  c-twitter &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  d-facebook &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  e-linkedin &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  f-google &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  g-github &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  h-weibo &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  i-zhihu &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  j-douban &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  k-pocket &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  l-tumblr &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  m-instagram &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  n-gitlab &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br><span class="line">  o-bilibili &#x3D; &quot;http:&#x2F;&#x2F;localhost:1313&quot;</span><br></pre></td></tr></table></figure><p>填入自己的链接即可</p><h1 id="定制logo"><a href="#定制logo" class="headerlink" title="定制logo"></a>定制logo</h1><p>为了定制 favicon，你需要在站点根目录的 <code>static</code> 文件夹下放置下述<strong>所有</strong>文件，这将覆盖 <a href="https://github.com/olOwOlo/hugo-theme-even/tree/master/static"><code>themes/even/static/</code></a> 文件夹下的那些文件。</p><ul><li>android-chrome-192x192.png</li><li>android-chrome-512x512.png</li><li>apple-touch-icon.png</li><li>browserconfig.xml</li><li>favicon.ico</li><li>favicon-16x16.png</li><li>favicon-32x32.png</li><li>manifest.json</li><li>mstile-150x150.png</li><li>safari-pinned-tab.svg</li></ul><p><a href="https://www.google.com/search?q=favicon+generator">favicon generator (Google)</a> 能够帮助你生成这些文件。</p><h1 id="中文导航栏"><a href="#中文导航栏" class="headerlink" title="中文导航栏"></a>中文导航栏</h1><p>虽然说在前面设置了中文，但是导航栏任然要手动改成中文的。</p><h1 id="文章可以配置的属性"><a href="#文章可以配置的属性" class="headerlink" title="文章可以配置的属性"></a>文章可以配置的属性</h1><p>你可以通过 front-matter 针对每一篇文章单独进行设置。<a href="https://github.com/olOwOlo/hugo-theme-even/tree/master/archetypes/default.md"><code>themes/even/archetypes/default.md</code></a> 文件陈列了所有可用的参数。将该文件复制到站点根目录的 <code>archetypes</code> 文件夹下将会有所帮助。</p><h1 id="部署到gitee"><a href="#部署到gitee" class="headerlink" title="部署到gitee"></a>部署到gitee</h1><p>这部分网上可以搜到一堆，就不细讲了。注意几个问题就行</p><p>1、如何创建一个首页访问地址不带二级目录的 pages，如ipvb.gitee.io？</p><p>答：如果你想你的 pages 首页访问地址不带二级目录，如ipvb.gitee.io，<strong>你需要建立一个与自己个性地址同名的仓库</strong>，如 <a href="https://gitee.com/ipvb">https://gitee.com/ipvb</a> 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以<code>ipvb.gitee.io</code>直接访问，那么他就可以创建一个名字为<code>ipvb</code>的仓库 <a href="https://gitee.com/ipvb/ipvb">https://gitee.com/ipvb/ipvb</a> 部署完成后，就可以以 <a href="https://ipvb.gitee.io/">https://ipvb.gitee.io</a> 进行访问了。</p><p>2、当要部署的项目与自己的个性地址不一致时，部署完成后存在一些资源访问404？</p><p>答：当需要部署的仓库和自己的个性地址不一致时，如：<a href="https://gitee.com/ipvb/blog">https://gitee.com/ipvb/blog</a> ，生成的pages url 为 <a href="https://ipvb.gitee.io/blog">https://ipvb.gitee.io/blog</a> ，而访问的资源404，如 <a href="https://ipvb.gitee.io/style.css">https://ipvb.gitee.io/style.css</a> 。这是因为相应配置文件的相对路径存在问题导致的，生成的资源 url 应该为 <a href="https://ipvb.gitee.io/blog/style.css">https://ipvb.gitee.io/blog/style.css</a> 才对。对于不同的静态资源生成器，配置如下：</p><ul><li>Hugo 配置文件<code>config.toml</code>的baseURL修改如下</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baseURL &#x3D; &quot;https:&#x2F;&#x2F;ipvb.gitee.io&#x2F;blog&quot;</span><br></pre></td></tr></table></figure><ul><li>Hexo 配置文件<code>_config.yml</code>的<code>url</code>和<code>root</code>修改如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;ipvb.gitee.io&#x2F;blog</span><br><span class="line">root: &#x2F;blog</span><br></pre></td></tr></table></figure><p>3、编译静态文件</p><p>在Hugo_blog目录下执行hugo命令进行编译，此时会出现一个public目录。然后在Hugo_blog\public 目录下进行 git commit</p><h1 id="几个大坑"><a href="#几个大坑" class="headerlink" title="几个大坑"></a>几个大坑</h1><h2 id="报错error-failed-to-transform-resource-SCSS"><a href="#报错error-failed-to-transform-resource-SCSS" class="headerlink" title="报错error: failed to transform resource: SCSS"></a>报错error: failed to transform resource: SCSS</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Building sites … ERROR 2019/08/27 16:56:32 error: failed to transform resource: SCSS processing failed: file <span class="string">&quot;stdin&quot;</span>, line 3, col 1: File to import not found or unreadable: bulma/bulma. </span><br><span class="line">Total <span class="keyword">in</span> 13 ms</span><br><span class="line">Error: Error building site: logged 1 error(s)</span><br></pre></td></tr></table></figure><p>这个错误耗费的时间比较长，最后找到了hugo一个英文社区。大神说把hugo换成扩展版就可以了，然后就成功了。</p><p>普通版：hugo_0.75.1_Windows-64bit.zip</p><p>扩展版：hugo_extended_0.75.1_Windows-64bit.zip</p><p>地址：<a href="https://github.com/gohugoio/hugo/releases">https://github.com/gohugoio/hugo/releases</a></p><h2 id="页面加载不出来"><a href="#页面加载不出来" class="headerlink" title="页面加载不出来"></a>页面加载不出来</h2><p>1、hexo是在站点目录，比如Hexo_blog下进行git commit等类似操作的。</p><p>2、hugo是首先在Hugo_blog进行hugo编译，然后生成一个public文件夹。然后在Hugo_blog\public 目录下进行 git commit的，很容易出错。</p>]]></content>
      
      
      <categories>
          
          <category> Hugo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hugo </tag>
            
            <tag> 博客教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客教程</title>
      <link href="post/2e704894.html"/>
      <url>post/2e704894.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><span style="color:red;font-weight:bold">特别强调一点，修改文件一定要用csvode打开。不然会出现各种莫名其妙的格式问题</span></p></blockquote><h1 id="Hexo和Hugo"><a href="#Hexo和Hugo" class="headerlink" title="Hexo和Hugo"></a>Hexo和Hugo</h1><p>1、Hexo我个人认为最大的优点目前就是主题多，缺点就是生成静态文件 (hexo g) 速度慢。Hexo是基于Nodejs的，有很多插件，但是加载费时。并且当md文档成百的时候，可能hexo g一次几分钟，体验感不好（不过几分钟也还好，不是特别长），Hexo目前貌似也是在进行优化</p><p>2、Hugo使用自带的Go html模板实现， 速度快，基本上在 Hexo 上面几分钟，使用 Hugo 只需要十几秒钟。然而Hugo目前主题太少，找不到什么满意的主题。</p><p>3、我个人搭建博客比较喜欢漂亮的主题，所以目前用的Hexo。</p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先选择一个磁盘作为你博客文件的存放位置，然后新建一个文件夹，比如名为 blogtest 的文件夹，创建完后，先不要点进去，在此处点击鼠标右键，选择 Git Bash Here，然后依次输入如下命令，：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"># 等上一个命令完成后，在输入下面的命令</span><br><span class="line">hexo init &lt;新建文件夹的名称&gt;  #初始化文件夹</span><br><span class="line">cd &lt;新建文件夹的名称&gt;</span><br><span class="line"></span><br><span class="line">npm install  # 安装博客所需要的依赖文件</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/Hexo/Setup/0001.png"><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><blockquote><p> <font color="red">注意：后续的命令均需要在站点目录下（即文件夹内）使用 Git Bash 运行。</font></p></blockquote><p>等待运行完成，此时文件夹中多了许多文件。 此时 Hexo 框架的本地搭建已经完成了，我们来运行一下看看，命令行依次输入以下命令进行本地验证:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000</a> 或者 127.0.0.1:4000，可以看到一个网页，说明 Hexo 博客已经成功在本地运行。</p><h1 id="主题快速开始（后面的都以Butterfly主题为例）"><a href="#主题快速开始（后面的都以Butterfly主题为例）" class="headerlink" title="主题快速开始（后面的都以Butterfly主题为例）"></a>主题快速开始（后面的都以Butterfly主题为例）</h1><blockquote><p>官方文档：<a href="https://demo.jerryc.me/posts/21cfbf15/">https://demo.jerryc.me/posts/21cfbf15/</a></p></blockquote><p>官方文档的配置相当详细了，这里只是记录下我的配置过程，以及一些细节坑。对于默认不需要改动的配置就不说了</p><h2 id="安裝插件"><a href="#安裝插件" class="headerlink" title="安裝插件"></a>安裝插件</h2><p>如果你沒有 pug 以及 stylus 的渲染器，請下載安裝：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>这个命令一定要执行，不执行的话后面会出问题。</p><h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><p>我用的是<code>_config.butterfly.yml</code>这个方法。<font color="red">后续如果没有特殊说明，改动的配置都是<code>_config.butterfly.yml</code>这个文件里的。</font></p><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p>执行以下命令，如果发现页面和之前验证的页面不一样了，说明主题配置成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h1 id="生成导航菜单"><a href="#生成导航菜单" class="headerlink" title="生成导航菜单"></a>生成导航菜单</h1><blockquote><p><font color="red">再次提醒：后续的命令均需要在站点目录下（即文件夹内）使用 Git Bash 运行。</font></p></blockquote><p>1、生成标签页，分类页，友情链接等等按照文档要求做即可。做完之后，需要将<code>_config.butterfly.yml</code>下面的配置打开，butterfly3.2.0版本是注释掉了，打开之后。再次本地运行验证，就会发现页面右上角出现了几个菜单就算成功了。</p><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>2、<code>hexo new page about</code>可以生成关于页，和上面生成标签页，分类页一个意思，也可以自定义名字，只要和下面的配置对上号就可以。</p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><p>注意中文需要自己在这里手动改，改成ch-zn没有用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#改动的地方</span><br><span class="line">menu:</span><br><span class="line">  首页: &#x2F; || fa fa-home</span><br><span class="line">  时间轴: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  标签: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  分类: &#x2F;categories&#x2F; || fa fa-folder-open</span><br><span class="line">  清单||fa fa-heartbeat:</span><br><span class="line">    - 友人帐 || &#x2F;link&#x2F; || fa fa-link</span><br><span class="line">    - 分享 || &#x2F;share&#x2F; || fas fa-share</span><br><span class="line">  留言板: &#x2F;messageboard&#x2F; || fas fa-comment-dots</span><br><span class="line">  关于作者: &#x2F;about&#x2F; || fas fa-user-tag</span><br></pre></td></tr></table></figure><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page messageboard</span><br></pre></td></tr></table></figure><h1 id="开启404"><a href="#开启404" class="headerlink" title="开启404"></a>开启404</h1><p>将<code>_config.butterfly.yml</code>对应的配置打开即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># A simple 404 page</span><br><span class="line">error_404:</span><br><span class="line">  enable: true</span><br><span class="line">  subtitle: &#39;頁面沒有找到&#39;</span><br><span class="line">  background: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;19&#x2F;aKOcLiyPl2JQdFD.png</span><br></pre></td></tr></table></figure><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>修改<code>_config.butterfly.yml</code>对应的配置，mac比较好看。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#改动的地方</span><br><span class="line">highlight_theme: mac #  darker &#x2F; pale night &#x2F; light &#x2F; ocean &#x2F; mac &#x2F; mac light &#x2F; false</span><br><span class="line">highlight_copy: true # copy button</span><br><span class="line">highlight_lang: true # show the code language</span><br><span class="line">highlight_shrink: false # true: shrink the code blocks &#x2F; false: expand the code blocks | none: expand code blocks and hide the button</span><br><span class="line">code_word_wrap: false</span><br></pre></td></tr></table></figure><h1 id="社交图标"><a href="#社交图标" class="headerlink" title="社交图标"></a>社交图标</h1><h2 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h2><p><a href="https://fontawesome.com/icons?from=io">https://fontawesome.com/icons?from=io</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#改动的地方</span><br><span class="line">social:</span><br><span class="line">  fab fa-github: https:&#x2F;&#x2F;github.com&#x2F;youthlql || GitHub</span><br><span class="line">  fab fa-qq: 1826692270 || QQ：1826692270</span><br><span class="line">  fa fa-address-card: https:&#x2F;&#x2F;blog.csdn.net&#x2F;Youth_lql || 我的CSDN</span><br></pre></td></tr></table></figure><h1 id="主页文章节选"><a href="#主页文章节选" class="headerlink" title="主页文章节选"></a>主页文章节选</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#改动的地方</span><br><span class="line">index_post_content:</span><br><span class="line">  method: 2</span><br><span class="line">  length: 500 # if you set method to 2 or 3, the length need to config</span><br></pre></td></tr></table></figure><h1 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h1><p>这里我设置的是封面统一显示在左边</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cover:</span><br><span class="line">  # display the cover or not (是否顯示文章封面)</span><br><span class="line">  index_enable: true</span><br><span class="line">  aside_enable: true</span><br><span class="line">  archives_enable: true</span><br><span class="line">  # the position of cover in home page (封面顯示的位置)</span><br><span class="line">  # left&#x2F;right&#x2F;both</span><br><span class="line">  # 改动的地方</span><br><span class="line">  position: left</span><br><span class="line">  # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)</span><br><span class="line">  default_cover:</span><br><span class="line">    - https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;01&#x2F;gkihqEjXxJ5UZ1C.jpg</span><br></pre></td></tr></table></figure><h1 id="文章页相关配置"><a href="#文章页相关配置" class="headerlink" title="文章页相关配置"></a>文章页相关配置</h1><h2 id="文章meta显示"><a href="#文章meta显示" class="headerlink" title="文章meta显示"></a>文章meta显示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">post_meta:</span><br><span class="line">  page: # Home Page</span><br><span class="line">    date_type: both # created or updated or both 主頁文章日期是創建日或者更新日或都顯示</span><br><span class="line">    date_format: date # date&#x2F;relative 顯示日期還是相對日期</span><br><span class="line">    categories: true # true or false 主頁是否顯示分類</span><br><span class="line">    tags: true # true or false 主頁是否顯示標籤</span><br><span class="line">    label: true # true or false 顯示描述性文字</span><br><span class="line">  post:</span><br><span class="line">    date_type: both # created or updated or both 文章頁日期是創建日或者更新日或都顯示</span><br><span class="line">    date_format: date # date&#x2F;relative 顯示日期還是相對日期</span><br><span class="line">    categories: true # true or false 文章頁是否顯示分類</span><br><span class="line">    tags: true # true or false 文章頁是否顯示標籤</span><br><span class="line">    label: true # true or false 顯示描述性文字</span><br></pre></td></tr></table></figure><h2 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">reward:</span><br><span class="line">  enable: true</span><br><span class="line">  QR_code:</span><br><span class="line">    - img: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;youthlql&#x2F;lqlp@v1.0.0&#x2F;blog&#x2F;wechat.jpg</span><br><span class="line">      link:</span><br><span class="line">      text: 微信</span><br><span class="line">    - img: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;youthlql&#x2F;lqlp@v1.0.0&#x2F;blog&#x2F;alipay.jpg</span><br><span class="line">      link:</span><br><span class="line">      text: 支付宝</span><br></pre></td></tr></table></figure><h1 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">avatar:</span><br><span class="line">  img: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;youthlql&#x2F;lqlp@v1.0.0&#x2F;blog&#x2F;avatar.jpg</span><br><span class="line">  effect: false # 頭像會一直轉圈</span><br></pre></td></tr></table></figure><h1 id="主页侧边栏设置"><a href="#主页侧边栏设置" class="headerlink" title="主页侧边栏设置"></a>主页侧边栏设置</h1><h2 id="侧边栏排版及内容"><a href="#侧边栏排版及内容" class="headerlink" title="侧边栏排版及内容"></a>侧边栏排版及内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">aside:</span><br><span class="line">  enable: true</span><br><span class="line">  mobile: true # display on mobile</span><br><span class="line">  position: left # left or right</span><br><span class="line">  card_author:</span><br><span class="line">    enable: true</span><br><span class="line">    description:</span><br><span class="line">    button:</span><br><span class="line">      icon: fab fa-github</span><br><span class="line">      text: Follow Me</span><br><span class="line">      link: https:&#x2F;&#x2F;github.com&#x2F;youthlql</span><br><span class="line">  card_announcement:</span><br><span class="line">    enable: true</span><br><span class="line">    content: 这里是公告。</span><br><span class="line">  card_recent_post:</span><br><span class="line">    enable: true</span><br><span class="line">    limit: 10 # if set 0 will show all</span><br><span class="line">    sort: date # date or updated</span><br><span class="line">  card_categories:</span><br><span class="line">    enable: true</span><br><span class="line">    limit: 0 # if set 0 will show all</span><br><span class="line">    expand: none # none&#x2F;true&#x2F;false</span><br><span class="line">  card_tags:</span><br><span class="line">    enable: true</span><br><span class="line">    limit: 40 # if set 0 will show all</span><br><span class="line">    color: true</span><br><span class="line">  card_archives:</span><br><span class="line">    enable: true</span><br><span class="line">    type: monthly # yearly or monthly</span><br><span class="line">    format: MMMM YYYY # eg: YYYY年MM月</span><br><span class="line">    order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending</span><br><span class="line">    limit: 8 # if set 0 will show all</span><br><span class="line">  card_webinfo:</span><br><span class="line">    enable: true</span><br><span class="line">    post_count: true</span><br><span class="line">    last_push_date: true</span><br></pre></td></tr></table></figure><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">runtimeshow:</span><br><span class="line">  enable: true</span><br><span class="line">  publish_date: 1&#x2F;27&#x2F;2020 00:00:00</span><br></pre></td></tr></table></figure><h2 id="最新评论"><a href="#最新评论" class="headerlink" title="最新评论"></a>最新评论</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">newest_comments:</span><br><span class="line">  enable: true</span><br><span class="line">  limit: 6</span><br><span class="line">  avatar: true</span><br><span class="line">  leancloud:</span><br><span class="line">    enable: false</span><br><span class="line">    appId: # leancloud application app id</span><br><span class="line">    appKey: # leancloud application app key</span><br><span class="line">    serverURL: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span><br><span class="line">    default_avatar: # mp&#x2F;identicon&#x2F;monsterid&#x2F;wavatar&#x2F;retro&#x2F;robohash&#x2F;blank</span><br><span class="line">  github_issues:</span><br><span class="line">    enable: false</span><br><span class="line">    repo:</span><br><span class="line">  disqus:</span><br><span class="line">    enable: false</span><br><span class="line">    forum:</span><br><span class="line">    api_key:</span><br></pre></td></tr></table></figure><p>如果你用的是Valine的话这三个属性都要填<code>appId，appKey，serverURL</code>，不然显示不出来。</p><p><code>serverURL</code>就是REST API 服务器地址</p><h1 id="不蒜子原理"><a href="#不蒜子原理" class="headerlink" title="不蒜子原理"></a>不蒜子原理</h1><p>1、不蒜子可以同时网页的UV和PV主要是通过域名来定位的，比如说我现在只有gitee的域名，<a href="https://youthlql.gitee.io/%E3%80%82">https://youthlql.gitee.io/。</a></p><p>假设我再将博客放到github上并且自定义域名，那么他网站的UV和PV会重新计算。</p><p>2、文章的阅读量也是由不蒜子算的，是通过域名和URL链接来定位是哪篇文章。</p><h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><blockquote><p><font color="green">评论系统和说说功能在我的另一篇文章里有细讲</font></p></blockquote><p>推荐valine，好用且评论的人不用登陆</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">comments:</span><br><span class="line">  # Up to two comments system, the first will be shown as default</span><br><span class="line">  # Choose: Disqus&#x2F;Disqusjs&#x2F;Livere&#x2F;Gitalk&#x2F;Valine&#x2F;Utterances&#x2F;Facebook Comments</span><br><span class="line">  use: </span><br><span class="line">    - Valine</span><br><span class="line">  text: true # Display the comment name next to the button</span><br><span class="line">  # lazyload: The comment system will be load when comment element enters the browser&#39;s viewport.</span><br><span class="line">  # If you set it to true, the comment count will be invalid</span><br><span class="line">  lazyload: true</span><br><span class="line">  count: true # Display comment count in top_img</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">valine:</span><br><span class="line">  appId: 你自己的ID # leancloud application app id</span><br><span class="line">  appKey: 你自己的Key # leancloud application app key</span><br><span class="line">  pageSize: 10 # comment list page size</span><br><span class="line">  avatar: monsterid # gravatar style https:&#x2F;&#x2F;valine.js.org&#x2F;#&#x2F;avatar</span><br><span class="line">  lang: en # i18n: zh-CN&#x2F;zh-TW&#x2F;en&#x2F;ja</span><br><span class="line">  placeholder: Please leave your footprints # valine comment input placeholder(like: Please leave your footprints )</span><br><span class="line">  guest_info: nick,mail,link #valine comment header info (nick&#x2F;mail&#x2F;link)</span><br><span class="line">  recordIP: false # Record reviewer IP</span><br><span class="line">  serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span><br><span class="line">  bg: # valine background</span><br><span class="line">  emojiCDN: # emoji CDN</span><br><span class="line">  enableQQ: false # enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span><br><span class="line">  requiredFields: nick,mail # required fields (nick&#x2F;mail)</span><br></pre></td></tr></table></figure><h1 id="搜索（algolia）"><a href="#搜索（algolia）" class="headerlink" title="搜索（algolia）"></a>搜索（algolia）</h1><h2 id="algolia（放弃了）"><a href="#algolia（放弃了）" class="headerlink" title="algolia（放弃了）"></a>algolia（放弃了）</h2><blockquote><p>很详细的一篇博客：<a href="https://blog.csdn.net/qq_35479468/article/details/107335663">https://blog.csdn.net/qq_35479468/article/details/107335663</a></p></blockquote><p>上面的文章讲的很详细了，下面对一些细节进行补充</p><p>1、这个是根目录的<code>_config.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: &#39;your applicationID&#39;</span><br><span class="line">  apiKey: &#39;your apiKey&#39;</span><br><span class="line">  adminApiKey: &#39;your adminApiKey&#39;</span><br><span class="line">  indexName: &#39;your indexName&#39;</span><br><span class="line">  chunkSize: 5000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个配置里的<code>indexName</code>是你之前创建的那个index的名字。</p><p>2、每当你上传一篇新的文章，就要使用下面两个命令更新一下索引。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY&#x3D;your apiKey</span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure><p>或者把<code>HEXO_ALGOLIA_INDEXING_KEY</code>配到系统环境变量里，这样就只需要输入<code>hexo algolia</code>命令了</p><p>3、刚注册的algolia可能显示的是试用版，它会让你更改计划，你点进去，拉到最下面改成Free版的就行。</p><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search 本地搜索</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># 如果没有查到内容相关内容显示</span></span><br></pre></td></tr></table></figure><p>需要安装插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>加速（可选）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hexo-Blog\themes\Butterfly\source\source\js\local-search.js&#96; 找到如下内容因该是在 &#96;55行&#96;左右</span><br><span class="line">修改 &#96;url: GLOBAL_CONFIG.root + path,&#96; 为 &#96;url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;你GitHub的用户名&#x2F;你GitHub的用户名.github.io&#x2F;search.xml&quot;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">   $.ajax(&#123;</span><br><span class="line">     url: <span class="string">&quot;https://cdn.jsdelivr.net/gh/youthlql/youthlql.github.io/search.xml&quot;</span>,</span><br><span class="line">     dataType: <span class="string">&#x27;xml&#x27;</span>,</span><br><span class="line">     success: <span class="function"><span class="keyword">function</span> (<span class="params">xmlResponse</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// get the contents from search data</span></span><br><span class="line">       <span class="keyword">const</span> datas = $(<span class="string">&#x27;entry&#x27;</span>, xmlResponse).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           title: $(<span class="string">&#x27;title&#x27;</span>, <span class="built_in">this</span>).text(),</span><br><span class="line">           content: $(<span class="string">&#x27;content&#x27;</span>, <span class="built_in">this</span>).text(),</span><br><span class="line">           url: $(<span class="string">&#x27;url&#x27;</span>, <span class="built_in">this</span>).text()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;).get()</span><br></pre></td></tr></table></figure><h1 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#改动的地方</span><br><span class="line">wordcount:</span><br><span class="line">  enable: true</span><br><span class="line">  post_wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  total_wordcount: true</span><br></pre></td></tr></table></figure><p>同时安装wordcount插件 ，不安装的话运行会报错</p><p><code>npm i --save hexo-wordcount</code></p><h1 id="网站背景图片"><a href="#网站背景图片" class="headerlink" title="网站背景图片"></a>网站背景图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#改动的地方</span><br><span class="line">background: url(https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;youthlql&#x2F;lqlp@v1.0.0&#x2F;blog&#x2F;background.jpg)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line"># the banner image of home page</span><br><span class="line">index_img: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;youthlql&#x2F;lqlp@v1.0.0&#x2F;blog&#x2F;background.jpg</span><br></pre></td></tr></table></figure><p>上面两个地方改了之后整个主页就是自定义图片了，个人感觉还挺好看。</p><h1 id="文章生成永久url连接"><a href="#文章生成永久url连接" class="headerlink" title="文章生成永久url连接"></a>文章生成永久url连接</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>1、首先安装插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>2、然后改配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">url: http:&#x2F;&#x2F;youthlql.gitee.io</span><br><span class="line">root: &#x2F;</span><br><span class="line">#permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink: post&#x2F;:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure><h2 id="效果区别"><a href="#效果区别" class="headerlink" title="效果区别"></a>效果区别</h2><p>1、下面这个是默认的配置</p><p><code>permalink: :year/:month/:day/:title/</code>：(<a href="http://localhost:4000/2020/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/">http://localhost:4000/2020/04/16/计算机网络-总结/</a>)</p><p>2、修改之后</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</span><br><span class="line">crc16 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;youthlql.gitee.io&#x2F;posts&#x2F;66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;youthlql.gitee.io&#x2F;posts&#x2F;65535.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:&#x2F;&#x2F;youthlql.gitee.io&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:&#x2F;&#x2F;youthlql.gitee.io&#x2F;posts&#x2F;1690090958.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>在以后进行文章评论的合并，不蒜子阅读量的合并上都有用处。</p><h1 id="自定义图标"><a href="#自定义图标" class="headerlink" title="自定义图标"></a>自定义图标</h1><p><svg t="1601710987249" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9986" width="20" height="20"><path d="M512 1024C229.2224 1024 0 794.7776 0 512 0 229.2224 229.2224 0 512 0c282.7776 0 512 229.2224 512 512 0 282.7776-229.2224 512-512 512z m17.066667-413.525333c34.850133 4.352 68.778667 5.12 102.741333 2.0992 23.04-2.048 44.817067-8.362667 64.170667-21.9136 38.212267-26.794667 49.783467-85.1968 24.251733-123.050667-14.626133-21.7088-36.8128-30.344533-60.757333-35.498667-35.054933-7.543467-70.4512-5.751467-105.847467-3.413333-5.666133 0.3584-6.7584 3.072-7.236267 8.209067-3.072 32.682667-6.536533 65.314133-9.813333 97.962666-2.5088 24.814933-4.932267 49.629867-7.509333 75.605334z m53.4016-33.928534c1.962667-20.906667 3.6352-39.338667 5.4272-57.770666 1.553067-15.906133 3.413333-31.778133 4.727466-47.701334 0.3584-4.283733 1.553067-6.656 5.956267-6.382933 15.616 1.041067 31.709867 0.034133 46.728533 3.652267 36.488533 8.823467 48.725333 54.306133 23.3472 83.029333-15.8208 17.902933-36.7616 23.586133-59.255466 25.088-8.465067 0.546133-17.015467 0.085333-26.9312 0.085333zM512 434.295467c-2.184533-0.648533-3.5328-1.1776-4.932267-1.4336-37.717333-6.877867-75.690667-8.328533-113.646933-2.816-20.974933 3.037867-41.0112 9.489067-57.480533 23.330133-22.9888 19.319467-21.640533 46.848 4.4032 62.0032 13.056 7.594667 28.023467 12.509867 42.5984 17.288533 14.08 4.608 28.996267 6.826667 43.144533 11.264 12.5952 3.925333 14.011733 14.318933 3.584 22.306134-3.345067 2.56-7.441067 5.085867-11.537067 5.751466-11.195733 1.826133-22.698667 4.386133-33.826133 3.566934-24.098133-1.774933-48.042667-5.461333-72.5504-8.430934-1.365333 10.615467-2.935467 23.0912-4.5568 35.9424 4.181333 1.365333 7.68 2.730667 11.264 3.618134 33.9456 8.4992 68.386133 9.608533 102.912 5.12 20.087467-2.6112 39.4752-7.901867 56.695467-19.029334 28.603733-18.4832 36.693333-57.1904-4.676267-75.383466-14.506667-6.382933-30.190933-10.410667-45.482667-15.086934-11.4176-3.4816-23.313067-5.614933-34.525866-9.5232-9.7792-3.413333-11.144533-12.202667-3.037867-18.397866 4.6592-3.549867 10.717867-6.997333 16.384-7.3728a480.853333 480.853333 0 0 1 53.384533-0.853334c15.377067 0.699733 30.651733 3.549867 46.4896 5.5296L512 434.295467z m257.143467 2.048L750.933333 614.2976h54.152534c4.778667-45.636267 9.710933-90.7264 14.062933-135.8848 0.6144-6.365867 2.3552-8.840533 8.686933-9.0112 11.434667-0.273067 22.8864-1.979733 34.286934-1.570133 23.722667 0.853333 42.3936 9.728 38.4 43.264-2.901333 24.2688-5.597867 48.571733-8.2432 72.874666-1.092267 10.069333-1.826133 20.189867-2.730667 30.4128h55.330133c3.584-35.259733 7.9872-70.058667 10.496-104.994133 3.413333-47.4624-17.7664-73.3184-64.682666-80.213333-40.96-6.007467-81.339733-0.341333-121.5488 7.133866z m-483.498667 134.6048c-8.738133 1.297067-16.384 2.798933-24.098133 3.4816-25.6512 2.235733-51.319467 3.9424-76.305067-4.266667-13.909333-4.590933-24.6784-12.578133-29.7984-25.9584-7.901867-20.701867 0.887467-47.104 19.831467-60.3136 17.373867-12.117333 37.717333-15.9232 58.453333-15.9232 22.545067-0.017067 45.090133 2.423467 68.232533 3.84L307.2 432.298667c-15.069867-1.723733-29.4912-3.925333-43.997867-4.9152-41.0112-2.798933-80.64 2.6112-117.469866 20.462933-30.020267 14.557867-52.053333 36.010667-58.6752 68.130133-7.850667 38.144 11.537067 69.495467 51.7632 85.845334 19.1488 7.765333 39.287467 12.509867 60.0064 12.5952 24.746667 0.1024 49.493333-1.570133 74.205866-2.952534 3.106133-0.170667 8.311467-2.901333 8.669867-5.034666 1.979733-11.554133 2.730667-23.278933 3.9424-35.464534z" fill="#DD1700" p-id="9987"></path></svg>: 这种自定义图标如何实现呢？</p><blockquote><p>阿里阿巴图标库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p>用svg的格式，把代码复制下来，然后改一下高度和宽度即可</p></blockquote><h1 id="部署到Gitee"><a href="#部署到Gitee" class="headerlink" title="部署到Gitee"></a>部署到Gitee</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 改动的地方</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;gitee.com&#x2F;youthlql&#x2F;youthlql.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="安装发布的插件"><a href="#安装发布的插件" class="headerlink" title="安装发布的插件"></a>安装发布的插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="直接部署"><a href="#直接部署" class="headerlink" title="直接部署"></a>直接部署</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h2 id="几个坑"><a href="#几个坑" class="headerlink" title="几个坑"></a>几个坑</h2><p>这部分网上可以搜到一堆，就不细讲了。注意几个问题就行</p><p>1、如何创建一个首页访问地址不带二级目录的 pages，如ipvb.gitee.io？</p><p>答：如果你想你的 pages 首页访问地址不带二级目录，如ipvb.gitee.io，<strong>你需要建立一个与自己个性地址同名的仓库</strong>，如 <a href="https://gitee.com/ipvb">https://gitee.com/ipvb</a> 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以<code>ipvb.gitee.io</code>直接访问，那么他就可以创建一个名字为<code>ipvb</code>的仓库 <a href="https://gitee.com/ipvb/ipvb">https://gitee.com/ipvb/ipvb</a> 部署完成后，就可以以 <a href="https://ipvb.gitee.io/">https://ipvb.gitee.io</a> 进行访问了。</p><p>2、当要部署的项目与自己的个性地址不一致时，部署完成后存在一些资源访问404？</p><p>答：当需要部署的仓库和自己的个性地址不一致时，如：<a href="https://gitee.com/ipvb/blog">https://gitee.com/ipvb/blog</a> ，生成的pages url 为 <a href="https://ipvb.gitee.io/blog">https://ipvb.gitee.io/blog</a> ，而访问的资源404，如 <a href="https://ipvb.gitee.io/style.css">https://ipvb.gitee.io/style.css</a> 。这是因为相应配置文件的相对路径存在问题导致的，生成的资源 url 应该为 <a href="https://ipvb.gitee.io/blog/style.css">https://ipvb.gitee.io/blog/style.css</a> 才对。对于不同的静态资源生成器，配置如下：</p><ul><li>Hugo 配置文件<code>config.toml</code>的baseURL修改如下</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baseURL &#x3D; &quot;https:&#x2F;&#x2F;ipvb.gitee.io&#x2F;blog&quot;</span><br></pre></td></tr></table></figure><ul><li>Hexo 配置文件<code>_config.yml</code>的<code>url</code>和<code>root</code>修改如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;ipvb.gitee.io&#x2F;blog</span><br><span class="line">root: &#x2F;blog</span><br></pre></td></tr></table></figure><h1 id="同时部署到Github"><a href="#同时部署到Github" class="headerlink" title="同时部署到Github"></a>同时部署到Github</h1><h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p><a href="https://yafine-blog.cn/posts/a170.html">https://yafine-blog.cn/posts/a170.html</a></p><p>注意在域名绑定的时候有一个坑：<a href="https://blog.csdn.net/qq_38332436/article/details/81907686">https://blog.csdn.net/qq_38332436/article/details/81907686</a></p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><h2 id="可配置的属性"><a href="#可配置的属性" class="headerlink" title="可配置的属性"></a>可配置的属性</h2><p><a href="https://demo.jerryc.me/posts/dc584b87/">https://demo.jerryc.me/posts/dc584b87/</a></p><h2 id="abbrlink不要写"><a href="#abbrlink不要写" class="headerlink" title="abbrlink不要写"></a>abbrlink不要写</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">计算机网络-总结篇</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">计算机网络</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">面试</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">计算机网络</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">计算机网络，计网，面试</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">计算机网络-总结篇，可以用来期末复习，校招面试等。</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">&#x27;https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/logo.jpg&#x27;</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">&#x27;https://cdn.jsdelivr.net/gh/lql-youth/lqlp@v1.0.0/blog/background.jpg&#x27;</span></span><br><span class="line"><span class="comment"># abbrlink: 3905e6f8</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-04-16 17:21:58</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>上面的abbrlink不要写，这个属性会给你自动生成。你自己写可能会有冲突</p><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>安装<code>hexo-generator-index</code>插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br></pre></td></tr></table></figure><p>你可以直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。</p><p>参考：</p><ul><li><a href="https://yafine-blog.cn/posts/4ab2.html">https://yafine-blog.cn/posts/4ab2.html</a></li></ul><h1 id="CDN全站加速"><a href="#CDN全站加速" class="headerlink" title="CDN全站加速"></a>CDN全站加速</h1><p>参考这篇文章即可</p><p><a href="https://plushine.cn/14261.html">https://plushine.cn/14261.html</a></p><p>笔者亲测百度云很不行，虽然上面文章的作者推荐百度云，但是目前据butterfly群里反馈来看，大部分用百度云都会出现各种各样的问题，所以建议如果需要用cdn的话，可以考虑又拍云</p><p>参考这两篇文章即可</p><h1 id="diy部分1"><a href="#diy部分1" class="headerlink" title="diy部分1"></a>diy部分1</h1><p>页面整体的样式参考：<a href="https://blog.lete114.top/article/Butterfly-config.html">https://blog.lete114.top/article/Butterfly-config.html</a></p><h1 id="diy部分2"><a href="#diy部分2" class="headerlink" title="diy部分2"></a>diy部分2</h1><p>参考：<a href="https://www.antmoe.com/posts/a811d614/index.html">https://www.antmoe.com/posts/a811d614/index.html</a></p><p>下面是一些笔者博客用到的功能</p><h2 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h2><p>1、目前我只引入了功能扩展部分的css</p><h2 id="自定义阿里图标"><a href="#自定义阿里图标" class="headerlink" title="自定义阿里图标"></a>自定义阿里图标</h2><h2 id="评论系统出现博主-访客（仅限valine）"><a href="#评论系统出现博主-访客（仅限valine）" class="headerlink" title="评论系统出现博主/访客（仅限valine）"></a>评论系统出现博主/访客（仅限valine）</h2><p>看这篇文章：<a href="https://blog.lete114.top/article/Valine-LeanCloud-Config.html">https://blog.lete114.top/article/Valine-LeanCloud-Config.html</a></p><p>这里有一个大坑，master和friends进行Md5加密的时候不能用大写字母，不然就会发生只有访客标识，没有博主和小伙伴标识</p><h2 id="花瓣飘零"><a href="#花瓣飘零" class="headerlink" title="花瓣飘零"></a>花瓣飘零</h2><p><a href="https://yafine-blog.cn/posts/12b4.html">https://yafine-blog.cn/posts/12b4.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-总结篇</title>
      <link href="post/3905e6f8.html"/>
      <url>post/3905e6f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>1、打【】的是有印象，能大致说出来即可，但是没打【】的也不要背，理解性记忆。</p><p>2、如果有知识点，有的博客讲的很清楚，我就直接贴链接了。</p><p>3、《计算机网络7》是一本很好的书，讲的很详细，而且不难懂，读者有时间的话，建议看一下。</p><p>4、如果有错误，欢迎在评论区指正</p><blockquote><p>1、本人正在准备秋招，秋招完之后会持续更新博客。这些总结的部分，也是准备面试期间看了很多很多博客写下来的。<br>2、本人博客：<a href="https://youthlql.gitee.io/">https://youthlql.gitee.io/</a><br>3、等忙完秋招，会陆续更新一些内容。喜欢的朋友可以收藏一下博客</p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>这里面的就是讲的比较详细的博客</p><h2 id="关于计网比较好的博客"><a href="#关于计网比较好的博客" class="headerlink" title="关于计网比较好的博客"></a>关于计网比较好的博客</h2><p><a href="https://blog.csdn.net/ThinkWon/article/details/104903925">https://blog.csdn.net/ThinkWon/article/details/104903925</a></p><p><a href="https://www.cnblogs.com/xjtu-lyh/p/12439036.html">https://www.cnblogs.com/xjtu-lyh/p/12439036.html</a></p><h2 id="三次挥手，四次握手"><a href="#三次挥手，四次握手" class="headerlink" title="三次挥手，四次握手"></a>三次挥手，四次握手</h2><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p><a href="https://blog.csdn.net/weixin_40470303/article/details/80642190">https://blog.csdn.net/weixin_40470303/article/details/80642190</a></p><h2 id="http1-0，http1-1，http2-0介绍"><a href="#http1-0，http1-1，http2-0介绍" class="headerlink" title="http1.0，http1.1，http2.0介绍"></a>http1.0，http1.1，http2.0介绍</h2><p><a href="https://segmentfault.com/a/1190000016656529">https://segmentfault.com/a/1190000016656529</a></p><h2 id="https建立链接过程"><a href="#https建立链接过程" class="headerlink" title="https建立链接过程"></a>https建立链接过程</h2><p><a href="https://blog.csdn.net/iispring/article/details/51615631">https://blog.csdn.net/iispring/article/details/51615631</a></p><h2 id="IO的一些博客"><a href="#IO的一些博客" class="headerlink" title="IO的一些博客"></a>IO的一些博客</h2><p><a href="https://blog.csdn.net/sehanlingfeng/article/details/78920423">https://blog.csdn.net/sehanlingfeng/article/details/78920423</a></p><p><a href="https://www.cnblogs.com/felixzh/p/10345929.html">https://www.cnblogs.com/felixzh/p/10345929.html</a></p><h1 id="OSI七层模型与TCP-IP-五层模型"><a href="#OSI七层模型与TCP-IP-五层模型" class="headerlink" title="OSI七层模型与TCP/IP 五层模型"></a>OSI七层模型与TCP/IP 五层模型</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>​    物理层考虑的是怎样才能在连接各种计算机的传输介质上传输数据比特流。现有的计算机网络中的硬件设备和传输媒体(介质)的种类非常多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和硬件设备的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可使数据链路层只考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么。             </p><blockquote><p>参考《计算机网络7》P51</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    数据链路层研究的是分组怎样从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，局域网仍属于数据链路层的范围。数据传送单位是帧。</p><p><strong>简单的过程：</strong></p><p>1、在两个相邻节点之间传送数据时，数据链路层将网络层交下来的<strong>IP 数据报</strong>添加首部和尾部组装成帧<strong>，</strong>在两个相邻节点间的链路上传送帧<strong>。</strong>每一帧包括数据和必要的控制信息【如同步信息，地址信息，差错控制等】。</p><p>2、数据链路层在收到一个帧后，通过控制信息检测收到的帧中是否有差错，如果没有就可从中提出<strong>IP数据报</strong>部分，上交给网络层<strong>。</strong>如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源 【在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些】</p><h3 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h3><p><strong>数据链路层使用的信道主要有两种：</strong></p><p>①点对点信道</p><p>②广播信道</p><p> <strong>三个基本问题：</strong></p><p>封装成帧、透明传输和差错检测。</p><blockquote><p>更细致的看《计算机网络7》  P82</p></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>1、在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层向上只提供简单灵活的、无连接的、尽最大努力交付的IP数据报服务。【其实数据报或IP数据报就是我们经常使用的“分组”】</p><p>2、网络层在发送分组时不需要先建立连接，没有给分组进行上编号，所传送的分组可能出错、丢失、重复和失序。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）</p><blockquote><p>更多细节–&gt;《计算机网络7》  P124</p></blockquote><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>1、运输层的主要任务就是负责向两台主机的进程之间提供通用的数据传输服务。</p><p>2、运输层有一个很重要的功能 复用和分用。这里的“复用”是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据(当然需要加上适当的首部)，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程</p><p>3、运输层向高层用户屏蔽了下面网络核心的细节【如网络拓扑、所采用的路由选择协议等】，<strong>它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道</strong>。但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。当运输层釆用面向连接的TCP协议时，尽管下面的网络层是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当运输层采用无连接的udp协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>(在上一章，我们巳学习了运输层为应用进程提供了端到端的通信服务)。</p><p><strong>1.</strong> <strong>不同的网络应用的应用进程之间，还需要有不同的通信规则。因此在运输层协议之上，还需要有应用层协议****。</strong></p><p><strong>2.</strong> <strong>每个应用层协议都是为了解决某一类应用问题，</strong>(而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成)<strong>。应用进程之间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。</strong></p><p>3.<strong>运输层是两台主机间进程的交互。应用层是为了更加细化不同网络应用的交互规则。</strong></p><h1 id="常见应用层协议和运输层、网络层协议"><a href="#常见应用层协议和运输层、网络层协议" class="headerlink" title="常见应用层协议和运输层、网络层协议"></a>常见应用层协议和运输层、网络层协议</h1><h2 id="各层协议"><a href="#各层协议" class="headerlink" title="各层协议"></a>各层协议</h2><p><strong>应用层：</strong>HTTP(超文本传输协议) ，DNS(域名系统) ，FTP(文件传输协议) ，SMTP(简单邮件传送协议)</p><p><strong>运输层：</strong>TCP ，UDP</p><p><strong>网络层：</strong> IP, ARP(地址解析协议)–&gt; 见《计网7》P134</p><h2 id="硬件如路由器之类在哪一层"><a href="#硬件如路由器之类在哪一层" class="headerlink" title="硬件如路由器之类在哪一层"></a>硬件如路由器之类在哪一层</h2><ul><li>路由器在网络层，用来进行路由选择</li></ul><h1 id="TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些"><a href="#TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些" class="headerlink" title="TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些"></a>TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些</h1><h2 id="区别-应用场景"><a href="#区别-应用场景" class="headerlink" title="区别+应用场景"></a>区别+应用场景</h2><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0001.png" width=90%> <p><strong>总结：</strong></p><p>1、UDP的主要特点是</p><p>①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p><p>2、TCP的主要特点是</p><p>①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p><h2 id="基于TCP的协议有哪些，基于UDP的有哪些"><a href="#基于TCP的协议有哪些，基于UDP的有哪些" class="headerlink" title="基于TCP的协议有哪些，基于UDP的有哪些"></a>基于TCP的协议有哪些，基于UDP的有哪些</h2><p><strong>TCP：</strong></p><p>HTTP, 超文本传输协议</p><p>FTP, 文件传输协议</p><p>SMTP,简单邮件传输协议，用来发送电子邮件</p><p>SSH 安全外壳协议,用于加密安全登陆</p><p><strong>UDP：</strong></p><p>DHCP协议：动态主机配置协议，动态配置IP地址</p><p>NTP协议：网络时间协议，用于网络时间同步</p><p>RIP（路由选择协议）</p><p>DNS</p><h1 id="TCP可靠传输的保证，拥塞控制目的和过程"><a href="#TCP可靠传输的保证，拥塞控制目的和过程" class="headerlink" title="TCP可靠传输的保证，拥塞控制目的和过程"></a>TCP可靠传输的保证，拥塞控制目的和过程</h1><h2 id="如何保证可靠传输"><a href="#如何保证可靠传输" class="headerlink" title="如何保证可靠传输"></a>如何保证可靠传输</h2><p>TCP通过三次握手建立可靠连接</p><p>①数据被分割成 TCP 认为最适合发送的数据包。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，将有序数据传送给应用层。<strong>TCP通过序列号和确认应答提高可靠性</strong></p><p>②校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到端的校验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p><p>③流量控制： TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。</p><p>④拥塞控制： 当网络拥塞时，减少数据的发送。</p><p>⑤ARQ协议：分为停止等待ARQ协议和连续ARQ协议</p><p>5.1 它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p>5.2 超时重传:：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><p>5.3 TCP 的接收端会丢弃重复的数据</p><h2 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h2><ul><li><p>停止等待ARQ：它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p></li><li><p>连续ARQ协议：(流水线的传输方式)可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p></li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>目的：</strong></p><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><strong>过程：</strong></p><p>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<strong>慢开始和拥塞避免都是基于窗口的拥塞控制</strong>。</p><p><strong>区别：</strong></p><blockquote><p><a href="https://blog.csdn.net/ligupeng7929/article/details/79597423">https://blog.csdn.net/ligupeng7929/article/details/79597423</a></p></blockquote><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li></ul><ul><li>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：</li></ul><p>​    当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</p><p>​    当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p><p>​    当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><ul><li>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li></ul><p><strong>快重传和快恢复：</strong></p><p>1、<strong>快重传</strong>算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p>2、发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行<strong>快恢复算法</strong>。这时，发送方调整门限值ssthresh= (cwnd/2=8,，同时设置拥塞窗口cwnd = ssthresh=8 ，并开始执行拥塞避免算法。</p><p>3、请注意，也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一一些(增大3个报文段的长度)，即等于新的ssthresh + 3 x MSS。这样做的理由是:既然发送方收到3个重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留在接收方的缓存中(接收方发送出3个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0002.png" width=80%><h2 id="为什么要进行流量控制"><a href="#为什么要进行流量控制" class="headerlink" title="为什么要进行流量控制"></a>为什么要进行流量控制</h2><p>一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失(丢包)。</p><h1 id="TCP粘包现象原因和解决方法"><a href="#TCP粘包现象原因和解决方法" class="headerlink" title="TCP粘包现象原因和解决方法"></a>TCP粘包现象原因和解决方法</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>1.UDP协议的保护消息边界使得每一个消息都是独立的  </p><p>2.而tcp是基于流的传输，流传输却把数据当作一串数据流，他不认为数据是一个一个的消息</p><p>3.发送端需要等缓冲区满才发送出去，造成粘包</p><p>4.接收方不及时接收缓冲区的包，造成多个包粘包</p><p>具体点：</p><p>（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</p><p>（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP程序收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p><p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</p><p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</p><h2 id="为什么粘包需要处理"><a href="#为什么粘包需要处理" class="headerlink" title="为什么粘包需要处理?"></a>为什么粘包需要处理?</h2><p>不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。分包一般难度较大,所以尽量避免粘包</p><h1 id="三次握手相关问题"><a href="#三次握手相关问题" class="headerlink" title="三次握手相关问题"></a>三次握手相关问题</h1><h2 id="过程-状态改变"><a href="#过程-状态改变" class="headerlink" title="过程+状态改变"></a>过程+状态改变</h2><p>把<strong>补充</strong>里面的<strong>第二个博客</strong>的过程背下来。(有的地方需要参考第一个博客)</p><h2 id="为什么三次，两次为什么不行"><a href="#为什么三次，两次为什么不行" class="headerlink" title="为什么三次，两次为什么不行?"></a>为什么三次，两次为什么不行?</h2><h3 id="第一种答案"><a href="#第一种答案" class="headerlink" title="第一种答案"></a>第一种答案</h3><p>两次握手只能保证单向连接是畅通的。只有经过第三次握手，才能确保双向都可以接收到对方的发送的 数据。两次握手接收方这里不能确定自己的的发送是正常的，发送方的接收是正常的。</p><p><strong>具体点：</strong></p><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h3 id="第二种答案"><a href="#第二种答案" class="headerlink" title="第二种答案"></a>第二种答案</h3><p>​    一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h1 id="四次挥手相关问题"><a href="#四次挥手相关问题" class="headerlink" title="四次挥手相关问题"></a>四次挥手相关问题</h1><h2 id="过程及状态改变"><a href="#过程及状态改变" class="headerlink" title="过程及状态改变"></a>过程及状态改变</h2><p>就是把<strong>补充</strong>里面的<strong>第二个博客</strong>的过程背下来。(有的地方需要参考第一个博客)</p><h2 id="为什么四次挥手"><a href="#为什么四次挥手" class="headerlink" title="为什么四次挥手"></a>为什么四次挥手</h2><p>​    因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p><h2 id="CLOSE-WAIT和TIME-WAIT存在的意义"><a href="#CLOSE-WAIT和TIME-WAIT存在的意义" class="headerlink" title="CLOSE-WAIT和TIME-WAIT存在的意义"></a>CLOSE-WAIT和TIME-WAIT存在的意义</h2><ul><li><p>Close-wait存在的意义: 就是服务端还有数据要发送，这个时间内就是服务端发送完最后的数据</p></li><li><p>Time-wait存在的意义: </p><ul><li>第一，这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了</li><li>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ul></li></ul><h2 id="如何查看TIME-WAIT状态的链接数量？-TODO"><a href="#如何查看TIME-WAIT状态的链接数量？-TODO" class="headerlink" title="如何查看TIME-WAIT状态的链接数量？(TODO)"></a>如何查看TIME-WAIT状态的链接数量？(TODO)</h2><h2 id="为什么会TIME-WAIT过多？解决方法是怎样的？-TODO"><a href="#为什么会TIME-WAIT过多？解决方法是怎样的？-TODO" class="headerlink" title="为什么会TIME-WAIT过多？解决方法是怎样的？ (TODO)"></a>为什么会TIME-WAIT过多？解决方法是怎样的？ (TODO)</h2><h2 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h2><p>补充里的第二个博客</p><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h2><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxOWU2YzEzNA?x-oss-process=image/format,png"> <p><strong>重要字段：</strong></p><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p><p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><p>ACK：确认序号有效。<br>FIN：释放一个连接。<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接。<br>SYN：发起一个新连接。<br>URG：紧急指针（urgent pointer）有效。</p><p><strong>需要注意的是：</strong></p><p>不要将确认序号ack与标志位中的ACK搞混了。<br>确认方ack=发起方seq+1，两端配对。</p><h1 id="浏览器输入URL并回车的过程以及相关协议，DNS查询过程。"><a href="#浏览器输入URL并回车的过程以及相关协议，DNS查询过程。" class="headerlink" title="浏览器输入URL并回车的过程以及相关协议，DNS查询过程。"></a>浏览器输入URL并回车的过程以及相关协议，DNS查询过程。</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>1、DNS域名解析，得到IP地址</p><p>DNS解析流程:</p><blockquote><p> 参考：<a href="https://blog.csdn.net/yanshuanche3765/article/details/82589210">https://blog.csdn.net/yanshuanche3765/article/details/82589210</a></p><p> <a href="https://blog.csdn.net/u014465934/article/details/83241097">https://blog.csdn.net/u014465934/article/details/83241097</a></p></blockquote><p>（1）1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，(如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。)</p><p>（2）在主机查询操作系统DNS缓存，也就是hosts文件里配置的。</p><p>（3）如果浏览器和系统缓存都没有，系统的 gethostname 函数就会像本地 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。</p><p>（4）如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</p><p>（5）如果LDNS仍然没有命中，本地的DNS服务器向根域名服务器发送查询请求，根域名服务器返回该域名的顶级级域名服务器。依次类推：根域名服务器-顶级域名服务器-主域名服务器</p><p>2、解析出IP地址后，根据IP地址和默认端口80和服务器建立连接，发送http请求</p><p>3、服务器对浏览器的请求作出响应，并把对应的html文本发送给浏览器</p><p>4、释放TCP连接（四次挥手断开连接）</p><p>6、浏览器解析该HTML文本并显示内容</p><h2 id="用到的协议"><a href="#用到的协议" class="headerlink" title="用到的协议"></a>用到的协议</h2><ul><li><p>TCP:与服务器建立TCP连接</p></li><li><p>IP: 建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议</p></li><li><p>OPSF: IP数据包在路由器之间，路由选择使用OPSF协议</p></li><li><p>ARP: 路由器在与服务器通信时，需要将ip地址转换为MAC地址，需要使用ARP协议</p></li><li><p>HTTP:在TCP建立完成后，使用HTTP协议访问网页</p></li></ul><h1 id="HTTP1-0、1-1、2-0之间的区别"><a href="#HTTP1-0、1-1、2-0之间的区别" class="headerlink" title="HTTP1.0、1.1、2.0之间的区别"></a>HTTP1.0、1.1、2.0之间的区别</h1><h2 id="TCP队头阻塞和HTTP队头阻塞"><a href="#TCP队头阻塞和HTTP队头阻塞" class="headerlink" title="TCP队头阻塞和HTTP队头阻塞"></a>TCP队头阻塞和HTTP队头阻塞</h2><blockquote><p><a href="http://www.mamicode.com/info-detail-2983775.html">http://www.mamicode.com/info-detail-2983775.html</a></p></blockquote><p><strong>管道化请求的致命弱点</strong>:</p><p>1、会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞</p><p>2、请求必须是幂等请求，不能修改资源。因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。</p><p>3、由于这个原因，目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式。无论是非管道化还是管道化，都会造成队头阻塞(请求阻塞)。</p><p><strong>解决http队头阻塞的方法：</strong></p><p><strong>1. 并发TCP连接</strong>（浏览器一个域名采用6-8个TCP连接，并发HTTP请求）<br><strong>2. 域名分片</strong>（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发）</p><p><strong>2. HTTP2方式</strong></p><p>http2使用一个域名单一TCP连接发送请求，请求包被二进制分帧，不同请求可以互相穿插，避免了http层面的请求队头阻塞。<br>但是不能避免TCP层面的队头阻塞。</p><h2 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h2><p>1.在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>2.http队列头阻塞</p><p> 请求队列的第一个请求因为服务器正忙（或请求格式问题等其他原因），导致后面的请求被阻塞</p><h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><p>1、支持长链接</p><p>（在request和response中的header中的connection是close或者Keep-Alive进行控制）</p><p> 一个TCP链接可以传送多个http请求和响应，减少了TCP建立链接和关闭链接的消耗。</p><p>2、支持http管道(也就是流水线方式)</p><p>​    不使用管道的http请求，在使用持久链接时，必须严格满足先进先出的队列顺序（FIFO），即发送请求，等待响应完成，再发送客户端队列中的下一个请求。管道可以让我们把 FIFO 队列从客户端（请求队列）迁移到服务器（响应队列），即客户端可以并行，服务端串行。客户端可以不用等待前一个请求返回，发送请求，但服务器端必须顺序的返回客户端的请求响应结果。</p><p>​    但是http1.1任然无法解决http队头阻塞</p><p><strong>还有更细的就看补充里的第四个博客</strong></p><h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><p>1.HTTP2.0最主要的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。</p><p><strong>2.</strong> <strong>二进制传输</strong>:大幅提高性能的一个原因就是: HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><p><strong>3.</strong> <strong>多路复用</strong>: HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求</p><p>对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装【请求包被二进制分帧，不同请求可以互相穿插】。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能</p><p><strong>4.</strong> <strong>Header压缩</strong></p><p><strong>5.</strong> <strong>服务器Push</strong>: 在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源</p><p><strong>6.</strong> <strong>更安全</strong>: HTTP2.0对tls的安全性做了近一步加强</p><h1 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>1、端口：</strong>HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p><p><strong>2、安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源</p><h2 id="HTTPS链接建立的过程"><a href="#HTTPS链接建立的过程" class="headerlink" title="HTTPS链接建立的过程"></a>HTTPS链接建立的过程</h2><p>HTTPS在传输的过程中会涉及到三个密钥：</p><ul><li><p>服务器端的公钥和私钥，用来进行非对称加密</p></li><li><p>客户端生成的随机密钥，用来进行对称加密</p></li></ul><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><ol><li><p>客户端向服务器发起HTTPS请求，连接到服务器的443端口。</p></li><li><p>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p></li><li><p>服务器将自己的公钥发送给客户端。</p></li><li><p>客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。【严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。】如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p></li><li><p>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p></li><li><p>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p></li><li><p>然后服务器将加密后的密文发送给客户端。</p></li><li><p>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p></li></ol><p><strong>详细就看补充-5博客</strong></p><h2 id="了解对称加密算法和非对称加密算法不？"><a href="#了解对称加密算法和非对称加密算法不？" class="headerlink" title="了解对称加密算法和非对称加密算法不？"></a>了解对称加密算法和非对称加密算法不？</h2><p>1.<strong>对称加密</strong>：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p><strong>存在的问题:</strong> 这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方,对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><p><strong>2.</strong> <strong>非对称加密</strong>：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><h1 id="HTTP请求有哪些。Post和get区别。"><a href="#HTTP请求有哪些。Post和get区别。" class="headerlink" title="HTTP请求有哪些。Post和get区别。"></a>HTTP请求有哪些。Post和get区别。</h1><h2 id="有哪些http请求"><a href="#有哪些http请求" class="headerlink" title="有哪些http请求"></a>有哪些http请求</h2><p><a href="https://www.runoob.com/http/http-methods.html">https://www.runoob.com/http/http-methods.html</a></p><h2 id="post和get的区别"><a href="#post和get的区别" class="headerlink" title="post和get的区别"></a>post和get的区别</h2><p>1.GET提交的数据放在URL中，POST数据放在Request body。(但这种情况仅限于浏览器发请求的场景)。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密，使用https）</p><p>2.GET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）</p><p>3.GET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有</p><p>4.GET可以被保存为书签，POST不可以。这一点也能感受到。（这点可能没啥用）</p><p>5.GET请求会被浏览器主动cache，而POST不可缓存</p><p>6.对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p><p>7.GET会保存再浏览器历史记录中，POST不会。这点也能感受到。</p><p>下面的就是深层次的</p><p>8.可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接 </p><p>对于第1点的补充(如果需要举例子可以这样举)</p><blockquote><p>其中的“<METHOD>“可以是GET也可以是POST，或者其他的HTTP Method，如PUT、DELETE、OPTION……。从协议本身看，并没有什么限制说GET一定不能没有body，POST就一定不能把参放到<URL>的querystring上。因此其实可以更加自由的去利用格式。比如Elastic Search的_search api就用了带body的GET；也可以自己开发接口让POST一半的参数放在url的querystring里，另外一半放body里；你甚至还可以让所有的参数都放Header里——可以做各种各样的定制，只要请求的客户端和服务器端能够约定好</p><p>摘自—<a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a></p></blockquote><h1 id="HTTP常见响应状态码，从1xx到5xx都要说"><a href="#HTTP常见响应状态码，从1xx到5xx都要说" class="headerlink" title="HTTP常见响应状态码，从1xx到5xx都要说"></a>HTTP常见响应状态码，从1xx到5xx都要说</h1><p><a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></p><p>需要记住的（下面的应该足够了）</p><p>100, 101</p><p>200, 201, 202, 204 </p><p>301, 302 , 304, 305</p><p>400, 401, 403, 404, 408</p><p>500, 502 ,504</p><h1 id="重定向和转发区别"><a href="#重定向和转发区别" class="headerlink" title="重定向和转发区别"></a>重定向和转发区别</h1><p>1、重定向是两次请求，转发是一次请求。因此转发的速度要快于重定向</p><p><strong>重定向过程</strong>:第一次，客户端request一个网址,服务器响应，并response回来，告诉浏览器，你应该去别一个网址。</p><p>2、重定向之后地址栏上的地址会发生变化，变化成第二次请求的地址，转发之后地址栏上的地址不会变化，还是第一次请求的地址</p><p>3、转发是服务器行为，重定向是客户端行为。</p><p>4、重定向时的网址可以是任何网址，转发的网址必须是本站点的网址</p><h1 id="Session、Cookie和Token的主要区别"><a href="#Session、Cookie和Token的主要区别" class="headerlink" title="Session、Cookie和Token的主要区别"></a>Session、Cookie和Token的主要区别</h1><p>HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。</p><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p>cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>session是依赖Cookie实现的。session是服务器端对象</p><p>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><h2 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h2><p>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；<br>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制<br>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</p><h2 id="什么是Token"><a href="#什么是Token" class="headerlink" title="什么是Token"></a>什么是Token</h2><ul><li><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p></li><li><p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p></li><li><p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p></li><li><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p></li><li><p>Token常用JWT实现，原来需要客户端需要请求服务端验证session合法性，现在只需要通过算法检验Token是否合法，减少了查数据库或者访问服务器比对用户密码，用户身份的消耗。也就是通过算法和密钥代替了访问数据库或服务器比对的过程</p></li></ul><h2 id="session与token区别"><a href="#session与token区别" class="headerlink" title="session与token区别"></a>session与token区别</h2><ul><li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li><li>session存储在服务器端，token存储在客户端</li><li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li><li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li></ul><h1 id="Reactor和Proactor区别"><a href="#Reactor和Proactor区别" class="headerlink" title="Reactor和Proactor区别"></a>Reactor和Proactor区别</h1><p>1.Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先注册到监听事件集合中等待socket可读时再进行操作；。</p><p>2.Proactor直接调用异步读写操作，调用完后放到到用户线程指定的缓存区，接着通知用户线程直接使用即可。</p><p>3.Proactor是真正意义上的用于异步IO，但是依赖操作系统对异步的支持。而Reactor用于同步IO</p><p>通俗语言:</p><p>reactor：能收数据了你跟我说一声。</p><p>proactor: 这有十个字节数据，收好了跟我说一声。</p><blockquote><p>想要理解这两设计模式，还是要真正的学习设计模式。</p></blockquote><h1 id="五种IO模型的区别"><a href="#五种IO模型的区别" class="headerlink" title="五种IO模型的区别"></a>五种IO模型的区别</h1><blockquote><p>从下面这两个文章总结的：</p><ul><li><a href="https://blog.csdn.net/sehanlingfeng/article/details/78920423">https://blog.csdn.net/sehanlingfeng/article/details/78920423</a></li><li><a href="http://www.tianshouzhi.com/api/tutorials/netty/221">http://www.tianshouzhi.com/api/tutorials/netty/221</a></li></ul><p>下面总结的地方如果有不懂的，看上面的文章内容</p><p>下面这两篇文章看起来不错，不过还没认真看：</p><ul><li><a href="https://blog.csdn.net/ocean_fan/article/details/79622956">https://blog.csdn.net/ocean_fan/article/details/79622956</a></li><li><a href="https://blog.csdn.net/ZWE7616175/article/details/80591587">https://blog.csdn.net/ZWE7616175/article/details/80591587</a></li></ul></blockquote><p>在这里，我们以一个网络IO来的read来举例，它会涉及到两个东西：一个是产生这个IO的进程，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><p><strong>阶段1：</strong>等待数据准备 </p><p><strong>阶段2：</strong>将数据从内核拷贝到进程中</p><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>​    当用户进程进行recvfrom这个系统调用，内核就开始了IO的第一个阶段：等待数据准备。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候<strong>内核</strong>就要等待足够的数据到来。而在用户进程这边，整 个进程会被阻塞。当<strong>内核</strong>一直等到数据准备好了，它就会将数据从<strong>内核</strong>中拷贝到用户内存，然后<strong>内核</strong>返回果，用户进程才解除 block的状态，重新运行起来。<strong>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</strong></p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0003.png" width=80%><img src="http://images.cnitblog.com/blog/405877/201411/142330286789443.png" width=70%><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><ol><li>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 </li><li>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好。用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</li><li>虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</li><li><strong>所以，用户进程第一个阶段不是阻塞的,需要不断的主动询问内核数据好了没有；第二个阶段依然总是阻塞的。</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0004.png" width=80%><img src="http://images.cnitblog.com/blog/405877/201411/142332004602984.png" width=70%><h2 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h2><ol><li>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作</li><li>它的基本原理就是select /epoll这个函数会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程，正式发起read请求。</li><li>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket(也就是数据准备好了的socket)，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0005.png" width=80%><h3 id="select函数的其它好处"><a href="#select函数的其它好处" class="headerlink" title="select函数的其它好处"></a>select函数的其它好处</h3><blockquote><p>handle_events：实现事件循环</p><p>handle_event：进行读/写等操作</p></blockquote><ol><li>使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。</li><li>如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</li><li>IO多路复用模型使用了Reactor设计模式实现了这一机制。</li><li>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时(就是数据准备好的时候)，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。</li><li>由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。(一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。)</li></ol><img src="http://images.cnitblog.com/blog/405877/201411/142333254136604.png" width=80%><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><ol><li>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</li><li>这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情</li><li>信号驱动IO放佛很像异步IO，它的第一阶段不是阻塞的。但是很遗憾，它的数据拷贝阶段(第二阶段)，任然是阻塞的。</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0006.png" width=80%><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><ol><li>真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，由用户线程自行读取数据、处理数据。</li><li>而在异步IO模型中，用户进程发起read操作之后，立刻就可以开始去做其它的事。</li><li>而另一方面，从<strong>内核</strong>的角度，当它受到一个异步读之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都 完成之后，<strong>内核</strong>会给用户进程发送一个信号，告诉它read操作完成了，用户线程直接使用即可。 在这整个过程中，进程完全没有被阻塞。</li><li>异步IO模型使用了Proactor设计模式实现了这一机制。**(具体怎么搞得，看上面的文章链接)**</li></ol><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/computer_network/summary/0007.png" width=80%><img src="http://images.cnitblog.com/blog/405877/201411/142333511475767.png"><h1 id="select、poll、epoll的区别？"><a href="#select、poll、epoll的区别？" class="headerlink" title="select、poll、epoll的区别？"></a>select、poll、epoll的区别？</h1><blockquote><p>select, poll, epoll 都是I/O多路复用的具体的实现，之所以有这三个存在，其实是他们出现是有先后顺序的。</p><ul><li><a href="https://blog.csdn.net/nanxiaotao/article/details/90612404">https://blog.csdn.net/nanxiaotao/article/details/90612404</a></li><li><a href="https://www.cnblogs.com/aspirant/p/9166944.html">https://www.cnblogs.com/aspirant/p/9166944.html</a></li><li><a href="https://www.zhihu.com/question/32163005">https://www.zhihu.com/question/32163005</a></li></ul></blockquote><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ol><li>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</li><li>单个进程可监视的fd_set(监听的端口个数)数量被限制：32位机默认是1024个，64位机默认是2048。</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll本质上和select没有区别，采用<strong>链表</strong>的方式替换原有fd_set数据结构,而使其<strong>没有连接数的限制</strong>。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><ol><li>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数。即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li>epoll通过内核和用户空间共享一块内存来实现的。select和poll都是内核需要将消息传递到用户空间，都需要内核拷贝动作</li><li>epoll有EPOLLLT和EPOLLET两种触发模式。(<strong>暂时不去记，有个印象，大致是什么样就可以</strong>)</li></ol><h1 id="IO疑难点"><a href="#IO疑难点" class="headerlink" title="IO疑难点"></a>IO疑难点</h1><p><a href="https://blog.csdn.net/m0_38109046/article/details/89449305">https://blog.csdn.net/m0_38109046/article/details/89449305</a></p><p><a href="https://www.zhihu.com/question/19732473">https://www.zhihu.com/question/19732473</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41&scene=21#wechat_redirect">漫画讲IO</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch-进阶篇</title>
      <link href="post/50e81c79.html"/>
      <url>post/50e81c79.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h1><p>ES提供多种不同的客户端： </p><p>1、TransportClient </p><p>ES提供的传统客户端，官方计划8.0版本删除此客户端。 </p><p>2、RestClient </p><p>RestClient是官方推荐使用的，它包括两种：Java Low Level REST Client和 Java High Level REST Client。 </p><p>ES在6.0之后提供 Java High Level REST Client， 两种客户端官方更推荐使用 Java High Level REST Client，不过当 </p><p>前它还处于完善中，有些功能还没有。 </p><p>我们采用SpringBoot2.x与ElasticSearch集成</p><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><p>部分依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;elasticsearch.version&gt;6.3.2&lt;&#x2F;elasticsearch.version&gt;</span><br><span class="line">     &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- ES --&gt;</span><br><span class="line"> &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;transport&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;elasticsearch.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;elasticsearch.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;elasticsearch&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;elasticsearch.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">      &lt;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#elasticsearch配置</span></span><br><span class="line"><span class="meta">anshe.elasticsearch.hostlist</span>=<span class="string">$&#123;eshostlist:你的IP地址:9200&#125;</span></span><br></pre></td></tr></table></figure><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anshe.common.config.es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.anshe.web.service.ISearchService;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.TransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.transport.client.PreBuiltTransportClient;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ISearchService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;anshe.elasticsearch.hostlist&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hostlist;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//解析hostlist配置信息</span></span><br><span class="line">        String[] split = hostlist.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//创建HttpHost数组，其中存放es主机和端口的配置信息</span></span><br><span class="line">        HttpHost[] httpHostArray = <span class="keyword">new</span> HttpHost[split.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;split.length;i++)&#123;</span><br><span class="line">            String item = split[i];</span><br><span class="line">            httpHostArray[i] = <span class="keyword">new</span> HttpHost(item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>], Integer.parseInt(item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]), <span class="string">&quot;http&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建RestHighLevelClient客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(httpHostArray));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//项目主要使用RestHighLevelClient，对于低级的客户端暂时不用</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestClient <span class="title">restClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//解析hostlist配置信息</span></span><br><span class="line">        String[] split = hostlist.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">//创建HttpHost数组，其中存放es主机和端口的配置信息</span></span><br><span class="line">        HttpHost[] httpHostArray = <span class="keyword">new</span> HttpHost[split.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;split.length;i++)&#123;</span><br><span class="line">            String item = split[i];</span><br><span class="line">            httpHostArray[i] = <span class="keyword">new</span> HttpHost(item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>], Integer.parseInt(item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]), <span class="string">&quot;http&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RestClient.builder(httpHostArray).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;transportClient&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransportClient <span class="title">transportClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Elasticsearch初始化开始。。。。。&quot;</span>);</span><br><span class="line">        TransportClient transportClient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 配置信息</span></span><br><span class="line">            Settings esSetting = Settings.builder()</span><br><span class="line">                    .put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;elasticsearch_anshe&quot;</span>) <span class="comment">//集群名字</span></span><br><span class="line">                    .put(<span class="string">&quot;client.transport.sniff&quot;</span>, <span class="keyword">true</span>)<span class="comment">//增加嗅探机制，找到ES集群</span></span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">//配置信息Settings自定义</span></span><br><span class="line">            transportClient = <span class="keyword">new</span> PreBuiltTransportClient(esSetting);</span><br><span class="line">            TransportAddress transportAddress = <span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">&quot;你的IP地址&quot;</span>), <span class="number">9300</span>);</span><br><span class="line">            transportClient.addTransportAddresses(transportAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;elasticsearch TransportClient create error!!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transportClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anshe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> tk.mybatis.spring.annotation.MapperScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.anshe.web.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnsheApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;es.set.netty.runtime.available.processors&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        SpringApplication.run(AnsheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>创建索引：</strong> </p><p>put <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D%E7%A7%B0">http://localhost:9200/索引名称</a> </p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>:&#123;</span><br><span class="line">            &quot;number_of_shards&quot;:&quot;1&quot;, # 分片数</span><br><span class="line">            &quot;number_of_replicas&quot;:&quot;0&quot; # 副本数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建映射：</strong> </p><p>发送：put <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%BA%93%E5%90%8D%E7%A7%B0/%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0/_mapping">http://localhost:9200/索引库名称/类型名称/_mapping</a> </p><p>创建类型为xc_course的映射，共包括三个字段：name、description、studymodel 等</p><p><a href="http://localhost:9200/xc_course/doc/_mapping">http://localhost:9200/xc_course/doc/_mapping</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;float&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line"><span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestClient restClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建索引库</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建索引对象</span></span><br><span class="line">    CreateIndexRequest createIndexRequest = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//设置参数</span></span><br><span class="line">    createIndexRequest.settings(Settings.builder().put(<span class="string">&quot;number_of_shards&quot;</span>,<span class="string">&quot;1&quot;</span>).put(<span class="string">&quot;number_of_replicas&quot;</span>,<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    <span class="comment">//指定映射</span></span><br><span class="line">    createIndexRequest.mapping(<span class="string">&quot;doc&quot;</span>,<span class="string">&quot; &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot; \t\&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;studymodel\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;             \&quot;type\&quot;:\&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;           &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;            \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;             \&quot;type\&quot;:\&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;           &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;           \&quot;description\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;              \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;              \&quot;analyzer\&quot;:\&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;              \&quot;search_analyzer\&quot;:\&quot;ik_smart\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;           &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;           \&quot;pic\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;             \&quot;type\&quot;:\&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;             \&quot;index\&quot;:false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;           &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot; \t&#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>, XContentType.JSON);</span><br><span class="line">    <span class="comment">//操作索引的客户端</span></span><br><span class="line">    IndicesClient indices = client.indices();</span><br><span class="line">    <span class="comment">//执行创建索引库</span></span><br><span class="line">    CreateIndexResponse createIndexResponse = indices.create(createIndexRequest);</span><br><span class="line">    <span class="comment">//得到响应</span></span><br><span class="line">    <span class="keyword">boolean</span> acknowledged = createIndexResponse.isAcknowledged();</span><br><span class="line">    System.out.println(acknowledged);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h2><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE http://[&#x27;你自己的Ip加Port&#x27;]/test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;acknowledged&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java客户端-1"><a href="#Java客户端-1" class="headerlink" title="Java客户端"></a>Java客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除索引库</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//删除索引对象</span></span><br><span class="line">    DeleteIndexRequest deleteIndexRequest = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//操作索引的客户端</span></span><br><span class="line">    IndicesClient indices = client.indices();</span><br><span class="line">    <span class="comment">//执行删除索引</span></span><br><span class="line">    DeleteIndexResponse delete = indices.delete(deleteIndexRequest);</span><br><span class="line">    <span class="comment">//得到响应</span></span><br><span class="line">    <span class="keyword">boolean</span> acknowledged = delete.isAcknowledged();</span><br><span class="line">    System.out.println(acknowledged);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h2><h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><p>格式如下： PUT /{index}/{type}/{id} { “fifield”: “value”, … } </p><p>如果不指定id，ES会自动生成。 </p><p>一个例子： </p><p>put <a href="http://localhost:9200/xc_course/doc/3">http://localhost:9200/xc_course/doc/3</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring cloud实战&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战Spring Boot 4.注册中心eureka。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span>,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="number">5.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java客户端-2"><a href="#Java客户端-2" class="headerlink" title="Java客户端"></a>Java客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加文档</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//文档内容</span></span><br><span class="line">    <span class="comment">//准备json数据</span></span><br><span class="line">    Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    jsonMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;spring cloud实战&quot;</span>);</span><br><span class="line">    jsonMap.put(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战Spring Boot 4.注册中心eureka。&quot;</span>);</span><br><span class="line">    jsonMap.put(<span class="string">&quot;studymodel&quot;</span>, <span class="string">&quot;201001&quot;</span>);</span><br><span class="line">    SimpleDateFormat dateFormat =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    jsonMap.put(<span class="string">&quot;timestamp&quot;</span>, dateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    jsonMap.put(<span class="string">&quot;price&quot;</span>, <span class="number">5.6f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建索引创建对象</span></span><br><span class="line">    IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;xc_course&quot;</span>,<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//文档内容</span></span><br><span class="line">    indexRequest.source(jsonMap);</span><br><span class="line">    <span class="comment">//通过client进行http的请求</span></span><br><span class="line">    IndexResponse indexResponse = client.index(indexRequest);</span><br><span class="line">    DocWriteResponse.Result result = indexResponse.getResult();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><h3 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h3><p>格式如下： GET /{index}/{type}/{id} </p><h3 id="Java客户端-3"><a href="#Java客户端-3" class="headerlink" title="Java客户端"></a>Java客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询文档</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//查询请求对象</span></span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;xc_course&quot;</span>,<span class="string">&quot;doc&quot;</span>,<span class="string">&quot;0fOCF2sBEYTsNRZ43I8b&quot;</span>);</span><br><span class="line">    GetResponse getResponse = client.get(getRequest);</span><br><span class="line">    <span class="comment">//得到文档的内容</span></span><br><span class="line">    Map&lt;String, Object&gt; sourceAsMap = getResponse.getSourceAsMap();</span><br><span class="line">    System.out.println(sourceAsMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><h3 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h3><p>ES更新文档的顺序是：先检索到文档、将原来的文档标记为删除、创建新文档、删除旧文档，创建新文档就会重建 </p><p>索引。 </p><p>通过请求Url有两种方法： </p><p><strong>1、完全替换</strong> </p><p>Post：<a href="http://localhost:9200/xc_test/doc/3">http://localhost:9200/xc_test/doc/3</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring cloud实战&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战SpringBoot 4.注册中心eureka。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span>,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="number">5.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、局部更新</strong> </p><p>下边的例子是只更新price字段。 </p><p>post: <a href="http://localhost:9200/xc_test/doc/3/_update">http://localhost:9200/xc_test/doc/3/_update</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="number">66.6</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java客户端-4"><a href="#Java客户端-4" class="headerlink" title="Java客户端"></a>Java客户端</h3><p>使用 Client Api更新文档的方法同上边第二种局部更新方法。 </p><p>可以指定文档的部分字段也可以指定完整的文档内容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;更新文档</span><br><span class="line">@Test public void updateDoc() throws IOException &#123;</span><br><span class="line">UpdateRequest updateRequest &#x3D; new UpdateRequest(&quot;xc_course&quot;, &quot;doc&quot;, &quot;4028e581617f945f01617f9dabc40000&quot;);</span><br><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;spring cloud实战&quot;);</span><br><span class="line">updateRequest.doc(map);</span><br><span class="line">UpdateResponse update &#x3D; client.update(updateRequest);</span><br><span class="line">RestStatus status &#x3D; update.status();</span><br><span class="line">System.out.println(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><h3 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h3><p>1、根据id删除，格式如下： </p><p>DELETE /{index}/{type}/{id} </p><p>2、搜索匹配删除，将搜索出来的记录删除，格式如下： </p><p>POST /{index}/{type}/_delete_by_query </p><p>下边是搜索条件例子： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边例子的搜索匹配删除会将studymodel为201001的记录全部删除</p><h3 id="Java客户端-5"><a href="#Java客户端-5" class="headerlink" title="Java客户端"></a>Java客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id删除文档</span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line"><span class="comment">//删除文档id</span></span><br><span class="line">String id = <span class="string">&quot;eqP_amQBKsGOdwJ4fHiC&quot;</span>; </span><br><span class="line"><span class="comment">//删除索引请求对象</span></span><br><span class="line">DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;xc_course&quot;</span>,<span class="string">&quot;doc&quot;</span>,id); </span><br><span class="line"><span class="comment">//响应对象</span></span><br><span class="line">DeleteResponse deleteResponse = client.delete(deleteRequest);</span><br><span class="line"><span class="comment">//获取响应结果</span></span><br><span class="line">DocWriteResponse.Result result = deleteResponse.getResult();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索匹配删除还没有具体的api，可以采用先搜索出文档id，根据文档id删除。</p><h1 id="—–下面是DSL搜索的内容—–"><a href="#—–下面是DSL搜索的内容—–" class="headerlink" title="—–下面是DSL搜索的内容—–"></a>—–下面是DSL搜索的内容—–</h1><h1 id="DSL搜索环境准备"><a href="#DSL搜索环境准备" class="headerlink" title="DSL搜索环境准备"></a>DSL搜索环境准备</h1><h2 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h2><p>创建xc_course索引库。 </p><p>创建如下映射 </p><p>post：<a href="http://localhost:9200/xc_course/doc/_mapping">http://localhost:9200/xc_course/doc/_mapping</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;float&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line"><span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入原始数据"><a href="#插入原始数据" class="headerlink" title="插入原始数据"></a>插入原始数据</h2><p>向xc_course/doc中插入以下数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/xc_course/doc/1</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Bootstrap开发&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Bootstrap是由Twitter推出的一个前台页面开发框架，是一个非常流行的开发框架，此框架集成了 多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松 的实现一个不受浏览器限制的精美界面效果。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201002&quot;</span>,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="number">38.6</span>,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2018‐04‐25 19:11:35&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: <span class="string">&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http://localhost:9200/xc_course/doc/2</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;java编程基础&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;java语言是世界第一编程语言，在软件开发领域使用人数最多。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span>,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="number">68.6</span>,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2018‐03‐25 19:11:35&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: <span class="string">&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http://localhost:9200/xc_course/doc/3 </span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring开发基础&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;spring 在java领域非常流行，java程序员都在用。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span>,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="number">88.6</span>,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2018‐02‐24 19:11:35&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: <span class="string">&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p> DSL(Domain Specifific Language)是ES提出的基于json的搜索方式，在搜索时传入特定的json格式的数据来完成不 同的搜索需求。 DSL比URI搜索方式功能强大，在项目中建议使用DSL方式来完成搜索。</p></blockquote><h1 id="查询所有文档"><a href="#查询所有文档" class="headerlink" title="查询所有文档"></a>查询所有文档</h1><h2 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h2><p>查询所有索引库的文档。 </p><p>发送：post <a href="http://localhost:9200/_search">http://localhost:9200/_search</a> </p><p>查询指定索引库指定类型下的文档。（通过使用此方法） </p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_source：source源过虑设置，指定结果中所包括的字段有哪些。 </p><p><strong>结果说明：</strong> </p><p>took：本次操作花费的时间，单位为毫秒。 </p><p>timed_out：请求是否超时 </p><p>_shards：说明本次操作共搜索了哪些分片 </p><p>hits：搜索命中的记录 </p><p>hits.total ： 符合条件的文档总数 hits.hits ：匹配度较高的前N个文档 </p><p>hits.max_score：文档匹配得分，这里为最高分 </p><p>_score：每个文档都有一个匹配度得分，按照降序排列。 </p><p>_source：显示了文档的原始内容。 </p><h2 id="Java客户端-6"><a href="#Java客户端-6" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line">    RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestClient restClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索全部记录</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//搜索请求对象</span></span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">        <span class="comment">//指定类型</span></span><br><span class="line">        searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">        <span class="comment">//搜索源构建对象</span></span><br><span class="line">        SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//搜索方式</span></span><br><span class="line">        <span class="comment">//matchAllQuery搜索全部</span></span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">        <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">        searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">        <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">        SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">        <span class="comment">//搜索结果</span></span><br><span class="line">        SearchHits hits = searchResponse.getHits();</span><br><span class="line">        <span class="comment">//匹配到的总记录数</span></span><br><span class="line">        <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">        <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">        SearchHit[] searchHits = hits.getHits();</span><br><span class="line">        <span class="comment">//日期格式化对象</span></span><br><span class="line"><span class="comment">//        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">            <span class="comment">//文档的主键</span></span><br><span class="line">            String id = hit.getId();</span><br><span class="line">            <span class="comment">//源文档内容</span></span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">            String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">            <span class="comment">//学习模式</span></span><br><span class="line">            String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">            <span class="comment">//价格</span></span><br><span class="line">            Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">            <span class="comment">//日期</span></span><br><span class="line">            Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(studymodel);</span><br><span class="line">            System.out.println(description);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><h2 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h2><p>ES支持分页查询，传入两个参数：from和size。 </p><p>form：表示起始文档的下标，从0开始。 </p><p>size：查询的文档数量。 </p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;size&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java客户端-7"><a href="#Java客户端-7" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchPage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    <span class="comment">//页码</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//每页记录数</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算出记录起始下标</span></span><br><span class="line">    <span class="keyword">int</span> from  = (page-<span class="number">1</span>)*size;</span><br><span class="line">    searchSourceBuilder.from(from);<span class="comment">//起始记录下标，从0开始</span></span><br><span class="line">    searchSourceBuilder.size(size);<span class="comment">//每页显示的记录数</span></span><br><span class="line">    <span class="comment">//搜索方式</span></span><br><span class="line">    <span class="comment">//matchAllQuery搜索全部</span></span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Term-Query"><a href="#Term-Query" class="headerlink" title="Term Query"></a>Term Query</h1><h2 id="API-8"><a href="#API-8" class="headerlink" title="API"></a>API</h2><p>Term Query为精确查询，在搜索时会整体匹配关键字，不再将关键字分词。 </p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;spring&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的搜索会查询name包括“spring”这个词的文档。</p><h2 id="Java客户端-8"><a href="#Java客户端-8" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TermQuery</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTermQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    <span class="comment">//页码</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//每页记录数</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算出记录起始下标</span></span><br><span class="line">    <span class="keyword">int</span> from  = (page-<span class="number">1</span>)*size;</span><br><span class="line">    searchSourceBuilder.from(from);<span class="comment">//起始记录下标，从0开始</span></span><br><span class="line">    searchSourceBuilder.size(size);<span class="comment">//每页显示的记录数</span></span><br><span class="line">    <span class="comment">//搜索方式</span></span><br><span class="line">    <span class="comment">//termQuery</span></span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;spring&quot;</span>));</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="根据id精确匹配"><a href="#根据id精确匹配" class="headerlink" title="根据id精确匹配"></a>根据id精确匹配</h1><h2 id="API-9"><a href="#API-9" class="headerlink" title="API"></a>API</h2><p>ES提供根据多个id值匹配的方法： </p><p>测试：</p><p>post： <a href="http://127.0.0.1:9200/xc_course/doc/_search">http://127.0.0.1:9200/xc_course/doc/_search</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;ids&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;doc&quot;</span>,</span><br><span class="line"><span class="attr">&quot;values&quot;</span>: [</span><br><span class="line"><span class="string">&quot;3&quot;</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>,</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java客户端-9"><a href="#Java客户端-9" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTermQueryByIds</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//搜索方式</span></span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="comment">//定义id</span></span><br><span class="line">    String[] ids = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.termsQuery(<span class="string">&quot;_id&quot;</span>,ids));</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="match-Query"><a href="#match-Query" class="headerlink" title="match Query"></a>match Query</h1><h2 id="API-10"><a href="#API-10" class="headerlink" title="API"></a>API</h2><p>match Query即全文检索，它的搜索方式是先将搜索字符串分词，再使用各各词条从索引中搜索。 </p><p>match query与Term query区别是match query在搜索前先将搜索关键字分词，再拿各各词语去索引中搜索。 </p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;spring开发&quot;</span>,</span><br><span class="line"><span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;or&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>query：搜索的关键字，对于英文关键字如果有多个单词则中间要用半角逗号分隔，而对于中文关键字中间可以用 </p><p>逗号分隔也可以不用。 </p><p>operator：or 表示 只要有一个词在文档中出现则就符合条件，and表示每个词都在文档中出现则才符合条件。 </p><p>上边的搜索的执行过程是： </p><p>1、将“spring开发”分词，分为spring、开发两个词 </p><p>2、再使用spring和开发两个词去匹配索引中搜索。 </p><p>3、由于设置了operator为or，只要有一个词匹配成功则就返回该文档。 </p><h2 id="Java客户端-10"><a href="#Java客户端-10" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MatchQuery</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMatchQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索方式</span></span><br><span class="line">    <span class="comment">//MatchQuery</span></span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;spring开发框架&quot;</span>)</span><br><span class="line">            .minimumShouldMatch(<span class="string">&quot;80%&quot;</span>));</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="multi-Query"><a href="#multi-Query" class="headerlink" title="multi Query"></a>multi Query</h1><h2 id="API-11"><a href="#API-11" class="headerlink" title="API"></a>API</h2><p><strong>1、基本使用</strong></p><p>上边学习的termQuery和matchQuery一次只能匹配一个Field，本节学习multiQuery，一次可以匹配多个字段。 </p><p>单项匹配是在一个fifield中去匹配，多项匹配是拿关键字去多个Field中匹配。 </p><p>例子： </p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a> </p><p>拿关键字 “spring css”去匹配name 和description字段。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;spring css&quot;</span>,</span><br><span class="line"><span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、提升boost</strong> </p><p>匹配多个字段时可以提升字段的boost（权重）来提高得分 </p><p>例子： </p><p>提升boost之前，执行下边的查询： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;spring框架&quot;</span>,</span><br><span class="line"><span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查询发现Bootstrap排在前边。 </p><p>提升boost，通常关键字匹配上name的权重要比匹配上description的权重高，这里可以对name的权重提升</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;spring框架&quot;</span>,</span><br><span class="line"><span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name^10&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“name^10” 表示权重提升10倍，执行上边的查询，发现name中包括spring关键字的文档排在前边。</p><h2 id="Java客户端-11"><a href="#Java客户端-11" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MultiMatchQuery</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiMatchQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索方式</span></span><br><span class="line">    <span class="comment">//MultiMatchQuery</span></span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.multiMatchQuery(<span class="string">&quot;spring css&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;description&quot;</span>)</span><br><span class="line">            .minimumShouldMatch(<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">            .field(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>));</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h1><h2 id="API-12"><a href="#API-12" class="headerlink" title="API"></a>API</h2><p>布尔查询对应于Lucene的BooleanQuery查询，实现将多个查询组合起来。 </p><ul><li><p>三个参数： </p><ul><li><p>must：文档必须匹配must所包括的查询条件，相当于 “AND” </p></li><li><p>should：文档应该匹配should所包括的查询条件其中的一个或多个，相当于 “OR” </p></li><li><p>must_not：文档不能匹配must_not所包括的该查询条件，相当于“NOT”</p></li></ul></li></ul><p>分别使用must、should、must_not测试下边的查询： </p><p>发送：POST <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;size&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;spring框架&quot;</span>,</span><br><span class="line"><span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name^10&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>must：表示必须，多个查询条件必须都满足。（通常使用must） </p><p>should：表示或者，多个查询条件只要有一个满足即可。 </p><p>must_not：表示非。</p><h2 id="Java客户端-12"><a href="#Java客户端-12" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BoolQuery其实是一个过滤搜索</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBoolQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolQuery搜索方式</span></span><br><span class="line">    <span class="comment">//先定义一个MultiMatchQuery</span></span><br><span class="line">    MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="string">&quot;spring css&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>)</span><br><span class="line">            .minimumShouldMatch(<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">            .field(<span class="string">&quot;name&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//再定义一个termQuery</span></span><br><span class="line">    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;studymodel&quot;</span>, <span class="string">&quot;201001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个boolQuery</span></span><br><span class="line">    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">    boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line">    boolQueryBuilder.must(termQueryBuilder);</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="过虑器"><a href="#过虑器" class="headerlink" title="过虑器"></a>过虑器</h1><h2 id="API-13"><a href="#API-13" class="headerlink" title="API"></a>API</h2><p>​    过虑是针对搜索的结果进行过虑，过虑器主要判断的是文档是否匹配，不去计算和判断文档的匹配度得分，所以过 虑器性能比查询要高，且方便缓存，推荐尽量使用过虑器去实现查询或者过虑器和查询共同使用。 过虑器在布尔查询中使用，下边是在搜索结果的基础上进行过虑： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span>,</span><br><span class="line"><span class="string">&quot;price&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;spring框架&quot;</span>,</span><br><span class="line"><span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name^10&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;gte&quot;</span>: <span class="number">60</span>,</span><br><span class="line"><span class="attr">&quot;lte&quot;</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>range：范围过虑，保留大于等于60 并且小于等于100的记录。</p><p>term：项匹配过虑，保留studymodel等于”201001”的记录。 </p><p>注意：range和term一次只能对一个Field设置范围过虑。</p><h2 id="Java客户端-13"><a href="#Java客户端-13" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolQuery搜索方式</span></span><br><span class="line">    <span class="comment">//先定义一个MultiMatchQuery</span></span><br><span class="line">    MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="string">&quot;spring css&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>)</span><br><span class="line">            .minimumShouldMatch(<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">            .field(<span class="string">&quot;name&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个boolQuery</span></span><br><span class="line">    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">    boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line">    <span class="comment">//定义过虑器</span></span><br><span class="line">    boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;201001&quot;</span>));</span><br><span class="line">    boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">90</span>).lte(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="API-14"><a href="#API-14" class="headerlink" title="API"></a>API</h2><p>可以在字段上添加一个或多个排序，支持在keyword、date、flfloat等类型上添加，text类型的字段上不允许添加排 </p><p>序。</p><p>发送 POST <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a> </p><p>过虑0–10元价格范围的文档，并且对结果进行排序，先按studymodel降序，再按价格升序 </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span>,</span><br><span class="line"><span class="string">&quot;price&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;gte&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;lte&quot;</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java客户端-14"><a href="#Java客户端-14" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Sort</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求对象</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">    <span class="comment">//指定类型</span></span><br><span class="line">    searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">    <span class="comment">//搜索源构建对象</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolQuery搜索方式</span></span><br><span class="line">    <span class="comment">//定义一个boolQuery</span></span><br><span class="line">    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">//定义过虑器</span></span><br><span class="line">    boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">0</span>).lte(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    <span class="comment">//添加排序</span></span><br><span class="line">    searchSourceBuilder.sort(<span class="string">&quot;studymodel&quot;</span>, SortOrder.DESC);</span><br><span class="line">    searchSourceBuilder.sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">    searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">    <span class="comment">//搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    <span class="comment">//匹配到的总记录数</span></span><br><span class="line">    <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">    <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="comment">//日期格式化对象</span></span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">        <span class="comment">//文档的主键</span></span><br><span class="line">        String id = hit.getId();</span><br><span class="line">        <span class="comment">//源文档内容</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">        String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">        String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="comment">//学习模式</span></span><br><span class="line">        String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">        <span class="comment">//价格</span></span><br><span class="line">        Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">//日期</span></span><br><span class="line">        Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(studymodel);</span><br><span class="line">        System.out.println(description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h1><h2 id="API-15"><a href="#API-15" class="headerlink" title="API"></a>API</h2><p>高亮显示可以将搜索结果一个或多个字突出显示，以便向用户展示匹配关键字的位置。 </p><p>在搜索语句中添加highlight即可实现，如下： </p><p>Post： <a href="http://127.0.0.1:9200/xc_course/doc/_search">http://127.0.0.1:9200/xc_course/doc/_search</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name&quot;</span>,</span><br><span class="line"><span class="string">&quot;studymodel&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span>,</span><br><span class="line"><span class="string">&quot;price&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>: <span class="string">&quot;开发框架&quot;</span>,</span><br><span class="line"><span class="attr">&quot;minimum_should_match&quot;</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: [</span><br><span class="line"><span class="string">&quot;name^10&quot;</span>,</span><br><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;best_fields&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;gte&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;lte&quot;</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;pre_tags&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&lt;tag1&gt;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;post_tags&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&lt;/tag2&gt;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java客户端-15"><a href="#Java客户端-15" class="headerlink" title="Java客户端"></a>Java客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//Highlight</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//搜索请求对象</span></span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;xc_course&quot;</span>);</span><br><span class="line">        <span class="comment">//指定类型</span></span><br><span class="line">        searchRequest.types(<span class="string">&quot;doc&quot;</span>);</span><br><span class="line">        <span class="comment">//搜索源构建对象</span></span><br><span class="line">        SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolQuery搜索方式</span></span><br><span class="line">        <span class="comment">//先定义一个MultiMatchQuery</span></span><br><span class="line">        MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="string">&quot;开发框架&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;description&quot;</span>)</span><br><span class="line">                .minimumShouldMatch(<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">                .field(<span class="string">&quot;name&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个boolQuery</span></span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        boolQueryBuilder.must(multiMatchQueryBuilder);</span><br><span class="line">        <span class="comment">//定义过虑器</span></span><br><span class="line">        boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">0</span>).lte(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">        <span class="comment">//设置源字段过虑,第一个参数结果集包括哪些字段，第二个参数表示结果集不包括哪些字段</span></span><br><span class="line">        searchSourceBuilder.fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;studymodel&quot;</span>,<span class="string">&quot;price&quot;</span>,<span class="string">&quot;timestamp&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置高亮</span></span><br><span class="line">        HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">        highlightBuilder.preTags(<span class="string">&quot;&lt;tag&gt;&quot;</span>);</span><br><span class="line">        highlightBuilder.postTags(<span class="string">&quot;&lt;/tag&gt;&quot;</span>);</span><br><span class="line">        highlightBuilder.fields().add(<span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        highlightBuilder.fields().add(<span class="keyword">new</span> HighlightBuilder.Field(<span class="string">&quot;description&quot;</span>));</span><br><span class="line">        searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向搜索请求对象中设置搜索源</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="comment">//执行搜索,向ES发起http请求</span></span><br><span class="line">        SearchResponse searchResponse = client.search(searchRequest);</span><br><span class="line">        <span class="comment">//搜索结果</span></span><br><span class="line">        SearchHits hits = searchResponse.getHits();</span><br><span class="line">        <span class="comment">//匹配到的总记录数</span></span><br><span class="line">        <span class="keyword">long</span> totalHits = hits.getTotalHits();</span><br><span class="line">        <span class="comment">//得到匹配度高的文档</span></span><br><span class="line">        SearchHit[] searchHits = hits.getHits();</span><br><span class="line">        <span class="comment">//日期格式化对象</span></span><br><span class="line"><span class="comment">//        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS Z&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">            <span class="comment">//文档的主键</span></span><br><span class="line">            String id = hit.getId();</span><br><span class="line">            <span class="comment">//源文档内容</span></span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            <span class="comment">//源文档的name字段内容</span></span><br><span class="line">            String name = (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">//取出高亮字段</span></span><br><span class="line">            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">            <span class="keyword">if</span>(highlightFields!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//取出name高亮字段</span></span><br><span class="line">                HighlightField nameHighlightField = highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(nameHighlightField!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    Text[] fragments = nameHighlightField.getFragments();</span><br><span class="line">                    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span>(Text text:fragments)&#123;</span><br><span class="line">                        stringBuffer.append(text);</span><br><span class="line">                    &#125;</span><br><span class="line">                    name = stringBuffer.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由于前边设置了源文档字段过虑，这时description是取不到的</span></span><br><span class="line">            String description = (String) sourceAsMap.get(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">            <span class="comment">//学习模式</span></span><br><span class="line">            String studymodel = (String) sourceAsMap.get(<span class="string">&quot;studymodel&quot;</span>);</span><br><span class="line">            <span class="comment">//价格</span></span><br><span class="line">            Double price = (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">            <span class="comment">//日期</span></span><br><span class="line">            Date timestamp = dateFormat.parse((String) sourceAsMap.get(<span class="string">&quot;timestamp&quot;</span>));</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(studymodel);</span><br><span class="line">            System.out.println(description);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
          <category> 用法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> ELK </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch-入门篇</title>
      <link href="post/7f60dde9.html"/>
      <url>post/7f60dde9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章很长，喜欢的话，可以关注下博客。这段时间秋招忙完之后，会持续更新新内容</p></blockquote><h1 id="ElasticSearch介绍"><a href="#ElasticSearch介绍" class="headerlink" title="ElasticSearch介绍"></a>ElasticSearch介绍</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>1、elasticsearch是一个基于Lucene的高扩展的分布式搜索服务器，支持开箱即用。    </p><p>2、elasticsearch隐藏了Lucene的复杂性，对外提供Restful 接口来操作索引、搜索。</p><p><strong>突出优点：</strong> </p><ol><li><p>扩展性好，可部署上百台服务器集群，处理PB级数据。</p></li><li><p>近实时的去索引数据、搜索数据。</p></li></ol><p><strong>es和solr选择哪个？</strong></p><ol><li><p>如果你公司现在用的solr可以满足需求就不要换了。</p></li><li><p>如果你公司准备进行全文检索项目的开发，建议优先考虑elasticsearch，因为像Github这样大规模的搜索都在用它。</p></li></ol><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>下图是ElasticSearch的索引结构，下边黑色部分是物理结构，上边黄色部分是逻辑结构，逻辑结构也是为了更好的  去描述ElasticSearch的工作原理及去使用物理结构中的索引文件。</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/ElasticSearch/Introduction/0001.png" width=80%><p>逻辑结构部分是一个倒排索引表：</p><p>1、将要搜索的文档内容分词，所有不重复的词组成分词列表。</p><p>2、将搜索的文档最终以Document方式存储起来。</p><p>3、每个词和docment都有关联。</p><p>如下：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/ElasticSearch/Introduction/0002.png" width=40%><p>现在，如果我们想搜到<code>quick brown</code>我们只需要查找包含每个词条的文档：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/ElasticSearch/Introduction/0003.png" width=80%><p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ， 那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>1.创建索引库  ———————&gt;类似于:数据库的建表</p><p>2.创建映射  ———————&gt;类似于:数据库的添加表中字段</p><p>3.创建(添加)文档  ———————&gt;类似于:数据库的往表中添加数据。术语称这个过程为:创建索引</p><p>5.搜索文档  ———————&gt;类似于:从数据库里查数据</p><p>6.文档      ———————&gt;类似于:数据库中的一行记录(数据)</p><p>7.Field(域)   ———————&gt;类似于:数据库中的字段</p><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>ES的索引库是一个逻辑概念，它包括了分词列表及文档列表，同一个索引库中存储了相同类型的文档。它就相当于MySQL中的表，或相当于Mongodb中的集合。</p><p>索引(index)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 索引是 ES 对逻辑数据的逻辑存储，所以可以被分为更小的部分</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以将索引看成 MySQL 的 Table，索引的结构是为快速有效的全文索引准备的，特别是它不存储原始值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以将索引存放在一台机器，或分散在多台机器上</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每个索引有一或多个分片(shard)，每个分片可以有多个副本(replica)</span></span><br></pre></td></tr></table></figure><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>使用postman这样的工具创建： put <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%BA%93%E5%90%8D%E7%A7%B0">http://localhost:9200/索引库名称</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ES 中提供非结构化索引，实际上在底层 ES 会进行结构化操作，对用户透明</span></span><br><span class="line"></span><br><span class="line">PUT http://localhost:9200/索引库名称</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;index&quot;:&#123;</span><br><span class="line">            &quot;number_of_shards&quot;:&quot;1&quot;, # 分片数</span><br><span class="line">            &quot;number_of_replicas&quot;:&quot;0&quot; # 副本数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>number_of_shards：设置分片的数量，在集群中通常设置多个分片，表示一个索引库将拆分成多片分别存储不同  的结点，提高了ES的处理能力和高可用性，入门程序使用单机环境，这里设置为1。</p></li><li><p>number_of_replicas：设置副本的数量，设置副本是为了提高ES的高可靠性，单机环境设置为0.</p></li></ul><h2 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在索引中每个文档都包括了一个或多个ﬁeld，创建映射就是向索引库中创建ﬁeld的过程，下边是document和ﬁeld  与关系数据库的概念的类比：</p><p>文档（Document）—– Row记录</p><p>字段（Field）—– Columns 列</p><p>注意：6.0之前的版本有type（类型）概念，type相当于关系数据库的表，ES官方将在ES9.0版本中彻底删除type。  上边讲的创建索引库相当于关系数据库中的数据库还是表？</p><p>1、如果相当于数据库就表示一个索引库可以创建很多不同类型的文档，这在ES中也是允许的。</p><p>2、如果相当于表就表示一个索引库只能存储相同类型的文档，ES官方建议在一个索引库中只存储相同类型的文档。</p><p>3、所以索引库相当于数句酷的一个表</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>1、我们要把课程信息存储到ES中，这里我们创建课程信息的映射，先来一个简单的映射，如下： </p><p>发送：post <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%BA%93%E5%90%8D%E7%A7%B0/%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0/_mapping">http://localhost:9200/索引库名称/类型名称/_mapping</a></p><p>2、创建类型为xc_course的映射，共包括三个字段：name、description、studymondel 由于ES6.0版本还没有将type彻底删除，所以暂时把type起一个没有特殊意义的名字doc。post 请求：<a href="http://localhost:9200/xc_course/doc/_mapping">http://localhost:9200/xc_course/doc/_mapping</a></p><p>表示：在xc_course索引库下的doc类型下创建映射。doc是类型名，可以自定义，在ES6.0中要弱化类型的概念，  给它起一个没有具体业务意义的名称。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;description&quot;</span>:&#123; </span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;studymodel&quot;</span>:&#123; </span><br><span class="line">        <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>ES中的文档相当于MySQL数据库表中的记录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 存储在 ES 中的主要实体叫文档，可以看成 MySQL 的一条记录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ES 与 Mongo 的 document 类似，都可以有不同的结构，但 ES 相同字段必须有相同类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> document 由多个字段组成，每个字段可能多次出现在一个文档里，这样的字段叫多值字段(multivalued)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每个字段的类型，可以使文本、数值、日期等。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字段类型也可以是复杂类型，一个字段包含其他子文档或者数组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 ES 中，一个索引对象可以存储很多不同用途的 document，例如一个博客App中，可以保存文章和评论</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每个 document 可以有不同的结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不同的 document 不能为相同的属性设置不同的类型，例 : title 在同一索引中所有 Document 都应该相同数据类型</span></span><br></pre></td></tr></table></figure><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>发送：put 或Post <a href="http://localhost:9200/xc_course/doc/id%E5%80%BC">http://localhost:9200/xc_course/doc/id值</a></p><p>（如果不指定id值ES会自动生成ID）</p><p><a href="http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000">http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>:”Bootstrap开发框架<span class="string">&quot;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    &quot;description&quot; : &quot;Bootstrap是由Twitter推出的一个前台页面开发框架,在行业之中使用较为广泛。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者(尤其是不擅长页面开发的程序人员)轻松的实现个不受浏览器限制的精美界面 效果。”,</span><br><span class="line"></span><br><span class="line">&quot;studymodel&quot;: &quot;201001&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索文档"><a href="#搜索文档" class="headerlink" title="搜索文档"></a>搜索文档</h2><p>1、根据课程id查询文档</p><p>发送：get <a href="http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000">http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000</a></p><p>使用postman测试：</p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@v1.0.0/ElasticSearch/Introduction/0004.png"><p>2、查询所有记录</p><p>发送 get <a href="http://localhost:9200/xc_course/doc/_search">http://localhost:9200/xc_course/doc/_search</a></p><p>3、查询名称中包括spring 关键字的的记录</p><p>发送：get <a href="http://localhost:9200/xc_course/doc/_search?q=name:bootstrap">http://localhost:9200/xc_course/doc/_search?q=name:bootstrap</a></p><p>4、查询学习模式为201001的记录</p><p>发送 get <a href="http://localhost:9200/xc_course/doc/_search?q=studymodel:201001">http://localhost:9200/xc_course/doc/_search?q=studymodel:201001</a></p><p><strong>查询结果分析：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;took&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;max_score&quot;</span>: <span class="number">0.2876821</span>,</span><br><span class="line"><span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;xc_course&quot;</span>,</span><br><span class="line"><span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;doc&quot;</span>,</span><br><span class="line"><span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;4028e58161bcf7f40161bcf8b77c0000&quot;</span>,</span><br><span class="line"><span class="attr">&quot;_score&quot;</span>: <span class="number">0.2876821</span>,</span><br><span class="line"><span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Bootstrap开发框架&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Bootstrap是由Twitter推出的一个前台页面开发框架，在行业之中使用较 为广泛。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松的实现 一个不受浏览器限制的精美界面效果。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果说明：</strong></p><p>took：本次操作花费的时间，单位为毫秒。timed_out：请求是否超时</p><p>_shards：说明本次操作共搜索了哪些分片hits：搜索命中的记录</p><p>hits.total ： 符合条件的文档总数 hits.hits ：匹配度较高的前N个文档</p><p>hits.max_score：文档匹配得分，这里为最高分</p><p>_score：每个文档都有一个匹配度得分，按照降序排列。</p><p>_source：显示了文档的原始内容。</p><h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><h2 id="内置分词"><a href="#内置分词" class="headerlink" title="内置分词"></a>内置分词</h2><h3 id="分词API"><a href="#分词API" class="headerlink" title="分词API"></a>分词API</h3><p>分词是将一个文本转换成一系列单词的过程，也叫文本分析，在 ES 中称之为 Analysis</p><p>例如 : 我是中国人 -&gt; 我 | 是 | 中国人</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 指定分词器进行分词</span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;text&quot;</span>:<span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 结果中不仅可以看出分词的结果，还返回了该词在文本中的位置</span><br><span class="line"></span><br><span class="line"># 指定索引分词</span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/beluga/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;field&quot;</span>:<span class="string">&quot;hobby&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;text&quot;</span>:<span class="string">&quot;听音乐&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Standard 标准分词，按单词切分，并且会转换成小写</span></span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;standard&quot;,</span><br><span class="line">    &quot;text&quot;: &quot;A man becomes learned by asking questions.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Simple 分词器，按照非单词切分，并且做小写处理</span></span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;simple&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;If the document does&#x27;t already exist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Whitespace"><a href="#Whitespace" class="headerlink" title="Whitespace"></a>Whitespace</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Whitespace 是按照空格切分</span></span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;whitespace&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;If the document does&#x27;t already exist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stop"><a href="#Stop" class="headerlink" title="Stop"></a>Stop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Stop 去除 Stop Word 语气助词，如 the、an 等</span></span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;stop&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;If the document does&#x27;t already exist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Keyword"><a href="#Keyword" class="headerlink" title="Keyword"></a>Keyword</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> keyword 分词器，意思是传入就是关键词，不做分词处理</span></span><br><span class="line">POST http://[&#x27;自己的ip 加 port&#x27;]/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;keyword&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;If the document does&#x27;t already exist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 中文分词的难点在于，汉语中没有明显的词汇分界点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用中文分词器，IK jieba THULAC 等，推荐 IK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> IK Github 站点&lt;自定义词典扩展，禁用词典扩展等&gt;</span></span><br><span class="line">https://github.com/medcl/elasticsearch-analysis-ik</span><br></pre></td></tr></table></figure><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>安装过程这里不介绍，主要是解决常见中文分词的问题</p><p>Github地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p><h3 id="两种分词模式"><a href="#两种分词模式" class="headerlink" title="两种分词模式"></a>两种分词模式</h3><p>ik分词器有两种分词模式：ik_max_word和ik_smart模式。</p><p> 1、ik_max_word</p><p>会将文本做最细粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、  华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。</p><p>2、ik_smart</p><p>会做最粗粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。  测试两种分词模式：</p><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>上边章节安装了ik分词器，如果在索引和搜索时去使用ik分词器呢？如何指定其它类型的ﬁeld，比如日期类型、数  值类型等。本章节学习各种映射类型及映射维护方法。</p><h2 id="映射维护方法"><a href="#映射维护方法" class="headerlink" title="映射维护方法"></a>映射维护方法</h2><p>1、查询所有索引的映射：</p><p>GET： <a href="http://localhost:9200/_mapping">http://localhost:9200/_mapping</a></p><p>2、创建映射</p><p>post 请求：<a href="http://localhost:9200/xc_course/doc/_mapping">http://localhost:9200/xc_course/doc/_mapping</a></p><p>在上面提到过</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">&quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &quot;description&quot;:&#123; </span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &quot;studymodel&quot;:&#123; </span><br><span class="line">        &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、更新映射</p><p>映射创建成功可以添加新字段，已有字段不允许更新。</p><p>4、删除映射</p><p>通过删除索引来删除映射。</p><h2 id="常用映射类型"><a href="#常用映射类型" class="headerlink" title="常用映射类型"></a>常用映射类型</h2><h3 id="text文本字段"><a href="#text文本字段" class="headerlink" title="text文本字段"></a>text文本字段</h3><p><strong>1）text</strong></p><p>字符串包括text和keyword两种类型： 通过analyzer属性指定分词器。 </p><p>下边指定name的字段类型为text，使用ik分词器的ik_max_word分词模式。 </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边指定了analyzer是指在索引和搜索都使用ik_max_word，如果单独想定义搜索时使用的分词器则可以通过search_analyzer属性。</p><p>对于ik分词器建议是索引时使用ik_max_word将搜索内容进行细粒度分词，搜索时使用ik_smart提高搜索精确性。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2） index</strong></p><p>通过index属性指定是否索引。</p><p>默认为index=true，即要进行索引，只有进行索引才可以从索引库搜索到。</p><p>但是也有一些内容不需要索引，比如：商品图片地址只被用来展示图片，不进行搜索图片，此时可以将index设置  为false。</p><p>删除索引，重新创建映射，将pic的index设置为false，尝试根据pic去搜索，结果搜索不到数据</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）store</strong></p><p>是否在source之外存储，每个文档索引后会在 ES中保存一份原始文档，存放在”_source”中，一般情况下不需要设置 store为true，因为在_source中已经有一份原始文档了。</p><h3 id="keyword关键字字段"><a href="#keyword关键字字段" class="headerlink" title="keyword关键字字段"></a>keyword关键字字段</h3><p>上边介绍的text文本字段在映射时要设置分词器，keyword字段为关键字字段，通常搜索keyword是按照整体搜     索，所以创建keyword字段的索引时是不进行分词的，比如：邮政编码、手机号码、身份证等。keyword字段通常  用于过虑、排序、聚合等。</p><p><strong>测试：</strong></p><p>更改映射：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加文档：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;java编程基础&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;java语言是世界第一编程语言，在软件开发领域使用人数最多。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: <span class="string">&quot;group1/M00/00/01/wKhlQFqO4MmAOP53AAAcwDwm6SU490.jpg&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据name查询文档。搜索：<a href="http://localhost:9200/xc_course/_search?q=name:java">http://localhost:9200/xc_course/_search?q=name:java</a> name是keyword类型，所以查询方式是精确查询。</p><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p>日期类型不用设置分词器。</p><p>通常日期类型的字段用于排序。</p><p>1)format</p><p>通过format设置日期格式例子：</p><p>下边的设置允许date字段存储年月日时分秒、年月日及毫秒三种格式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line"><span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入文档： </p><p>Post :<a href="http://localhost:9200/xc_course/doc/3">http://localhost:9200/xc_course/doc/3</a> </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;spring开发基础&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;spring 在java领域非常流行，java程序员都在用。&quot;</span>,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: <span class="string">&quot;201001&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: <span class="string">&quot;group1/M00/00/01/wKhlQFqO4MmAOP53AAAcwDwm6SU490.jpg&quot;</span>,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2018‐07‐04 18:28:58&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h3><p>post：<a href="http://localhost:9200/xc_course/doc/_mapping">http://localhost:9200/xc_course/doc/_mapping</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line"><span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;float&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;studymodel&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;timestamp&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line"><span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
          <category> 用法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> ELK </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
