<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析 | 风祈的时光录</title><meta name="keywords" content="Dubbo，rpc"><meta name="author" content="youthlql"><meta name="copyright" content="youthlql"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Dubbo服务导出源码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析">
<meta property="og:url" content="https://imlql.cn/post/48141866.html">
<meta property="og:site_name" content="风祈的时光录">
<meta property="og:description" content="Dubbo服务导出源码解析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png">
<meta property="article:published_time" content="2021-10-06T06:11:58.000Z">
<meta property="article:modified_time" content="2022-07-24T11:02:09.801Z">
<meta property="article:author" content="youthlql">
<meta property="article:tag" content="Dubbo">
<meta property="article:tag" content="rpc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png"><link rel="shortcut icon" href="https://npm.elemecdn.com/youthlql@1.0.8/blog/favicon.png"><link rel="canonical" href="https://imlql.cn/post/48141866"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f693ff99cc7e613b88cf5b729a14b48b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-24 19:02:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://npm.elemecdn.com/lql_static@latest/butterfly_static/css/ali_icon.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lql_static@latest/butterfly_static/css/02-19-mogai.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="风祈的时光录" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/avatar/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://youthlql.gitee.io/lql_nav/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">风祈的时光录</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://youthlql.gitee.io/lql_nav/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-06T06:11:58.000Z" title="发表于 2021-10-06 14:11:58">2021-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-24T11:02:09.801Z" title="更新于 2022-07-24 19:02:09">2022-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/rpc/">rpc</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/rpc/Dubbo%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97v1/">Dubbo源码系列v1</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第五节-Dubbo服务注册-导出-源码解析"><a href="#第五节-Dubbo服务注册-导出-源码解析" class="headerlink" title="第五节: Dubbo服务注册(导出)源码解析"></a>第五节: Dubbo服务注册(导出)源码解析</h2><h3 id="服务导出原理概述"><a href="#服务导出原理概述" class="headerlink" title="服务导出原理概述"></a>服务导出原理概述</h3><ol>
<li>服务导出的入口为ServiceBean中的export()方法，当Spring启动完之后，通过接收Spring的ContextRefreshedEvent事件来触发export()方法的执行。</li>
<li>一个ServiceBean对象就表示一个Dubbo服务，ServiceBean对象中的参数就表示服务的参数，比如timeout，该对象的参数值来至@Service注解中所定义的。</li>
<li>服务导出主要得做两件事情：<ol>
<li>根据服务的参数信息，启动对应的网络服务器（netty、tomcat、jetty等），用来接收网络请求</li>
<li>将服务的信息注册到注册中心</li>
</ol>
</li>
<li>但是在做这两件事情之前得先把服务的参数确定好，因为一个Dubbo服务的参数，除开可以在@Service注解中去配置，还会继承Dubbo服务所属应用（Application）上的配置，还可以在配置中心或JVM环境变量中去配置某个服务的参数，所以首先要做的是确定好当前服务最终的（优先级最高）的参数值。</li>
<li>确定好服务参数之后，就根据所配置的协议启动对应的网络服务器。在启动网络服务器时，并且在网络服务器接收请求的过程中，都可以从服务参数中获取信息，比如最大连接数，线程数，socket超时时间等等。</li>
<li>启动完网络服务器之后，就将服务信息注册到注册中心。同时还有向注册中心注册监听器，监听Dubbo的中的动态配置信息变更。</li>
</ol>
<blockquote>
<p>服务导出就是服务注册的意思</p>
</blockquote>
<h3 id="服务概念的演化"><a href="#服务概念的演化" class="headerlink" title="服务概念的演化"></a>服务概念的演化</h3><ol>
<li> DemoService接口表示一个服务，此时的服务表示服务定义</li>
<li> DemoServiceImpl表示DemoService服务的具体实现，此时的服务表示服务的具体实现</li>
<li> DemoService+group+version表示一个服务，此时的服务增加了分组和版本概念</li>
<li> <a target="_blank" rel="noopener" href="http://192.168.31.211/com.luban.DemoService">http://192.168.31.211:80/cn.imlql.DemoService</a>表示一个服务，此时的服务增加了机器IP和Port，表示远程机器可以访问这个URL来使用cn.imlql.DemoService这个服务</li>
<li><a target="_blank" rel="noopener" href="http://192.168.31.211/com.luban.DemoService">http://192.168.31.211:80/cn.imlql.DemoService</a>?timeout=3000&amp;version=1.0.1&amp;application=dubbo-demo-provider-application表示一个服务，此时的服务是拥有参数的，比如超时时间、版本号、所属应用</li>
</ol>
<p>在dubbo中就是用的最后一种方式来表示服务的。</p>
<h3 id="服务导出思想"><a href="#服务导出思想" class="headerlink" title="服务导出思想"></a>服务导出思想</h3><p>服务导出要做的几件事情：</p>
<ol>
<li>确定服务的参数<ol start="2">
<li> 确定服务支持的协议</li>
<li> 构造服务最终的URL</li>
</ol>
</li>
<li> 根据服务支持的不同协议，启动不同的Server，用来接收和处理请求</li>
<li> 将服务URL注册到注册中心去</li>
<li>因为Dubbo支持动态配置服务参数，所以服务导出时还需要绑定一个监听器Listener来监听服务的参数是否有修改，如果发现有修改，则需要重新进行导出</li>
</ol>
<h3 id="确定服务的参数"><a href="#确定服务的参数" class="headerlink" title="确定服务的参数"></a>确定服务的参数</h3><h4 id="确定服务的参数概述"><a href="#确定服务的参数概述" class="headerlink" title="确定服务的参数概述"></a>确定服务的参数概述</h4><ul>
<li><p>在执行ServiceConfig.export()时，此时ServiceConfig对象就代表一个服务(也可以说ServiceBena代表一个服务，因为本来就是继承关系)，我们已经知道了这个服务的名字（就是服务提供者接口的名字），并且此时这个服务可能已经有一些参数了，就是**@Service注解上所定义的参数**。</p>
</li>
<li><p>但是在Dubbo中，除开可以在@Service注解中给服务配置参数，还有很多地方也可以给服务配置参数，比如：</p>
<ul>
<li>dubbo.properties文件，你可以建立这个文件，dubbo会去读取这个文件的内容作为服务的参数，Dubob的源码中叫做<strong>PropertiesConfiguration</strong></li>
<li>配置中心，dubbo在2.7版本后就支持了分布式配置中心，你可以在Dubbo-Admin中去操作配置中心，分布式配置中心就相当于一个远程的dubbo.properties文件，你可以在Dubbo-Admin中去修改这个dubbo.properties文件，当然配置中心支持按应用进行配置，也可以按全局进行配置两种，在Dubbo的源码中<strong>AppExternalConfiguration</strong>表示应用配置，<strong>ExternalConfiguration</strong>表示全局配置。</li>
<li>系统环境变量，你可以在启动应用程序时，通过-D的方式来指定参数，在Dubbo的源码中叫<strong>SystemConfiguration</strong></li>
<li>再加上通过@Service注解所配置的参数，在Dubbo的源码中叫<strong>AbstractConfig</strong></li>
</ul>
</li>
<li><p>服务的参数可以从这四个位置来，这四个位置上如果配了同一个参数的话，优先级从高到低有两种情况：</p>
<ul>
<li>SystemConfiguration -&gt; AppExternalConfiguration -&gt; ExternalConfiguration -&gt; AbstractConfig -&gt; PropertiesConfiguration</li>
<li>SystemConfiguration -&gt; AbstractConfig -&gt; AppExternalConfiguration -&gt; ExternalConfiguration -&gt; PropertiesConfiguration</li>
</ul>
</li>
<li><p>在服务导出时，首先得确定服务的参数。当然，服务的参数除开来自于服务的自身配置外，还可以来自其<strong>上级</strong>。比如如果服务本身没有配置timeout参数，但是如果服务所属的应用的配置了timeout，那么这个应用下的服务都会继承这个timeout配置。<strong>所以在确定服务参数时，需要先从上级获取参数，获取之后，如果服务本身配置了相同的参数，那么则进行覆盖。</strong></p>
</li>
</ul>
<h4 id="确定服务的参数源码"><a href="#确定服务的参数源码" class="headerlink" title="确定服务的参数源码"></a>确定服务的参数源码</h4><h5 id="ServiceBean"><a href="#ServiceBean" class="headerlink" title="ServiceBean"></a>ServiceBean</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当Spring启动完之后，通过接收Spring的ContextRefreshedEvent事件来触发export()方法的执行。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当前服务没有被导出并且没有卸载，才导出服务</span></span><br><span class="line">       <span class="keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 服务导出（服务注册）</span></span><br><span class="line">           export();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用ServiceConfig#export()</span></span><br><span class="line">       <span class="keyword">super</span>.export();</span><br><span class="line">       <span class="comment">// Publish ServiceBeanExportedEvent</span></span><br><span class="line">       <span class="comment">// Spring启动完发布ContextRefreshedEvent事件---&gt;服务导出---&gt;发布ServiceBeanExportedEvent</span></span><br><span class="line">       <span class="comment">// 程序员可以通过Spring中的ApplicationListener来监听服务导出是否完成</span></span><br><span class="line">       publishExportEvent();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishExportEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//监听这个事件就可以知道Dubbo的服务有没有注册完成</span></span><br><span class="line">       ServiceBeanExportedEvent exportEvent = <span class="keyword">new</span> ServiceBeanExportedEvent(<span class="keyword">this</span>);</span><br><span class="line">       applicationEventPublisher.publishEvent(exportEvent);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="ServiceConfig"><a href="#ServiceConfig" class="headerlink" title="ServiceConfig"></a>ServiceConfig</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//读取服务配置</span></span><br><span class="line">       checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查服务是否需要导出</span></span><br><span class="line">       <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;   </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查是否需要延迟发布</span></span><br><span class="line">       <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">           DELAY_EXPORT_EXECUTOR.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 导出服务</span></span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAndUpdateSubConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Use default configs defined explicitly on global configs</span></span><br><span class="line">       <span class="comment">// ServiceConfig中的某些属性如果是空的，那么就从ProviderConfig、ModuleConfig、ApplicationConfig中获取</span></span><br><span class="line">       <span class="comment">// 补全ServiceConfig中的属性</span></span><br><span class="line">       completeCompoundConfigs();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Config Center should always being started first.</span></span><br><span class="line">       <span class="comment">// 从配置中心获取配置，包括应用配置和全局配置</span></span><br><span class="line">       <span class="comment">// 把获取到的配置放入到Environment中的externalConfigurationMap和appExternalConfigurationMap中</span></span><br><span class="line">       <span class="comment">// 并刷新所有的XxConfig的属性（除开ServiceConfig），刷新的意思就是将配置中心的配置覆盖调用XxConfig中的属性</span></span><br><span class="line">       <span class="comment">// 调用AbstractInterfaceConfig#startConfigCenter()</span></span><br><span class="line">       startConfigCenter();</span><br><span class="line"></span><br><span class="line">       checkDefault();</span><br><span class="line"></span><br><span class="line">       checkProtocol();</span><br><span class="line"></span><br><span class="line">       checkApplication();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if protocol is not injvm checkRegistry</span></span><br><span class="line">       <span class="comment">// 如果protocol不是只有injvm协议，表示服务调用不是只在本机jvm里面调用，那就需要用到注册中心</span></span><br><span class="line">       <span class="keyword">if</span> (!isOnlyInJvm()) &#123;</span><br><span class="line">           checkRegistry();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 刷新ServiceConfig，调用AbstractConfig#refresh()</span></span><br><span class="line">       <span class="keyword">this</span>.refresh();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果配了metadataReportConfig，那么就刷新配置</span></span><br><span class="line">       checkMetadataReport();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(interfaceName)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前服务对应的实现类是一个GenericService，表示没有特定的接口</span></span><br><span class="line">       <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">           interfaceClass = GenericService.class;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">               generic = Boolean.TRUE.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 加载接口</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                       .getContextClassLoader());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 刷新MethodConfig，并判断MethodConfig中对应的方法在接口中是否存在</span></span><br><span class="line">           checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">           <span class="comment">// 实现类是不是该接口类型</span></span><br><span class="line">           checkRef();</span><br><span class="line">           generic = Boolean.FALSE.toString();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// local和stub一样，不建议使用了</span></span><br><span class="line">       <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果本地存根为true，则存根类为interfaceName + &quot;Local&quot;</span></span><br><span class="line">           <span class="keyword">if</span> (Boolean.TRUE.toString().equals(local)) &#123;</span><br><span class="line">               local = interfaceName + <span class="string">&quot;Local&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 加载本地存根类</span></span><br><span class="line">           Class&lt;?&gt; localClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               localClass = ClassUtils.forNameWithThreadContextClassLoader(local);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The local implementation class &quot;</span> + localClass.getName() + <span class="string">&quot; not implement interface &quot;</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 本地存根</span></span><br><span class="line">       <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果本地存根为true，则存根类为interfaceName + &quot;Stub&quot;</span></span><br><span class="line">           <span class="keyword">if</span> (Boolean.TRUE.toString().equals(stub)) &#123;</span><br><span class="line">               stub = interfaceName + <span class="string">&quot;Stub&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; stubClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               stubClass = ClassUtils.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The stub implementation class &quot;</span> + stubClass.getName() + <span class="string">&quot; not implement interface &quot;</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 检查local和stub</span></span><br><span class="line">       checkStubAndLocal(interfaceClass);</span><br><span class="line">       <span class="comment">// 检查mock</span></span><br><span class="line">       checkMock(interfaceClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.上节文章我们在启动类上写了这个配置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@PropertySource</span>(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line"><span class="comment">    * 2.那么Spring启动的时候就会加载里面的配置到一些xxxConfig里面【Spring整合Dubbo的时候讲过】</span></span><br><span class="line"><span class="comment">    * 3.<span class="doctag">@Service</span>注解里配置的参数被首先读取到了ServiceBean里</span></span><br><span class="line"><span class="comment">    * 4.接着会调用这个方法进行补全ServiceBean的配置，从哪里补全呢？就是从上面我们配置的</span></span><br><span class="line"><span class="comment">    * dubbo-provider.properties  进行补全</span></span><br><span class="line"><span class="comment">    * 5.ServcieBean继承了ServiceConfig，所以它两是一个意思，这里强调一下</span></span><br><span class="line"><span class="comment">    * 免得后续看不明白</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeCompoundConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 如果配置了provider，那么则从provider中获取信息赋值其他属性，在这些属性为空的情况下</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setApplication(provider.getApplication());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setModule(provider.getModule());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setRegistries(provider.getRegistries());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setMonitor(provider.getMonitor());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setProtocols(provider.getProtocols());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (configCenter == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setConfigCenter(provider.getConfigCenter());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果配置了module，那么则从module中获取信息赋值其他属性，在这些属性为空的情况下</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setRegistries(<span class="keyword">module</span>.getRegistries());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setMonitor(<span class="keyword">module</span>.getMonitor());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果配置了application，那么则从application中获取信息赋值其他属性，在这些属性为空的情况下</span></span><br><span class="line">       <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setRegistries(application.getRegistries());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               setMonitor(application.getMonitor());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="AbstractInterfaceConfig"><a href="#AbstractInterfaceConfig" class="headerlink" title="AbstractInterfaceConfig"></a>AbstractInterfaceConfig</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startConfigCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (configCenter == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ConfigManager.getInstance().getConfigCenter().ifPresent(cc -&gt; <span class="keyword">this</span>.configCenter = cc);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果配置了ConfigCenter</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.configCenter != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 从其他位置获取配置中心的相关属性信息，比如配置中心地址</span></span><br><span class="line">           <span class="comment">// TODO there may have duplicate refresh</span></span><br><span class="line">           <span class="keyword">this</span>.configCenter.refresh();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 属性更新后，从远程配置中心获取数据(应用配置，全局配置)</span></span><br><span class="line">           prepareEnvironment();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从配置中心取到配置数据后，刷新所有的XxConfig中的属性，除开ServiceConfig</span></span><br><span class="line">       ConfigManager.getInstance().refreshAll();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (configCenter.isValid()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!configCenter.checkOrUpdateInited()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 动态配置中心，管理台上的配置中心</span></span><br><span class="line">           DynamicConfiguration dynamicConfiguration = getDynamicConfiguration(configCenter.toUrl());</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果是zookeeper，获取的就是/dubbo/config/dubbo/dubbo.properties节点中的内容</span></span><br><span class="line">           String configContent = dynamicConfiguration.getProperties(configCenter.getConfigFile(), configCenter.getGroup());</span><br><span class="line"></span><br><span class="line">           String appGroup = application != <span class="keyword">null</span> ? application.getName() : <span class="keyword">null</span>;</span><br><span class="line">           String appConfigContent = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotEmpty(appGroup)) &#123;</span><br><span class="line">               <span class="comment">// 获取的就是/dubbo/config/dubbo-demo-consumer-application/dubbo.properties节点中的内容</span></span><br><span class="line">               <span class="comment">// 这里有bug</span></span><br><span class="line">               appConfigContent = dynamicConfiguration.getProperties</span><br><span class="line">                       (StringUtils.isNotEmpty(configCenter.getAppConfigFile()) ? configCenter.getAppConfigFile() : configCenter.getConfigFile(),</span><br><span class="line">                        appGroup</span><br><span class="line">                       );</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Environment.getInstance().setConfigCenterFirst(configCenter.isHighestPriority());</span><br><span class="line">               <span class="comment">//这个就是全局的，就是在网页上那个配置管理里的global</span></span><br><span class="line">               Environment.getInstance().updateExternalConfigurationMap(parseProperties(configContent));</span><br><span class="line">               <span class="comment">//这个就是某个应用的配置</span></span><br><span class="line">               Environment.getInstance().updateAppExternalConfigurationMap(parseProperties(appConfigContent));</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to parse configurations from Config Center.&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConfigManager"><a href="#ConfigManager" class="headerlink" title="ConfigManager"></a>ConfigManager</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// refresh all configs here,</span></span><br><span class="line">       getApplication().ifPresent(ApplicationConfig::refresh);</span><br><span class="line">       getMonitor().ifPresent(MonitorConfig::refresh);</span><br><span class="line">       getModule().ifPresent(ModuleConfig::refresh);</span><br><span class="line"></span><br><span class="line">       getProtocols().values().forEach(ProtocolConfig::refresh);</span><br><span class="line">       getRegistries().values().forEach(RegistryConfig::refresh);</span><br><span class="line">       getProviders().values().forEach(ProviderConfig::refresh);</span><br><span class="line">       getConsumers().values().forEach(ConsumerConfig::refresh);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="AbstractConfig"><a href="#AbstractConfig" class="headerlink" title="AbstractConfig"></a>AbstractConfig</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.刷新XxConfig</span></span><br><span class="line"><span class="comment">     * 2.一个XxConfig对象的属性可能是有值的，也可能是没有值的，这时需要从其他位置获取属性值,来进行属性的覆盖</span></span><br><span class="line"><span class="comment">     * 覆盖的优先级，从大到小为系统变量-&gt;配置中心应用配置-&gt;配置中心全局配置-&gt;注解或xml中定义-&gt;dubbo.properties文件</span></span><br><span class="line"><span class="comment">     * 3.以ServiceConfig为例，ServiceConfig中包括很多属性，比如timeout</span></span><br><span class="line"><span class="comment">     * 但是在定义一个Service时，如果在注解上没有配置timeout，那么就会其他地方获取timeout的配置</span></span><br><span class="line"><span class="comment">     * 比如可以从系统变量-&gt;配置中心应用配置-&gt;配置中心全局配置-&gt;注解或xml中定义-&gt;dubbo.properties文件</span></span><br><span class="line"><span class="comment">     * refresh是刷新，将当前ServiceConfig上的set方法所对应的属性更新为优先级最高的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.这里确定的配置优先级从高到低是这样的</span></span><br><span class="line"><span class="comment">             * 系统环境变量【JVM环境变量-&gt;操作系统环境变量】-&gt;配置中心应用配置-&gt;配置中心全局配置-&gt;dubbo.properties文件</span></span><br><span class="line"><span class="comment">             * 2.调用的是Environment#getConfiguration()</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            CompositeConfiguration compositeConfiguration = Environment.getInstance().getConfiguration(getPrefix(), getId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 表示XxConfig对象本身- AbstractConfig</span></span><br><span class="line">            Configuration config = <span class="keyword">new</span> ConfigConfigurationAdapter(<span class="keyword">this</span>);  <span class="comment">// ServiceConfig</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Environment.getInstance().isConfigCenterFirst()) &#123;<span class="comment">//这个是默认的</span></span><br><span class="line">                <span class="comment">// 优先级顺序: SystemConfiguration -&gt; AppExternalConfiguration -&gt; ExternalConfiguration -&gt; AbstractConfig -&gt; PropertiesConfiguration</span></span><br><span class="line">                compositeConfiguration.addConfiguration(<span class="number">4</span>, config);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The sequence would be: SystemConfiguration -&gt; AbstractConfig -&gt; AppExternalConfiguration -&gt; ExternalConfiguration -&gt; PropertiesConfiguration</span></span><br><span class="line">                compositeConfiguration.addConfiguration(<span class="number">2</span>, config);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop methods, get override value and set the new value back to method</span></span><br><span class="line">            Method[] methods = getClass().getMethods();  <span class="comment">//ServiceBean</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="comment">// 是不是setXX()方法</span></span><br><span class="line">                <span class="keyword">if</span> (MethodUtils.isSetter(method)) &#123;</span><br><span class="line">                    <span class="comment">// 获取xx配置项的value</span></span><br><span class="line">                    String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));</span><br><span class="line">                    <span class="comment">// isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two &#x27;setGeneric&#x27; methods in ReferenceConfig.</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(value) &amp;&amp; ClassUtils.isTypeMatch(method.getParameterTypes()[<span class="number">0</span>], value)) &#123;</span><br><span class="line">                        method.invoke(<span class="keyword">this</span>, ClassUtils.convertPrimitive(method.getParameterTypes()[<span class="number">0</span>], value));</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 是不是setParameters()方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isParametersSetter(method)) &#123;</span><br><span class="line">                    <span class="comment">// 获取parameter配置项的value</span></span><br><span class="line">                    String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">                        Map&lt;String, String&gt; map = invokeGetParameters(getClass(), <span class="keyword">this</span>);</span><br><span class="line">                        map = map == <span class="keyword">null</span> ? <span class="keyword">new</span> HashMap&lt;&gt;() : map;</span><br><span class="line">                        map.putAll(convert(StringUtils.parseParameters(value), <span class="string">&quot;&quot;</span>));</span><br><span class="line">                        invokeSetParameters(getClass(), <span class="keyword">this</span>, map);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to override &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompositeConfiguration <span class="title">getConfiguration</span><span class="params">(String prefix, String id)</span> </span>&#123;</span><br><span class="line">    CompositeConfiguration compositeConfiguration = <span class="keyword">new</span> CompositeConfiguration();</span><br><span class="line">    <span class="comment">// Config center has the highest priority</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM环境变量</span></span><br><span class="line">    compositeConfiguration.addConfiguration(<span class="keyword">this</span>.getSystemConfig(prefix, id));</span><br><span class="line">    <span class="comment">// 操作系统环境变量</span></span><br><span class="line">    compositeConfiguration.addConfiguration(<span class="keyword">this</span>.getEnvironmentConfig(prefix, id));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置中心APP配置</span></span><br><span class="line">    compositeConfiguration.addConfiguration(<span class="keyword">this</span>.getAppExternalConfig(prefix, id));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置中心Global配置</span></span><br><span class="line">    compositeConfiguration.addConfiguration(<span class="keyword">this</span>.getExternalConfig(prefix, id));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dubbo.properties中的配置</span></span><br><span class="line">    compositeConfiguration.addConfiguration(<span class="keyword">this</span>.getPropertiesConfig(prefix, id));</span><br><span class="line">    <span class="keyword">return</span> compositeConfiguration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="确定服务支持的协议"><a href="#确定服务支持的协议" class="headerlink" title="确定服务支持的协议"></a>确定服务支持的协议</h4><p>确定服务所支持的协议还是比较简单的，就是看用户配了多少个Protocol。和服务参数意义，Protocol也是可以在各个配置点进行配置的。  </p>
<ol>
<li> 首先在SpringBoot的application.properties文件中就可能配置了协议</li>
<li> 也可能在dubbo.properties文件中配置了协议</li>
<li> 也可能在配置中心中也配置了协议</li>
<li>也可能通过-D的方式也配置了协议</li>
</ol>
<p>所以在服务导出时，需要从以上几个地方获取协议，结果可能是一个协议，也可能是多个协议，从而确定出协议。</p>
<h4 id="URL作用"><a href="#URL作用" class="headerlink" title="URL作用"></a>URL作用</h4><ol>
<li><p>资源</p>
<ol>
<li>注册中心URL：zookeeper://ip+port?dynamic=true</li>
<li>服务：dubbo://ip+port/接口名?timeout=3000</li>
<li>服务：<a target="_blank" rel="noopener" href="http://ip+port/%E6%8E%A5%E5%8F%A3%E5%90%8D?timeout=3000">http://ip+port/接口名?timeout=3000</a></li>
</ol>
</li>
<li><p>方便扩展</p>
</li>
</ol>
<h4 id="构造服务最终的URL"><a href="#构造服务最终的URL" class="headerlink" title="构造服务最终的URL"></a>构造服务最终的URL</h4><p>有了确定的协议，服务名，服务参数后，自然就可以组装成服务的URL了。</p>
<p>但是还有一点是非常重要的，在Dubbo中支持服务动态配置，注意，这个和配置中心不是同一概念，动态配置是可以在服务导出后动态的去修改服务配置的，而配置中心则不能达到这一的效果（这个我要在确定一下）。</p>
<p>动态配置，其实就是继续给服务增加了一些参数，所以在把服务的URL注册到注册中心去之前，得先按照动态配置中所添加的配置重写一下URL，也就是应用上动态配置中的参数。</p>
<p>只有这样作完之后得到的URL才是<strong>真正准确</strong>的服务提供者URL。</p>
<h3 id="开始服务注册相关过程"><a href="#开始服务注册相关过程" class="headerlink" title="开始服务注册相关过程"></a>开始服务注册相关过程</h3><blockquote>
<ol>
<li> 根据服务支持的不同协议，启动不同的Server，用来接收和处理请求</li>
<li> 将服务URL注册到注册中心去</li>
<li> 因为Dubbo支持动态配置服务参数，所以服务导出时还需要绑定一个监听器Listener来监听服务的参数是否有修改，如果发现有修改，则需要重新进行导出</li>
</ol>
<p>这三个步骤都会在<code>ServiceConfig#export()#doExport()</code> 这个方法里做，流程比较复杂，就直接看代码吧</p>
</blockquote>
<h4 id="公用源码"><a href="#公用源码" class="headerlink" title="公用源码"></a>公用源码</h4><blockquote>
<p>这个部分的源码是前面三个步骤公用的</p>
</blockquote>
<h5 id="ServiceConfig-1"><a href="#ServiceConfig-1" class="headerlink" title="ServiceConfig"></a>ServiceConfig</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//读取服务配置</span></span><br><span class="line">       checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查服务是否需要导出，@Service里可以配置</span></span><br><span class="line">       <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查是否需要延迟发布，@Service里可以配置</span></span><br><span class="line">       <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">           DELAY_EXPORT_EXECUTOR.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 导出服务</span></span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; has already unexported!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 已经导出了，就不再导出了</span></span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(path)) &#123;</span><br><span class="line">           path = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line">       doExportUrls();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// registryURL 表示一个注册中心</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置的每一个protocol都会产生一个dubbo服务，所以这里是循环配置的协议，</span></span><br><span class="line">       <span class="comment">// 我们这里假设配置了dubbo,但是配了两个端口，这样也算两个protocol</span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// pathKey = group/contextpath/path:version</span></span><br><span class="line">           <span class="comment">// 例子：myGroup/user/org.apache.dubbo.demo.DemoService:1.0.1</span></span><br><span class="line">           String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), group, version);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// ProviderModel中存在服务提供者访问路径，实现类，接口，以及接口中的各个方法对应的ProviderMethodModel</span></span><br><span class="line">           <span class="comment">// ProviderMethodModel表示某一个方法，方法名，所属的服务的，</span></span><br><span class="line">           ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(pathKey, ref, interfaceClass);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// ApplicationModel表示应用中有哪些服务提供者和引用了哪些服务</span></span><br><span class="line">           ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 重点，每一个协议都会注册一个服务</span></span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// protocolConfig表示某个协议，registryURLs表示所有的注册中心</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果配置的某个协议，没有配置name，那么默认为dubbo</span></span><br><span class="line">       String name = protocolConfig.getName();</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">           name = DUBBO;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这个map表示服务url的参数</span></span><br><span class="line">       Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">       map.put(SIDE_KEY, PROVIDER_SIDE);</span><br><span class="line"></span><br><span class="line">       appendRuntimeParameters(map);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 监控中心参数</span></span><br><span class="line">       appendParameters(map, metrics);</span><br><span class="line">       <span class="comment">// 应用相关参数</span></span><br><span class="line">       appendParameters(map, application);</span><br><span class="line">       <span class="comment">// 模块相关参数</span></span><br><span class="line">       appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">       <span class="comment">// remove &#x27;default.&#x27; prefix for configs from ProviderConfig</span></span><br><span class="line">       <span class="comment">// appendParameters(map, provider, Constants.DEFAULT_KEY);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 提供者相关参数</span></span><br><span class="line">       appendParameters(map, provider);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 协议相关参数</span></span><br><span class="line">       appendParameters(map, protocolConfig);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 服务本身相关参数</span></span><br><span class="line">       appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 服务中某些方法参数，@Service里可以针对某些方法配置某些参数</span></span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methods)) &#123;</span><br><span class="line">           <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">               <span class="comment">// 某个方法的配置参数，注意有prefix</span></span><br><span class="line">               appendParameters(map, method, method.getName());</span><br><span class="line">               String retryKey = method.getName() + <span class="string">&quot;.retry&quot;</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果某个方法配置存在xx.retry=false，则改成xx.retry=0</span></span><br><span class="line">               <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                   String retryValue = map.remove(retryKey);</span><br><span class="line">                   <span class="keyword">if</span> (Boolean.FALSE.toString().equals(retryValue)) &#123;</span><br><span class="line">                       map.put(method.getName() + <span class="string">&quot;.retries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">               <span class="keyword">if</span> (CollectionUtils.isNotEmpty(arguments)) &#123;</span><br><span class="line">                   <span class="comment">// 遍历当前方法配置中的参数配置</span></span><br><span class="line">                   <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 如果配置了type，则遍历当前接口的所有方法，然后找到方法名和当前方法名相等的方法，可能存在多个</span></span><br><span class="line">                       <span class="comment">// 如果配置了index,则看index对应位置的参数类型是否等于type,如果相等，则向map中存入argument对象中的参数</span></span><br><span class="line">                       <span class="comment">// 如果没有配置index，那么则遍历方法所有的参数类型，等于type则向map中存入argument对象中的参数</span></span><br><span class="line">                       <span class="comment">// 如果没有配置type,但配置了index,则把对应位置的argument放入map</span></span><br><span class="line">                       <span class="comment">// convert argument type</span></span><br><span class="line">                       <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                           <span class="comment">// visit all methods</span></span><br><span class="line">                           <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                   String methodName = methods[i].getName();</span><br><span class="line">                                   <span class="comment">// target the method, and get its signature</span></span><br><span class="line">                                   <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                       Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                       <span class="comment">// one callback in the method</span></span><br><span class="line">                                       <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                           <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                               appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + argument.getIndex());</span><br><span class="line">                                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="string">&quot;, type:&quot;</span> + argument.getType());</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                           <span class="comment">// multiple callbacks in the method</span></span><br><span class="line">                                           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                               Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                               <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                   appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + j);</span><br><span class="line">                                                   <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="string">&quot;, type:&quot;</span> + argument.getType());</span><br><span class="line">                                                   &#125;</span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                           appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + argument.getIndex());</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config must set index or type attribute.eg: &lt;dubbo:argument index=&#x27;0&#x27; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="comment">// end of methods for</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">           map.put(GENERIC_KEY, generic);</span><br><span class="line">           map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">           <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               map.put(REVISION_KEY, revision);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 通过接口对应的Wrapper，拿到接口中所有的方法名字</span></span><br><span class="line">           String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">           <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">               map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Token是为了防止服务被消费者直接调用（伪造http请求）,可以在@Service里配置</span></span><br><span class="line">       <span class="comment">// 这里防止的是某些消费者不是从注册中心拿到的URL调用提供者，而是消费者自己拼出的URL进行调用</span></span><br><span class="line">       <span class="comment">// 服务调用的是会有个Tokenfilter过滤器进行拦截(后面讲)</span></span><br><span class="line">       <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">               map.put(TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(TOKEN_KEY, token);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// export service</span></span><br><span class="line">       <span class="comment">// 通过该host和port访问该服务</span></span><br><span class="line">       String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">       Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">       <span class="comment">// 服务url</span></span><br><span class="line">       URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * url：http://192.168.40.17:80/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=</span></span><br><span class="line"><span class="comment">        * dubbo-demo-annotation-provider&amp;bean.name=ServiceBean:org.apache.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">        * &amp;bind.ip=192.168.40.17&amp;bind.port=80&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;</span></span><br><span class="line"><span class="comment">        * generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=285072</span></span><br><span class="line"><span class="comment">        * &amp;release=&amp;side=provider&amp;timestamp=1585206500409</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.可以通过ConfiguratorFactory，对服务url再次进行配置</span></span><br><span class="line"><span class="comment">        * 2.意思就是可以自己实现一个ConfiguratorFactory的实现类，实现对应方法对URL进行自定义修改</span></span><br><span class="line"><span class="comment">        * 3.这个实现类是通过SPI进行加载的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">               .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">           url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                   .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String scope = url.getParameter(SCOPE_KEY); <span class="comment">// scope可能为null，remote, local,none</span></span><br><span class="line">       <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">       <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">           <span class="comment">// 如果scope为none,则不会进行任何的服务导出，既不会远程，也不会本地</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">           <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">               <span class="comment">// 如果scope不是remote,则会进行本地导出，会把当前url的protocol改为injvm，然后进行导出</span></span><br><span class="line">               <span class="comment">// 这样的话就只有本地的JVM才能调用</span></span><br><span class="line">               exportLocal(url);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">           <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">               <span class="comment">// 如果scope不是local,则会进行远程导出</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                   <span class="comment">// 如果有注册中心，则将服务注册到注册中心</span></span><br><span class="line">                   <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                       <span class="comment">// 如果是injvm，则不需要进行注册中心注册</span></span><br><span class="line">                       <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 该服务是否是动态，对应zookeeper上表示是否是临时节点，对应dubbo中的功能就是静态服务</span></span><br><span class="line">                       url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 拿到监控中心地址</span></span><br><span class="line">                       URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 当前服务连接哪个监控中心</span></span><br><span class="line">                       <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 服务的register参数，如果为true，则表示要注册到注册中心</span></span><br><span class="line">                       <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                               logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                       <span class="comment">// 服务使用的动态代理机制，如果为空则使用javassit</span></span><br><span class="line">                       String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                       <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                           registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 1.生成一个当前服务接口的代理对象</span></span><br><span class="line"><span class="comment">                        * 2.使用代理生成一个Invoker，Invoker表示服务提供者的代理，可以使用Invoker的invoke方法执行服务</span></span><br><span class="line"><span class="comment">                        * 就是把注册中心的URL和服务的URL拼起来，registryURL + &quot;export&quot; + url,对应的url为:</span></span><br><span class="line"><span class="comment">                        * &lt;code&gt;</span></span><br><span class="line"><span class="comment">                        registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?</span></span><br><span class="line"><span class="comment">                        application=dubbo-demo-annotation-provider&amp;dubbo=2.0.2&amp;export=</span></span><br><span class="line"><span class="comment">                        http://192.168.40.17:80/org.apache.dubbo.demo.DemoService?</span></span><br><span class="line"><span class="comment">                        anyhost=true&amp;application=dubbo-demo-annotation-provider&amp;bean.name=</span></span><br><span class="line"><span class="comment">                        ServiceBean:org.apache.dubbo.demo.DemoService&amp;bind.ip=192.168.40.17&amp;</span></span><br><span class="line"><span class="comment">                        bind.port=80&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=</span></span><br><span class="line"><span class="comment">                        false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;</span></span><br><span class="line"><span class="comment">                        pid=19472&amp;release=&amp;side=provider&amp;timestamp=1585207994860&amp;pid=19472&amp;</span></span><br><span class="line"><span class="comment">                        registry=zookeeper&amp;timestamp=1585207994828</span></span><br><span class="line"><span class="comment">                        * &lt;code/&gt;</span></span><br><span class="line"><span class="comment">                        * 3.这个Invoker中包括了服务的实现者、服务接口类、服务的注册地址（针对当前服务的，参数export</span></span><br><span class="line"><span class="comment">                        指定了当前服务）</span></span><br><span class="line"><span class="comment">                        * 4.此invoker表示一个可执行的服务，调用invoker的invoke()方法即可执行服务,同时此invoker也可用来导出</span></span><br><span class="line"><span class="comment">                        * 在服务导出(注册)的时候，invoker只是存在某一个地方，等消费者调用服务的时候才会执行</span></span><br><span class="line"><span class="comment">                        * 5.ref就是之前讲过的服务具体实现类</span></span><br><span class="line"><span class="comment">                        * 6.这里第二个参数传的是URL(具体就是registryURL)，后面exporter马上会用</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                       <span class="comment">// invoker.invoke(Invocation)</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">// DelegateProviderMetaDataInvoker也表示服务提供者，包括了Invoker和服务的配置</span></span><br><span class="line">                       <span class="comment">//把this(也就是serviceconfig服务参数)和invoker  服务实现类等 再包装一下</span></span><br><span class="line">                       DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 使用特定的协议来对服务进行导出，这里的协议为RegistryProtocol，导出成功后得到一个Exporter</span></span><br><span class="line"><span class="comment">                        * 1.exporter导出器怎么确定用哪个实现类的export方法呢？SPI机制会判断哪个invoker里面有getURL这个方法</span></span><br><span class="line"><span class="comment">                        * 【这里不知道怎么调哪个类的哪个方法的请看前面讲的SPI】</span></span><br><span class="line"><span class="comment">                        * 2.因为前面invoker传的是registryURL，所以我们这里就会使用RegistryProtocol进行服务注册</span></span><br><span class="line"><span class="comment">                        * registryURL可以理解为注册中心的注册协议吧，debug这里，就会看到是这样的registry://127.0.0.1:2181......</span></span><br><span class="line"><span class="comment">                        * 3.注册完了之后，使用DubboProtocol进行导出</span></span><br><span class="line"><span class="comment">                        * 4.到此为止做了哪些事情？ ServiceBean.export()--&gt;刷新ServiceBean的参数--&gt;得到注册中心URL和协议URL--&gt;</span></span><br><span class="line"><span class="comment">                        * 遍历每个协议URL--&gt;组成服务URL--&gt;生成可执行服务Invoker--&gt;导出服务</span></span><br><span class="line"><span class="comment">                        * 5.这里就会调用RegistryProtocol#export(Invoker)</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                       exporters.add(exporter);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 没有配置注册中心时，也会导出服务</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                       logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                   Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                   DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                   Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                   exporters.add(exporter);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">                * ServiceData Store</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 根据服务url，讲服务的元信息存入元数据中心</span></span><br><span class="line">               MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   metadataReportService.publishProvider(url);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="启动Netty-Tomcat等Server源码"><a href="#启动Netty-Tomcat等Server源码" class="headerlink" title="启动Netty,Tomcat等Server源码"></a>启动Netty,Tomcat等Server源码</h4><h5 id="RegistryProtocol"><a href="#RegistryProtocol" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;</span><br><span class="line">      String key = getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;</span><br><span class="line">          Invoker&lt;?&gt; invokerDelegate = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(originInvoker, providerUrl);</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 1.这里又是SPI的知识。protocol属性的值是哪来的，是在SPI中注入进来的，是一个代理类</span></span><br><span class="line"><span class="comment">           * 2.InvokerDelegate的父类InvokerWrapper有getURL方法,所以最终SPI决定调哪个扩展点</span></span><br><span class="line"><span class="comment">           * 是通过providerUrl决定的，而providerUrl这里基本就是DubboProtocol或HttpProtocol去export</span></span><br><span class="line"><span class="comment">           * 3.我们这里用的是dubbo协议，所以会调用DubboProtocol</span></span><br><span class="line"><span class="comment">           * 4.为什么需要ExporterChangeableWrapper？方便注销已经被导出的服务</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 唯一标识一个服务的key</span></span><br><span class="line">       String key = serviceKey(url);</span><br><span class="line">       <span class="comment">// 构造一个Exporter进行服务导出</span></span><br><span class="line">       DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">       exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">       Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">       Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">           String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">           <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                   logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                           <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 服务的stub方法</span></span><br><span class="line">               stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 开启NettyServer</span></span><br><span class="line">       <span class="comment">// 请求---&gt;invocation---&gt;服务key---&gt;exporterMap.get(key)---&gt;exporter---&gt;invoker---&gt;invoker.invoke(invocation)--&gt;执行服务</span></span><br><span class="line">       openServer(url);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 特殊的一些序列化机制，比如kryo提供了注册机制来注册类，提高序列化和反序列化的速度</span></span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// find server.</span></span><br><span class="line">       String key = url.getAddress(); <span class="comment">// 获得ip地址和port， 192.168.40.17:20880</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// NettyClient, NettyServer</span></span><br><span class="line">       <span class="comment">//client can export a service which&#x27;s only for server to invoke</span></span><br><span class="line">       <span class="keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">           <span class="comment">// 缓存Server对象</span></span><br><span class="line">           ExchangeServer server = serverMap.get(key);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// DCL，Double Check Lock</span></span><br><span class="line">           <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   server = serverMap.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 创建Server，并进行缓存</span></span><br><span class="line">                       serverMap.put(key, createServer(url));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// server supports reset, use together with override</span></span><br><span class="line">               <span class="comment">// 服务重新导出时，就会走这里  这里会调用HeaderExchangeServer#reset</span></span><br><span class="line">               server.reset(url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="AbstractProtocol"><a href="#AbstractProtocol" class="headerlink" title="AbstractProtocol"></a>AbstractProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> String <span class="title">serviceKey</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> port = url.getParameter(Constants.BIND_PORT_KEY, url.getPort());</span><br><span class="line">     <span class="comment">// path就是@Service注解配的，path配了就用，不配就不用。这四个参数作用就是生成唯一标识一个服务的key</span></span><br><span class="line">     <span class="comment">// 从这里就可以看出，协议相同的只要端口号不一样，依然算不同的服务</span></span><br><span class="line">     <span class="keyword">return</span> serviceKey(port, url.getPath(), url.getParameter(VERSION_KEY), url.getParameter(GROUP_KEY));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h5 id="启动Server总结"><a href="#启动Server总结" class="headerlink" title="启动Server总结"></a>启动Server总结</h5><blockquote>
<p>这里不是dubbo的核心，就不贴源码了</p>
</blockquote>
<p>在服务URL中指定了协议，比如Http协议、Dubbo协议。根据不同的协议启动对应的Server。</p>
<p>比如Http协议就启动Tomcat、Jetty。</p>
<p>比如Dubbo协议就启动Netty。</p>
<p>不能只启动Server，还需要绑定一个RequestHandler，用来处理请求。</p>
<p>比如，Http协议对应的就是InternalHandler。Dubbo协议对应的就是ExchangeHandler。</p>
<p>这里来详细分析一下Dubbo协议所启动的Server。</p>
<ol>
<li> 调用DubboProtocol的openServer(URL url)方法开启启动Server</li>
<li> 调用DubboProtocol的createServer(url)方法，在createServer()方法中调用**Exchangers.bind(url, requestHandler)**得到一个ExchangeServer</li>
<li> 其中requestHandler表示请求处理器，用来处理请求</li>
<li> 在**Exchangers.bind(url, requestHandler)**中，先会根据URL得到一个Exchanger，默认为HeaderExchanger</li>
<li> HeaderExchanger中包括HeaderExchangeClient、HeaderExchangeServer</li>
<li> HeaderExchangeClient负责发送心跳，HeaderExchangeServer负责接收心跳，如果超时则会关闭channel</li>
<li> 在构造HeaderExchangeServer之前，会通过调用Transporters.<em>bind</em>(url, <strong>new</strong> DecodeHandler(<strong>new</strong> HeaderExchangeHandler(handler)))方法的到一个Server</li>
<li> 默认会使用getTransporter去bind(URL url, ChannelHandler listener)从而得到一个Servlet，此时的listener就是外部传进来的DecodeHandler</li>
<li> 在NettyTransporter的bind方法中会去<strong>new</strong> NettyServer(url, listener)，所以上面返回的Server默认就是NettyServer</li>
<li> 在构造NettyServer时，会调用ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))再构造一个ChannelHandler。</li>
<li> wrap中的handler就是上面的listener</li>
<li> 在wrap方法中会调用new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class).getAdaptiveExtension().dispatch(handler, url)));构造一个ChannelHandler。</li>
<li> 构造完ChannelHandler后，就是真正的去开启Server了，会调用AbstractServer抽象类的doOpen方法。</li>
<li> 在NettyServer中，会实现doOpen方法，会调用<strong>new</strong> NettyServerHandler(getUrl(), <strong>this</strong>)构造一个NettyServerHandler，并bind地址</li>
<li> 至此，DubboProtocol协议的启动Server流程就结束。</li>
</ol>
<ol>
<li><p> NettyServerHandler：与NettyServer直接绑定的请求处理器，负责从Netty接收到请求，channelRead()方法获取到请求，然后调用下一层的Handler（NettyServer）的received()方法将请求传递下去，此时的请求还是Object msg</p>
</li>
<li><p> NettyServer：NettyServer的父类AbstractPeer中存在received()，该方法没有做什么，直接把msg传递给下一层Handler（MultiMessageHandler）</p>
</li>
<li><p> MultiMessageHandler：此Handler会判断msg是否是一个MultiMessage，如果是，则对MultiMessage进行拆分，则把拆分出来的msg传递给下层Handler（HeartbeatHandler），如果不是，则直接把msg传递给下层Handler（HeartbeatHandler）</p>
</li>
<li><p> HeartbeatHandler：此Handler通过received()方法接收到msg，然后判断该msg是不是一个心跳请求或心跳响应，如果是心跳请求，则此Handler返回一个Response对象（很简单的一个对象），如果是心跳响应，则打印一个日志，不会有其他逻辑，如果都不是，则把msg传递给下层Handler（AllChannelHandler）。</p>
</li>
<li><p> AllChannelHandler：此Handler通过received()方法接收到msg，然后把msg封装为一个ChannelEventRunnable对象，并把ChannelEventRunnable扔到线程池中去，异步去处理该msg。在ChannelEventRunnable中会把msg交给下一个Handler（DecodeHandler）</p>
</li>
<li><p> DecodeHandler：此Handler通过received()方法接收到msg，会对msg解析decode解码，然后交给下一个Handler(HeaderExchangeHandler)</p>
</li>
<li><p>HeaderExchangeHandler：此Handler通过received()方法接收到msg，会判断msg的类型</p>
<ol>
<li> 如果Request是TwoWay，则会调用下一个Handler(DubboProtocol中的<strong>requestHandler</strong>)的reply方法得到一个结果，然后返回</li>
<li> 如果Request不是TwoWay，则会调用下一个Handler(DubboProtocol中的<strong>requestHandler</strong>)的received方法处理该请求，不会返回结果</li>
</ol>
</li>
<li><p> requestHandler：此Handler是真正的处理请求逻辑，在received()方法中，如果msg是Invocation，则会调用reply方法，但不会返回reply方法所返回的结果，在reply方法中把msg强制转换为Invocation类型 inv，然后根据inv得到对应的服务Invoker，然后调用invoke(inv)方法，得到结果。</p>
</li>
</ol>
<h4 id="服务注册源码"><a href="#服务注册源码" class="headerlink" title="服务注册源码"></a>服务注册源码</h4><h5 id="RegistryProtocol-1"><a href="#RegistryProtocol-1" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 这里最终也是通过SPI机制，判断传过来的是什么，我们这里在前面把registry转成了zookeeper的URL</span></span><br><span class="line">       Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">       <span class="comment">// 所以这里会调用ZookeeperRegistry的register方法，实际上是先调用ZookeeperRegistry的父类FailbackRegistry</span></span><br><span class="line">       registry.register(registeredProviderUrl);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>







<h5 id="FailbackRegistry-java"><a href="#FailbackRegistry-java" class="headerlink" title="FailbackRegistry.java"></a>FailbackRegistry.java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.register(url);</span><br><span class="line">       removeFailedRegistered(url);</span><br><span class="line">       removeFailedUnregistered(url);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 然后在这里调用ZookeeperRegistry#doRegister,这个URL参数很明显又是一个SPI的提现</span></span><br><span class="line">           doRegister(url);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Throwable t = e;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">           <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                   &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                   &amp;&amp; !CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">           <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">           <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">               <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                   t = t.getCause();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + getUrl().getAddress() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.error(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">           addFailedRegistered(url);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务监听器原理"><a href="#服务监听器原理" class="headerlink" title="服务监听器原理"></a>服务监听器原理</h3><blockquote>
<p>动态配置不能改端口</p>
</blockquote>
<h4 id="服务监听器原理总结"><a href="#服务监听器原理总结" class="headerlink" title="服务监听器原理总结"></a>服务监听器原理总结</h4><ol>
<li><p>服务在导出的过程中需要向动态配置中心的数据进行订阅，以便当管理人员修改了动态配置中心中对应服务的参数后，服务提供者能及时做出变化。此功能涉及到版本兼容，因为在Dubbo2.7之前也存在此功能，Dubbo2.7开始对此功能进行了调整。</p>
</li>
<li><p>在Dubbo2.7之前，仅支持多某个服务的动态配置</p>
</li>
<li><p>在Dubbo2.7之后，不仅支持对单个服务的动态配置，也支持对某个应用的动态配置（相当于对这个应用下的所有服务生效）</p>
</li>
<li><p>为了达到这个功能，需要利用Zookeeper的Watcher机制，所以对于服务提供者而言，我到底监听哪个Zookeeper节点的数据变化呢？</p>
</li>
<li><p>这个节点是有规则的，并且在Dubbo2.7前后也不一样：</p>
<ol>
<li>Dubbo2.7之前：监听的zk路径是：<code>/dubbo/org.apache.dubbo.demo.DemoService/configurators/override://0.0.0.0/org.apache.dubbo.demo.DemoService?category=configurators&amp;compatible_config=true&amp;dynamic=false&amp;enabled=true&amp;timeout=6000</code>注意，注意监听的是节点名字的变化，而不是节点内容</li>
<li>Dubbo2.7之后，监听的zk路径是：<ol>
<li>服务： <code>/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService.configurators</code>节点的内容</li>
<li>应用： <code>/dubbo/config/dubbo/dubbo-demo-provider-application.configurators</code>节点的内容</li>
</ol>
</li>
</ol>
</li>
<li><p>注意，要和配置中心的路径区分开来，配置中心的路径是：</p>
<ol>
<li>应用：/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService/dubbo.properties节点的内容</li>
<li>全局：/dubbo/config/dubbo/dubbo.properties节点的内容</li>
</ol>
</li>
</ol>
<blockquote>
<p>所以在一个服务进行导出时，需要在服务提供者端给当前服务生成一个对应的监听器实例，这个监听器实例为OverrideListener，它负责监听对应服务的动态配置变化，并且根据动态配置中心的参数重写服务URL。</p>
</blockquote>
<p>除开有OverrideListener之外，在Dubbo2.7之后增加了另外两个：</p>
<ol>
<li> ProviderConfigurationListener：监听的是应用的动态配置数据修改，所以它是在RegistryProtocol类中的一个属性，并且是随着RegistryProtocol实例化而实例化好的，一个应用中只有一个</li>
<li> ServiceConfigurationListener：监听的是服务的动态配置数据修改，和OverrideListener类似，也是对应一个服务的，所以在每个服务进行导出时都会生成一个，实际上ServiceConfigurationListener的内部有一个属性就是OverrideListener，所以当ServiceConfigurationListener监听数据发生了变化时，就会把配置中心的最新数据交给OverrideListener去重写服务URL。</li>
<li> 同时在RegistryProtocol类中保存了所有服务所对应的OverrideListener，所以实际上当ProviderConfigurationListener监听到数据发生了变化时，也会把它所得到的最新数据依次调用每个OverrideListener去重写服务对应的服务URL。</li>
<li> ProviderConfigurationListener会监听/dubbo/config/dubbo/dubbo-demo-provider-application.configurators节点</li>
<li>ServiceConfigurationListener会监听/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService.configurators节点</li>
</ol>
<p><strong>整理修改动态配置触发流程：</strong></p>
<ol>
<li><p>修改服务动态配置，底层会修改Zookeeper中的数据，</p>
<ol>
<li> /dubbo/config/dubbo/org.apache.dubbo.demo.DemoService.configurators节点的内容</li>
</ol>
</li>
<li><p> ServiceConfigurationListener会监听到节点内容的变化，会触发ServiceConfigurationListener的父类AbstractConfiguratorListener的process(ConfigChangeEvent event)方法</p>
</li>
<li><p>ConfigChangeEvent表示一个事件，事件中有事件类型，还有事件内容（节点内容），还有触发这个事件的节点名字，事件类型有三个：</p>
<ol>
<li> ADDED</li>
<li> MODIFIED</li>
<li> DELETED</li>
</ol>
</li>
<li><p>当接收到一个ConfigChangeEvent事件后，会根据事件类型做对应的处理</p>
<ol>
<li> ADDED、MODIFIED：会根据节点内容去生成override://协议的URL，然后根据URL去生成Configurator， Configurator对象很重要，表示一个配置器，根据配置器可以去重写URL</li>
<li> DELETED：删除ServiceConfigurationListener内的所有的Configurator</li>
</ol>
</li>
<li><p> 生成了Configurator后，调用notifyOverrides()方法对服务URL进行重写</p>
</li>
<li><p>注意，每次重写并不仅仅只是用到上面所生成的Configurator，每次重写要用到所有的Configurator，包括本服务的Configurator，也包括本应用的Configurator，也包括老版本管理台的Configurator，重写URL的逻辑如下：</p>
<ol>
<li><p> 从exporter中获取目前已经导出了的服务URL-currentUrl</p>
</li>
<li><p> 根据老版本管理台的Configurator重写服务URL</p>
</li>
<li><p> 根据providerConfigurationListener中的Configurator重写服务URL</p>
</li>
<li><p> 根据serviceConfigurationListeners中对应的服务的Configurator重写服务URL</p>
</li>
<li><p> 如果重写之后newUrl和currentUrl相等，那么不需要做什么了</p>
</li>
<li><p>如果重写之后newUrl和currentUrl不相等，则需要进行<strong>服务重新导出</strong>：</p>
<ol>
<li> 根据newUrl进行导出，注意，这里只是就是调用DubboProtocol的export，再次去启动NettyServer</li>
<li> 对newUrl进行简化，简化为registeredProviderUrl</li>
<li> 调用RegistryProtocol的unregister()方法，把当前服务之前的服务提供URL从注册中心删掉</li>
<li> 调用RegistryProtocol的register()方法，把新的registeredProviderUrl注册到注册中心</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="服务监听器绑定源码"><a href="#服务监听器绑定源码" class="headerlink" title="服务监听器绑定源码"></a>服务监听器绑定源码</h4><h5 id="RegistryProtocol-2"><a href="#RegistryProtocol-2" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 导出服务</span></span><br><span class="line">       <span class="comment">// registry://   ---&gt; RegistryProtocol</span></span><br><span class="line">       <span class="comment">// zookeeper://  ---&gt; ZookeeperRegistry</span></span><br><span class="line">       <span class="comment">// dubbo://      ---&gt; DubboProtocol</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1.registry://xxx?xx=xx&amp;registry=zookeeper ---&gt; zookeeper://xxx?xx=xx     表示注册中心</span></span><br><span class="line"><span class="comment">        * 这里就是把registry替换成zookeeper</span></span><br><span class="line"><span class="comment">        * 2.示例：zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=</span></span><br><span class="line"><span class="comment">        * dubbo-demo-provider-application&amp;dubbo=2.0.2&amp;export=dubbo://192.168.40.17:20880/</span></span><br><span class="line"><span class="comment">        * org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=</span></span><br><span class="line"><span class="comment">        * dubbo-demo-provider-application&amp;bean.name=ServiceBean:org.apache.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">        * &amp;bind.ip=192.168.40.17&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;</span></span><br><span class="line"><span class="comment">        * dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;</span></span><br><span class="line"><span class="comment">        * logger=log4j&amp;methods=sayHello&amp;pid=27656&amp;release=2.7.0&amp;side=provider&amp;timeout=3000&amp;</span></span><br><span class="line"><span class="comment">        * timestamp=1590735956489&amp;logger=log4j&amp;pid=27656&amp;release=2.7.0&amp;timestamp=1590735956479</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="comment">// 得到服务提供者url，表示服务提供者</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1.这里就是把之前export后面拼的dubbo服务url拿出来</span></span><br><span class="line"><span class="comment">        * 2.示例：dubbo://192.168.40.17:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=</span></span><br><span class="line"><span class="comment">        * dubbo-demo-provider-application&amp;bean.name=ServiceBean:org.apache.dubbo.demo.DemoService&amp;</span></span><br><span class="line"><span class="comment">        * bind.ip=192.168.40.17&amp;bind.port=20880&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;</span></span><br><span class="line"><span class="comment">        * generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;logger=log4j&amp;methods=sayHello</span></span><br><span class="line"><span class="comment">        * &amp;pid=27656&amp;release=2.7.0&amp;side=provider&amp;timeout=3000&amp;timestamp=1590735956489</span></span><br><span class="line"><span class="comment">        * 3.服务导出最终的目的就是要把providerUrl存到注册中心上，只不过中间有一些其他操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Subscribe the override data</span></span><br><span class="line">       <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">       <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">       <span class="comment">//  subscription information to cover.</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// overrideSubscribeUrl是老版本的动态配置监听url，表示了需要监听的服务以及监听的类型（configurators， 这是老版本上的动态配置）</span></span><br><span class="line">       <span class="comment">// 在服务提供者url的基础上，生成一个overrideSubscribeUrl，协议为provider://，增加参数category=configurators&amp;check=false</span></span><br><span class="line">       <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 一个overrideSubscribeUrl对应一个OverrideListener，用来监听变化事件，监听到overrideSubscribeUrl的变化后，</span></span><br><span class="line">       <span class="comment">// OverrideListener就会根据变化进行相应处理，具体处理逻辑看OverrideListener的实现</span></span><br><span class="line">       <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">       overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 在这个方法里会利用providerConfigurationListener和serviceConfigurationListener去重写providerUrl</span></span><br><span class="line"><span class="comment">        * providerConfigurationListener表示应用级别的动态配置监听器，providerConfigurationListener是RegistyProtocol的一个属性</span></span><br><span class="line"><span class="comment">        * serviceConfigurationListener表示服务级别的动态配置监听器，serviceConfigurationListener是在每暴露一个服务时就会生成一个</span></span><br><span class="line"><span class="comment">        * 这两个监听器都是新版本中的监听器</span></span><br><span class="line"><span class="comment">        * 新版本监听的zk路径是：</span></span><br><span class="line"><span class="comment">        * 服务： /dubbo/config/dubbo/org.apache.dubbo.demo.DemoService.configurators节点的内容</span></span><br><span class="line"><span class="comment">        * 应用： /dubbo/config/dubbo/dubbo-demo-provider-application.configurators节点的内容</span></span><br><span class="line"><span class="comment">        * 注意，要和配置中心的路径区分开来，配置中心的路径是：</span></span><br><span class="line"><span class="comment">        * 应用：/dubbo/config/dubbo/org.apache.dubbo.demo.DemoService/dubbo.properties节点的内容</span></span><br><span class="line"><span class="comment">        * 全局：/dubbo/config/dubbo/dubbo.properties节点的内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// export invoker</span></span><br><span class="line">       <span class="comment">// 根据动态配置重写了providerUrl之后，就会调用DubboProtocol或HttpProtocol去进行导出服务了,</span></span><br><span class="line">       <span class="comment">// 这里会启动netty，启动tomcat这些</span></span><br><span class="line">       <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// url to registry</span></span><br><span class="line">       <span class="comment">// 得到注册中心-ZookeeperRegistry</span></span><br><span class="line">       <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 得到存入到注册中心去的providerUrl,会对服务提供者url中的参数进行简化，</span></span><br><span class="line">       <span class="comment">// 因为有些参数存到注册中心是没有用的</span></span><br><span class="line">       <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将当前服务提供者Invoker，以及该服务对应的注册中心地址，以及简化后的服务url存入ProviderConsumerRegTable</span></span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">               registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">       <span class="comment">//是否需要注册到注册中心</span></span><br><span class="line">       <span class="keyword">boolean</span> register = providerUrl.getParameter(REGISTER_KEY, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (register) &#123;</span><br><span class="line">           <span class="comment">// 注册服务，把简化后的服务提供者url注册到registryUrl中去</span></span><br><span class="line">           register(registryUrl, registeredProviderUrl);</span><br><span class="line">           providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 针对老版本的动态配置，需要把overrideSubscribeListener绑定到overrideSubscribeUrl上去进行监听</span></span><br><span class="line"><span class="comment">        * 兼容老版本的配置修改，利用overrideSubscribeListener去监听旧版本的动态配置变化</span></span><br><span class="line"><span class="comment">        * 监听overrideSubscribeUrl   provider://192.168.40.17:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;</span></span><br><span class="line"><span class="comment">        * application=dubbo-demo-annotation-provider&amp;bean.name=ServiceBean:org.apache.dubbo.demo.DemoService&amp;</span></span><br><span class="line"><span class="comment">        * bind.ip=192.168.40.17&amp;bind.port=20880&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;</span></span><br><span class="line"><span class="comment">        * dynamic=true&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=416332&amp;</span></span><br><span class="line"><span class="comment">        * release=&amp;side=provider&amp;timestamp=1585318241955</span></span><br><span class="line"><span class="comment">        * 那么新版本的providerConfigurationListener和serviceConfigurationListener是在什么时候进行订阅的呢？在这两个类构造的时候</span></span><br><span class="line"><span class="comment">        * Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line"><span class="comment">        * 老版本监听的zk路径是：/dubbo/org.apache.dubbo.demo.DemoService/configurators/override://0.0.0.0/org.apache.dubbo.demo.DemoService?category=configurators&amp;compatible_config=true&amp;dynamic=false&amp;enabled=true&amp;timeout=6000</span></span><br><span class="line"><span class="comment">        * 监听的是路径的内容，不是节点的内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">       exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">       <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> URL <span class="title">overrideUrlWithConfig</span><span class="params">(URL providerUrl, OverrideListener listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1.应用配置，providerConfigurationListener是在属性那里直接初始化好的，</span></span><br><span class="line"><span class="comment">        *  providerConfigurationListener会监听配置中心的应用配置信息变动</span></span><br><span class="line"><span class="comment">        * 这个是每一个应用只有一个providerConfigurationListener</span></span><br><span class="line"><span class="comment">        * 2.首先这里流程是：</span></span><br><span class="line"><span class="comment">        *   1.ProviderConfigurationListener通过构造函数调用父类AbstractConfiguratorListener</span></span><br><span class="line"><span class="comment">        *   #initWith方法</span></span><br><span class="line"><span class="comment">        *   2.在initWith方法中通过传进来的路径key,监听注册中心(常用的是zookeeper)</span></span><br><span class="line"><span class="comment">        *   key路径下的节点，会先从注册中心拿到当前配置然后转换成configurators</span></span><br><span class="line"><span class="comment">        * 3.接着这里调用overrideUrl，用前面的configurators生成新的providerUrl</span></span><br><span class="line"><span class="comment">        * 4.这里因为之前的providerUrl是经过<span class="doctag">@Service</span>注解,配置中心文件(yml或properties)</span></span><br><span class="line"><span class="comment">        * 还有-D这种启动参数里的配置，组合成的一个URL。但是这个providerUrl还没有经过</span></span><br><span class="line"><span class="comment">        * 网页端的动态配置，所以这里需要重写下URL</span></span><br><span class="line"><span class="comment">        * 5.ServiceConfigurationListener同理，而且ServiceConfigurationListener代码顺序在后面</span></span><br><span class="line"><span class="comment">        * 所以很明显&#x27;服务配置&#x27;会覆盖&#x27;应用配置&#x27;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       providerUrl = providerConfigurationListener.overrideUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 服务配置，new ServiceConfigurationListener的时候回初始化，ServiceConfigurationListener会监听配置中心的服务信息配置信息变动</span></span><br><span class="line">       <span class="comment">// 这个是每个服务都会重新new一个ServiceConfigurationListener</span></span><br><span class="line">       ServiceConfigurationListener serviceConfigurationListener = <span class="keyword">new</span> ServiceConfigurationListener(providerUrl, listener);</span><br><span class="line">       serviceConfigurationListeners.put(providerUrl.getServiceKey(), serviceConfigurationListener);</span><br><span class="line">       <span class="keyword">return</span> serviceConfigurationListener.overrideUrl(providerUrl);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RegistryProtocol内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProviderConfigurationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//订阅 应用名+&quot;.configurators&quot;  这里就是新版本ProviderConfigurationListener的监听路径</span></span><br><span class="line">           <span class="keyword">this</span>.initWith(ApplicationModel.getApplication() + CONFIGURATORS_SUFFIX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="AbstractConfiguratorListener"><a href="#AbstractConfiguratorListener" class="headerlink" title="AbstractConfiguratorListener"></a>AbstractConfiguratorListener</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 在构造ProviderConfigurationListener和ServiceConfigurationListener都会调用到这个方法</span></span><br><span class="line">   <span class="comment">// 完成Listener自身订阅到对应的应用和服务</span></span><br><span class="line">   <span class="comment">// 订阅关系绑定完了之后，主动从动态配置中心获取一下对应的配置数据生成configurators，后面需要重写providerUrl</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initWith</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这里拿到的就是注册中心，我们大部分情况用的是zookeeper</span></span><br><span class="line">       DynamicConfiguration dynamicConfiguration = DynamicConfiguration.getDynamicConfiguration();</span><br><span class="line">       <span class="comment">// 添加Listener,进行了订阅</span></span><br><span class="line">       dynamicConfiguration.addListener(key, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从配置中心ConfigCenter获取属于当前应用的动态配置数据，从zk中拿到原始数据(主动从配置中心获取数据)</span></span><br><span class="line">       String rawConfig = dynamicConfiguration.getRule(key, DynamicConfiguration.DEFAULT_GROUP);</span><br><span class="line">       <span class="comment">// 如果存在应用配置信息则根据配置信息生成Configurator</span></span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.isEmpty(rawConfig)) &#123;</span><br><span class="line">           genConfiguratorsFromRawRule(rawConfig);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">genConfiguratorsFromRawRule</span><span class="params">(String rawConfig)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> parseSuccess = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// parseConfigurators will recognize app/service config automatically.</span></span><br><span class="line">           <span class="comment">// 先把应用或服务配置转成url，再根据url生成对应的Configurator</span></span><br><span class="line">           configurators = Configurator.toConfigurators(ConfigParser.parseConfigurators(rawConfig))</span><br><span class="line">                   .orElse(configurators);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.error(<span class="string">&quot;Failed to parse raw dynamic config and it will not take effect, the raw config is: &quot;</span> +</span><br><span class="line">                   rawConfig, e);</span><br><span class="line">           parseSuccess = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> parseSuccess;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h4 id="服务监听器监听源码"><a href="#服务监听器监听源码" class="headerlink" title="服务监听器监听源码"></a>服务监听器监听源码</h4><h5 id="RegistryProtocol-3"><a href="#RegistryProtocol-3" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfigurationListener</span> <span class="keyword">extends</span> <span class="title">AbstractConfiguratorListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ProviderConfigurationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//订阅 应用名+&quot;.configurators&quot;  这里就是新版本ProviderConfigurationListener的监听路径</span></span><br><span class="line">           <span class="keyword">this</span>.initWith(ApplicationModel.getApplication() + CONFIGURATORS_SUFFIX);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Get existing configuration rule and override provider url before exporting.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> providerUrl</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> &lt;T&gt; <span class="function">URL <span class="title">overrideUrl</span><span class="params">(URL providerUrl)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 通过configurators去修改/装配providerUrl</span></span><br><span class="line">           <span class="keyword">return</span> RegistryProtocol.getConfigedInvokerUrl(configurators, providerUrl);</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyOverrides</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           overrideListeners.values().forEach(listener -&gt; ((OverrideListener) listener).doOverrideIfNecessary());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfigurationListener</span> <span class="keyword">extends</span> <span class="title">AbstractConfiguratorListener</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> URL providerUrl;</span><br><span class="line">       <span class="keyword">private</span> OverrideListener notifyListener;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfigurationListener</span><span class="params">(URL providerUrl, OverrideListener notifyListener)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.providerUrl = providerUrl;</span><br><span class="line">           <span class="keyword">this</span>.notifyListener = notifyListener;</span><br><span class="line">           <span class="comment">// 订阅 服务接口名+group+version+&quot;.configurators&quot;</span></span><br><span class="line">           <span class="keyword">this</span>.initWith(DynamicConfiguration.getRuleKey(providerUrl) + CONFIGURATORS_SUFFIX);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> &lt;T&gt; <span class="function">URL <span class="title">overrideUrl</span><span class="params">(URL providerUrl)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> RegistryProtocol.getConfigedInvokerUrl(configurators, providerUrl);</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//这里是监听入口</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyOverrides</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           notifyListener.doOverrideIfNecessary();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOverrideIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">           <span class="keyword">if</span> (originInvoker <span class="keyword">instanceof</span> InvokerDelegate) &#123;</span><br><span class="line">               invoker = ((InvokerDelegate&lt;?&gt;) originInvoker).getInvoker();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               invoker = originInvoker;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//The origin invoker 当前服务的原始服务提供者url，没有经过任何动态配置改变的URL</span></span><br><span class="line">           URL originUrl = RegistryProtocol.<span class="keyword">this</span>.getProviderUrl(invoker);</span><br><span class="line">           String key = getCacheKey(originInvoker);</span><br><span class="line"></span><br><span class="line">           ExporterChangeableWrapper&lt;?&gt; exporter = bounds.get(key);</span><br><span class="line">           <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">               logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;error state, exporter should not be null&quot;</span>));</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//The current, may have been merged many times，事件触发之前，当前服务被导出的url</span></span><br><span class="line">           URL currentUrl = exporter.getInvoker().getUrl();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//根据configurators修改url，configurators是全量的，并不是某个新增的或删除的，</span></span><br><span class="line">           <span class="comment">// 所以是基于原始的url进行修改，并不是基于currentUrl，这里是老版本的configurators</span></span><br><span class="line">           <span class="comment">//Merged with this configuration</span></span><br><span class="line">           URL newUrl = getConfigedInvokerUrl(configurators, originUrl);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 这是新版本的configurators</span></span><br><span class="line">           newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);</span><br><span class="line">           newUrl = getConfigedInvokerUrl(serviceConfigurationListeners.get(originUrl.getServiceKey())</span><br><span class="line">                   .getConfigurators(), newUrl);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 修改过的url如果和目前的url不相同，则重新按newUrl导出</span></span><br><span class="line">           <span class="keyword">if</span> (!currentUrl.equals(newUrl)) &#123;</span><br><span class="line">               RegistryProtocol.<span class="keyword">this</span>.reExport(originInvoker, newUrl);</span><br><span class="line">               logger.info(<span class="string">&quot;exported provider url changed, origin url: &quot;</span> + originUrl +</span><br><span class="line">                       <span class="string">&quot;, old export url: &quot;</span> + currentUrl + <span class="string">&quot;, new export url: &quot;</span> + newUrl);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">reExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL newInvokerUrl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 根据newInvokerUrl进行导出</span></span><br><span class="line">       <span class="comment">// update local exporter</span></span><br><span class="line">       ExporterChangeableWrapper exporter = doChangeLocalExport(originInvoker, newInvokerUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取准确的ProviderUrl</span></span><br><span class="line">       <span class="comment">// update registry</span></span><br><span class="line">       URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">       <span class="comment">// 对于一个服务提供者url，在注册到注册中心时，会先进行简化</span></span><br><span class="line">       <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(newInvokerUrl, registryUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//decide if we need to re-publish</span></span><br><span class="line">       <span class="comment">// 根据getServiceKey获取ProviderInvokerWrapper</span></span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.getProviderWrapper(registeredProviderUrl, originInvoker);</span><br><span class="line">       <span class="comment">// 生成一个新的ProviderInvokerWrapper</span></span><br><span class="line">       ProviderInvokerWrapper&lt;T&gt; newProviderInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Only if the new url going to Registry is different with the previous one should we do unregister and register.</span></span><br><span class="line"><span class="comment">        * 如果新的服务提供者url简化后的url和这个服务之前的服务提供者url简化后的url不相等，则需要把新的简化后的服务提供者url注册到注册中心去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (providerInvokerWrapper.isReg() &amp;&amp; !registeredProviderUrl.equals(providerInvokerWrapper.getProviderUrl())) &#123;</span><br><span class="line">           unregister(registryUrl, providerInvokerWrapper.getProviderUrl());</span><br><span class="line">           register(registryUrl, registeredProviderUrl);</span><br><span class="line">           newProviderInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper <span class="title">doChangeLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL newInvokerUrl)</span> </span>&#123;</span><br><span class="line">       String key = getCacheKey(originInvoker);</span><br><span class="line">       <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">       <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">           logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;error state, exporter should not be null&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 到这里才能真正明白，为什么需要InvokerDelegate</span></span><br><span class="line">           <span class="comment">// InvokerDelegate表示一个调用者，由invoker+url构成，invoker不变，url可变</span></span><br><span class="line">           <span class="keyword">final</span> Invoker&lt;T&gt; invokerDelegate = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(originInvoker, newInvokerUrl);</span><br><span class="line">           <span class="comment">// 这里最后又会走到DubboProtocol#export 那里的逻辑,服务重新导出前面见过了</span></span><br><span class="line">           exporter.setExporter(protocol.export(invokerDelegate));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Q:这里引出一个问题，配置改变之后Netty，tomcat需要重启吗？</p>
<p>A:不需要，为什么？前面的DubboProtocol#export 那里的reset逻辑讲过</p>
<h4 id="服务重新导出源码"><a href="#服务重新导出源码" class="headerlink" title="服务重新导出源码"></a>服务重新导出源码</h4><h5 id="DubboProtocol-1"><a href="#DubboProtocol-1" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="comment">// ....省略</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 开启NettyServer</span></span><br><span class="line">       <span class="comment">// 请求---&gt;invocation---&gt;服务key---&gt;exporterMap.get(key)---&gt;exporter---&gt;invoker---&gt;invoker.invoke(invocation)--&gt;执行服务</span></span><br><span class="line">       openServer(url);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 特殊的一些序列化机制，比如kryo提供了注册机制来注册类，提高序列化和反序列化的速度</span></span><br><span class="line">       optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> exporter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// find server.</span></span><br><span class="line">       String key = url.getAddress(); <span class="comment">// 获得ip地址和port， 192.168.40.17:20880</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// NettyClient, NettyServer</span></span><br><span class="line">       <span class="comment">//client can export a service which&#x27;s only for server to invoke</span></span><br><span class="line">       <span class="keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">           <span class="comment">// 缓存Server对象</span></span><br><span class="line">           ExchangeServer server = serverMap.get(key);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// DCL，Double Check Lock</span></span><br><span class="line">           <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                   server = serverMap.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 创建Server，并进行缓存</span></span><br><span class="line">                       serverMap.put(key, createServer(url));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// server supports reset, use together with override</span></span><br><span class="line">               <span class="comment">// 服务重新导出时，就会走这里  这里会调用HeaderExchangeServer#reset</span></span><br><span class="line">               server.reset(url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="HeaderExchangeServer"><a href="#HeaderExchangeServer" class="headerlink" title="HeaderExchangeServer"></a>HeaderExchangeServer</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//启动netty的时候会调用这个</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">       Assert.notNull(server, <span class="string">&quot;server == null&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.server = server;</span><br><span class="line">       <span class="comment">// 启动定义关闭Channel(socket)的Task</span></span><br><span class="line">       startIdleCheckTask(getUrl());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startIdleCheckTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!server.canHandleIdle()) &#123; <span class="comment">// 底层NettyServer自己有心跳机制，那么上层的ExchangeServer就不用开启心跳任务了</span></span><br><span class="line">           AbstractTimerTask.ChannelProvider cp = () -&gt; unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line">           <span class="keyword">long</span> idleTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 定义关闭Channel的Task</span></span><br><span class="line">           CloseTimerTask closeTimerTask = <span class="keyword">new</span> CloseTimerTask(cp, idleTimeoutTick, idleTimeout);</span><br><span class="line">           <span class="keyword">this</span>.closeTimerTask = closeTimerTask;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// init task and start timer.</span></span><br><span class="line">           <span class="comment">// 定时运行closeTimerTask</span></span><br><span class="line">           IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       server.reset(url);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> currHeartbeat = getHeartbeat(getUrl());</span><br><span class="line">           <span class="keyword">int</span> currIdleTimeout = getIdleTimeout(getUrl());</span><br><span class="line">           <span class="keyword">int</span> heartbeat = getHeartbeat(url);</span><br><span class="line">           <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 1.动态改配置，重新导出服务时不需要重新启动netty,tomcat等等</span></span><br><span class="line"><span class="comment">            * 2.这里直接关闭那个服务的channel任务，然后根据新的url重启一个任务就行了</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (currHeartbeat != heartbeat || currIdleTimeout != idleTimeout) &#123;</span><br><span class="line">               cancelCloseTask();</span><br><span class="line">               startIdleCheckTask(url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.error(t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="CloseTimerTask"><a href="#CloseTimerTask" class="headerlink" title="CloseTimerTask"></a>CloseTimerTask</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Long lastRead = lastRead(channel);</span><br><span class="line">        Long lastWrite = lastWrite(channel);</span><br><span class="line">        Long now = now();</span><br><span class="line">        <span class="comment">// check ping &amp; pong at server</span></span><br><span class="line">        <span class="comment">// 表示Server端有多长时间没有读到过数据或写出过数据了，说白就是超时了</span></span><br><span class="line">        <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; idleTimeout)</span><br><span class="line">                || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; idleTimeout)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Close channel &quot;</span> + channel + <span class="string">&quot;, because idleCheck timeout: &quot;</span></span><br><span class="line">                    + idleTimeout + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception when close remote channel &quot;</span> + channel.getRemoteAddress(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务导出源码流程总结"><a href="#服务导出源码流程总结" class="headerlink" title="服务导出源码流程总结"></a>服务导出源码流程总结</h3><ol>
<li><p> ServiceBean.export()方法是导出的入口方法，会执行ServiceConfig.export()方法完成服务导出，导出完了之后会发布一个Spring事件ServiceBeanExportedEvent</p>
</li>
<li><p> 在ServiceConfig.export()方法中会先调用checkAndUpdateSubConfigs()，这个方法主要完成AbstractConfig的参数刷新(从配置中心获取参数等等)，AbstractConfig是指ApplicationConfig、ProtocolConfig、ServiceConfig等等，刷新完后会检查stub、local、mock等参数是否配置正确</p>
</li>
<li><p> 参数刷新和检查完成了之后，就会开始导出服务，如果配置了延迟导出，那么则按指定的时间利用ScheduledExecutorService来进行延迟导出</p>
</li>
<li><p> 否则调用doExport()进行服务导出</p>
</li>
<li><p> 继续调用doExportUrls()进行服务导出</p>
</li>
<li><p> 首先通过loadRegistries()方法获得所配置的注册中心的URL，可能配了多个配置中心，那么当前所导出的服务需要注册到每个配置中心去，这里，注册中心的是以URL的方式来表示的，使用的是什么注册中心、注册中心的地址和端口，给注册中心所配置的参数等等，都会存在在URL上，此URL以**registry://**开始</p>
</li>
<li><p> 获得到注册中心的registryURLs之后，就会遍历当前服务所有的ProtocolConfig，调用doExportUrlsFor1Protocol(protocolConfig, registryURLs);方法把当前服务按每个协议每个注册中心分别进行导出</p>
</li>
<li><p>在doExportUrlsFor1Protocol()方法中，会先构造一个服务URL，包括</p>
<ol>
<li> 服务的协议dubbo://,</li>
<li> 服务的IP和PORT，如果指定了就取指定的，没有指定IP就获取服务器上网卡的IP，</li>
<li> 以及服务的PATH，如果没有指定PATH参数，则取接口名</li>
<li> 以及服务的参数，参数包括服务的参数，服务中某个方法的参数</li>
<li> 最终得到的URL类似： dubbo://192.168.1.110:20880/cn.imlql.DemoService?timeout=3000&amp;&amp;sayHello.loadbalance=random</li>
</ol>
</li>
<li><p> 得到服务的URL之后，会把服务URL作为一个参数添加到registryURL中去，然后把registryURL、服务的接口、当前服务实现类ref生成一个Invoker代理对象，再把这个代理对象和当前ServiceConfig对象包装成一个DelegateProviderMetaDataInvoker对象，DelegateProviderMetaDataInvoker就表示了完整的一个服务</p>
</li>
<li><p> 接下来就会使用Protocol去export导出服务了，导出之后将得到一个Exporter对象（该Exporter对象，可以理解为主要可以用来卸载（unexport）服务，什么时候会卸载服务？在优雅关闭Dubbo应用的时候）</p>
</li>
<li><p> 接下来我们来详细看看Protocol是怎么导出服务的？</p>
</li>
<li><p> 但调用<strong>protocol</strong>.export(wrapperInvoker)方法时，因为protocol是Protocol接口的一个Adaptive对象，所以此时会根据wrapperInvoker的genUrl方法得到一个url，根据此url的协议找到对应的扩展点，此时扩展点就是RegistryProtocol，但是，因为Protocol接口有两个包装类，一个是ProtocolFilterWrapper、ProtocolListenerWrapper，所以实际上在调用export方法时，会经过这两个包装类的export方法，但是在这两个包装类的export方法中都会Registry协议进行了判断，不会做过多处理，所以最终会直接调用到RegistryProtocol的export(Invoker&lt;T&gt; originInvoker)方法</p>
</li>
<li><p>在RegistryProtocol的export(Invoker&lt;T&gt; originInvoker)方法中，主要完成了以下几件事情：</p>
<ol>
<li><p> 生成监听器，监听动态配置中心此服务的参数数据的变化，一旦监听到变化，则重写服务URL，并且在服务导出时先重写一次服务URL</p>
</li>
<li><p>拿到重写之后的URL之后，调用doLocalExport()进行服务导出，在这个方法中就会调用DubboProtocol的export方法去导出服务了，导出成功后将得到一个ExporterChangeableWrapper</p>
<ol>
<li> 在DubboProtocol的export方法中主要要做的事情就是启动NettyServer，并且设置一系列的RequestHandler，以便在接收到请求时能依次被这些RequestHandler所处理</li>
<li> 这些RequestHandler在上文已经整理过了</li>
</ol>
</li>
<li><p> 从originInvoker中获取注册中心的实现类，比如ZookeeperRegistry</p>
</li>
<li><p> 将重写后的服务URL进行简化，把不用存到注册中心去的参数去除</p>
</li>
<li><p> 把简化后的服务URL调用ZookeeperRegistry.registry()方法注册到注册中心去</p>
</li>
<li><p> 最后将ExporterChangeableWrapper封装为DestroyableExporter对象返回，完成服务导出</p>
</li>
</ol>
</li>
</ol>
<h3 id="Exporter架构"><a href="#Exporter架构" class="headerlink" title="Exporter架构"></a>Exporter架构</h3><p>一个服务导出成功后，会生成对应的Exporter：</p>
<ol>
<li> DestroyableExporter：Exporter的最外层包装类，这个类的主要作用是可以用来unexporter对应的服务</li>
<li> ExporterChangeableWrapper：这个类主要负责在unexport对应服务之前，把服务URL从注册中心中移除，把该服务对应的动态配置监听器移除</li>
<li> ListenerExporterWrapper：这个类主要负责在unexport对应服务之后，把服务导出监听器移除</li>
<li>DubboExporter：这个类中保存了对应服务的Invoker对象，和当前服务的唯一标志，当NettyServer接收到请求后，会根据请求中的服务信息，找到服务对应的DubboExporter对象，然后从对象中得到Invoker对象</li>
</ol>
<h3 id="服务端Invoker架构"><a href="#服务端Invoker架构" class="headerlink" title="服务端Invoker架构"></a>服务端Invoker架构</h3><ol>
<li> ProtocolFilterWrapper$CallbackRegistrationInvoker：会去调用下层Invoker，下层Invoker执行完了之后，会遍历过滤器，查看是否有过滤器实现了ListenableFilter接口，如果有，则回调对应的onResponse方法，比如TimeoutFilter，当调用完下层Invoker之后，就会计算服务的执行时间</li>
<li> ProtocolFilterWrapper$1：ProtocolFilterWrapper中的过滤器组成的Invoker，利用该Invoker，可以执行服务端的过滤器，执行完过滤器之后，调用下层Invoker</li>
<li> RegistryProtocol$InvokerDelegate：服务的的委托类，里面包含了DelegateProviderMetaDataInvoker对象和服务对应的providerUrl，执行时直接调用下层Invoker</li>
<li> DelegateProviderMetaDataInvoker：服务的的委托类，里面包含了AbstractProxyInvoker对象和ServiceConfig对象，执行时直接调用下层Invoker</li>
<li>AbstractProxyInvoker：服务接口的代理类，绑定了对应的实现类，执行时会利用反射调用服务实现类实例的具体方法，并得到结果</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">youthlql</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://imlql.cn/post/48141866.html">https://imlql.cn/post/48141866.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://imlql.cn" target="_blank">风祈的时光录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dubbo/">Dubbo</a><a class="post-meta__tags" href="/tags/rpc/">rpc</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://npm.elemecdn.com/youthlql@1.0.8/blog/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/blog/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/youthlql@1.0.8/blog/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/blog/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/bda15919.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">06.Dubbo源码系列V1-Dubbo第六节-服务引入源码解析</div></div></a></div><div class="next-post pull-right"><a href="/post/796f395d.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/84653c9d.html" title="07.Dubbo源码系列V1-Dubbo第七节-服务调用源码解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-09</div><div class="title">07.Dubbo源码系列V1-Dubbo第七节-服务调用源码解析</div></div></a></div><div><a href="/post/d3c530c4.html" title="01&02.Dubbo源码系列V1-Dubbo第一二节-基本应用与高级应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-11</div><div class="title">01&02.Dubbo源码系列V1-Dubbo第一二节-基本应用与高级应用</div></div></a></div><div><a href="/post/dbcfef47.html" title="03.Dubbo源码系列V1-Dubbo第三节-可扩展机制SPI源码解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-12</div><div class="title">03.Dubbo源码系列V1-Dubbo第三节-可扩展机制SPI源码解析</div></div></a></div><div><a href="/post/796f395d.html" title="04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-06</div><div class="title">04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析</div></div></a></div><div><a href="/post/bda15919.html" title="06.Dubbo源码系列V1-Dubbo第六节-服务引入源码解析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upyunimg.imlql.cn/lql_static@latest/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-08</div><div class="title">06.Dubbo源码系列V1-Dubbo第六节-服务引入源码解析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E5%AF%BC%E5%87%BA-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">第五节: Dubbo服务注册(导出)源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-text">服务导出原理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%9A%84%E6%BC%94%E5%8C%96"><span class="toc-text">服务概念的演化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E6%80%9D%E6%83%B3"><span class="toc-text">服务导出思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">确定服务的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%82%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="toc-text">确定服务的参数概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%82%E6%95%B0%E6%BA%90%E7%A0%81"><span class="toc-text">确定服务的参数源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ServiceBean"><span class="toc-text">ServiceBean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ServiceConfig"><span class="toc-text">ServiceConfig</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractInterfaceConfig"><span class="toc-text">AbstractInterfaceConfig</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConfigManager"><span class="toc-text">ConfigManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractConfig"><span class="toc-text">AbstractConfig</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Environment"><span class="toc-text">Environment</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%9C%8D%E5%8A%A1%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-text">确定服务支持的协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL%E4%BD%9C%E7%94%A8"><span class="toc-text">URL作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%8D%E5%8A%A1%E6%9C%80%E7%BB%88%E7%9A%84URL"><span class="toc-text">构造服务最终的URL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3%E8%BF%87%E7%A8%8B"><span class="toc-text">开始服务注册相关过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E7%94%A8%E6%BA%90%E7%A0%81"><span class="toc-text">公用源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ServiceConfig-1"><span class="toc-text">ServiceConfig</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Netty-Tomcat%E7%AD%89Server%E6%BA%90%E7%A0%81"><span class="toc-text">启动Netty,Tomcat等Server源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RegistryProtocol"><span class="toc-text">RegistryProtocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DubboProtocol"><span class="toc-text">DubboProtocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractProtocol"><span class="toc-text">AbstractProtocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Server%E6%80%BB%E7%BB%93"><span class="toc-text">启动Server总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%BA%90%E7%A0%81"><span class="toc-text">服务注册源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RegistryProtocol-1"><span class="toc-text">RegistryProtocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FailbackRegistry-java"><span class="toc-text">FailbackRegistry.java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZookeeperRegistry"><span class="toc-text">ZookeeperRegistry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">服务监听器原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-text">服务监听器原理总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8%E7%BB%91%E5%AE%9A%E6%BA%90%E7%A0%81"><span class="toc-text">服务监听器绑定源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RegistryProtocol-2"><span class="toc-text">RegistryProtocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractConfiguratorListener"><span class="toc-text">AbstractConfiguratorListener</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8%E7%9B%91%E5%90%AC%E6%BA%90%E7%A0%81"><span class="toc-text">服务监听器监听源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RegistryProtocol-3"><span class="toc-text">RegistryProtocol</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%87%8D%E6%96%B0%E5%AF%BC%E5%87%BA%E6%BA%90%E7%A0%81"><span class="toc-text">服务重新导出源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DubboProtocol-1"><span class="toc-text">DubboProtocol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HeaderExchangeServer"><span class="toc-text">HeaderExchangeServer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CloseTimerTask"><span class="toc-text">CloseTimerTask</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">服务导出源码流程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exporter%E6%9E%B6%E6%9E%84"><span class="toc-text">Exporter架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFInvoker%E6%9E%B6%E6%9E%84"><span class="toc-text">服务端Invoker架构</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By youthlql</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener" class="one-pan-link-mark"><img style="position:relative;top:-3px; " src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/upyun/logo.png" align="absmiddle" width="60px" height="30px"></a><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/icp.png"><span>鄂ICP备19028890号-3</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page/instantpage.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script></div></body></html>