<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析 | 风祈的时光录</title><meta name="keywords" content="Dubbo，rpc"><meta name="author" content="youthlql"><meta name="copyright" content="youthlql"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring与Dubbo整合原理与源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析">
<meta property="og:url" content="https://imlql.cn/post/796f395d.html">
<meta property="og:site_name" content="风祈的时光录">
<meta property="og:description" content="Spring与Dubbo整合原理与源码分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png">
<meta property="article:published_time" content="2021-10-06T05:21:58.000Z">
<meta property="article:modified_time" content="2021-12-22T15:30:05.316Z">
<meta property="article:author" content="youthlql">
<meta property="article:tag" content="Dubbo">
<meta property="article:tag" content="rpc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png"><link rel="shortcut icon" href="https://unpkg.zhimg.com/youthlql@1.0.8/blog/favicon.png"><link rel="canonical" href="https://imlql.cn/post/796f395d"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f693ff99cc7e613b88cf5b729a14b48b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1279775059&amp;web_id=1279775059"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-22 23:30:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/youthlql/lql_static/butterfly_static/css/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/youthlql/lql_static/butterfly_static/css/12_08-mogai.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="风祈的时光录" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/youthlql/randombg/raw/master/avatar/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://youthlql.gitee.io/lql_nav/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">风祈的时光录</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://youthlql.gitee.io/lql_nav/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-06T05:21:58.000Z" title="发表于 2021-10-06 13:21:58">2021-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-22T15:30:05.316Z" title="更新于 2021-12-22 23:30:05">2021-12-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/rpc/">rpc</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/rpc/Dubbo%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97v1/">Dubbo源码系列v1</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="04.Dubbo源码系列V1-Dubbo第四节-Spring与Dubbo整合原理与源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第四节-Spring与Dubbo整合原理与源码分析"><a href="#第四节-Spring与Dubbo整合原理与源码分析" class="headerlink" title="第四节: Spring与Dubbo整合原理与源码分析"></a>第四节: Spring与Dubbo整合原理与源码分析</h2><h4 id="处理-Service"><a href="#处理-Service" class="headerlink" title="处理@Service"></a>处理@Service</h4><ol>
<li>Dubbo的@Service注解Spring的@Service注解重名了，dubbo在2.7版本之后改成了@DubboService注解。</li>
</ol>
<blockquote>
<p>在Dubbo的文章中如果不是特别说明@Service注解均为Dubbo的注解</p>
</blockquote>
<ol start="2">
<li>Dubbo在处理@Service注解时会生成两个对象，看上面的图，DemoServiceImpl这个是给Spring容器生成的，意思就是@Service注解兼具了Spring@Service注解的功能。同时@Serivce注解会再生成一个ServiceBean类型的对象，这个对象会做一些事情，比如：将对应的服务类注册到注册中心，将service服务进行分组，分版本，控制超时，权重等等。@Service注解上面写的参数，都是由ServiceBean类型的对象来承接。当调用ServiceBean类型里面的export方法就可以控制服务的注册。</li>
<li>ServiceBean的父类里有一个ref属性，指向这个服务的实现类</li>
</ol>
<h4 id="处理Properties文件"><a href="#处理Properties文件" class="headerlink" title="处理Properties文件"></a>处理Properties文件</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个会被解析成ApplicationConfig对象</span></span><br><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">dubbo-demo-provider1-application</span></span><br><span class="line"><span class="meta">dubbo.application.logger</span>=<span class="string">log4j</span></span><br><span class="line"><span class="meta">dubbo.application.timeout</span>=<span class="string">3000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个会被解析成ProtocolConfig</span></span><br><span class="line"><span class="meta">dubbo.protocols.p1.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="meta">dubbo.protocols.p1.port</span>=<span class="string">20880</span></span><br><span class="line"><span class="meta">dubbo.protocols.p1.host</span>=<span class="string">0.0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">dubbo.protocols.p2.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="meta">dubbo.protocols.p2.port</span>=<span class="string">20881</span></span><br><span class="line"><span class="meta">dubbo.protocols.p2.host</span>=<span class="string">0.0.0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个会被解析成RegistrieConfig</span></span><br><span class="line"><span class="meta">dubbo.registries.r1.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="meta">dubbo.registries.r1.timeout</span>=<span class="string">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等等</span></span><br></pre></td></tr></table></figure>

<p>这些xxxConfig最后都会赋值给ServiceBean里相应的属性</p>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p>应用启动类与配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.demo.provider&quot;)</span></span><br><span class="line">    <span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>应用配置类为ProviderConfiguration, 在配置上有两个比较重要的注解</p>
<ol>
<li> @PropertySource表示将dubbo-provider.properties中的配置项添加到Spring容器中，可以通过@Value的方式获取到配置项中的值</li>
<li> @EnableDubbo(scanBasePackages = “org.apache.dubbo.demo.provider”)表示对指定包下的类进行扫描，扫描@Service与@Reference注解，并且进行处理</li>
</ol>
<h3 id="EnableDubbo"><a href="#EnableDubbo" class="headerlink" title="@EnableDubbo"></a>@EnableDubbo</h3><p>在EnableDubbo注解上，有另外两个注解，也是研究Dubbo最重要的两个注解</p>
<ol>
<li> @EnableDubboConfig</li>
<li> @DubboComponentScan</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboConfigConfigurationRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubboConfig &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析properties文件  ===&gt;   xxxConfig </span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析@Service @Refrence注解</span></span><br></pre></td></tr></table></figure>



<p>注意两个注解中对应的@Import注解所导入的类：</p>
<ol>
<li> DubboConfigConfigurationRegistrar</li>
<li> DubboComponentScanRegistrar</li>
</ol>
<p>Spring在启动时会解析这两个注解，并且执行对应的Registrar类中的registerBeanDefinitions方法（这是Spring中提供的扩展功能。）</p>
<h3 id="DubboConfigConfigurationRegistrar"><a href="#DubboConfigConfigurationRegistrar" class="headerlink" title="DubboConfigConfigurationRegistrar"></a>DubboConfigConfigurationRegistrar</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfigurationRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行DubboConfigConfigurationRegistrar&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(</span><br><span class="line">                importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">&quot;multiple&quot;</span>); <span class="comment">// 拿EnableDubboConfig里的默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Single Config Bindings</span></span><br><span class="line">        registerBeans(registry, DubboConfigConfiguration.Single.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为true</span></span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123; <span class="comment">// Since 2.6.6 https://github.com/apache/dubbo/issues/3193</span></span><br><span class="line">            registerBeans(registry, DubboConfigConfiguration.Multiple.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>Spring启动时，会调用DubboConfigConfigurationRegistrar的registerBeanDefinitions方法，该方法是利用Spring中的AnnotatedBeanDefinitionReader来读取：</p>
<ol>
<li> DubboConfigConfiguration.Single.<strong>class</strong></li>
<li> DubboConfigConfiguration.Multiple.<strong>class</strong></li>
</ol>
<p>这两个类上的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Single Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; Bean Binding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDubboConfigBindings(&#123;</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.application&quot;, type = ApplicationConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.module&quot;, type = ModuleConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.registry&quot;, type = RegistryConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.protocol&quot;, type = ProtocolConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.monitor&quot;, type = MonitorConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.provider&quot;, type = ProviderConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.consumer&quot;, type = ConsumerConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.config-center&quot;, type = ConfigCenterBean.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.metadata-report&quot;, type = MetadataReportConfig.class),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.metrics&quot;, type = MetricsConfig.class)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Multiple Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; Bean Binding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDubboConfigBindings(&#123;</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.applications&quot;, type = ApplicationConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.modules&quot;, type = ModuleConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.registries&quot;, type = RegistryConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.protocols&quot;, type = ProtocolConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.monitors&quot;, type = MonitorConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.providers&quot;, type = ProviderConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.consumers&quot;, type = ConsumerConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.config-centers&quot;, type = ConfigCenterBean.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.metadata-reports&quot;, type = MetadataReportConfig.class, multiple = true),</span></span><br><span class="line"><span class="meta">            @EnableDubboConfigBinding(prefix = &quot;dubbo.metricses&quot;, type = MetricsConfig.class, multiple = true)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概意思就是什么前缀的注解，对应解析到哪个类的对象里。</p>
<p>这两个类主要用到的就是@EnableDubboConfigBindings注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboConfigBindingsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubboConfigBindings &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of &#123;<span class="doctag">@link</span> EnableDubboConfigBindings&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EnableDubboConfigBinding[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@EnableDubboConfigBindings注解上也有一个@Import注解，导入的是DubboConfigBindingsRegistrar.<strong>class</strong>。该类会获取@EnableDubboConfigBindings注解中的value，也就是多个@EnableDubboConfigBinding注解，然后利用DubboConfigBindingRegistrar去处理这些@EnableDubboConfigBinding注解。</p>
<h4 id="DubboConfigBindingRegistrar"><a href="#DubboConfigBindingRegistrar" class="headerlink" title="DubboConfigBindingRegistrar"></a>DubboConfigBindingRegistrar</h4><h5 id="此类总结"><a href="#此类总结" class="headerlink" title="此类总结"></a>此类总结</h5><p>此类中的主要方法是registerDubboConfigBeans()方法，主要功能就是获取用户所设置的properties文件中的内容，对Properties文件进行解析，根据Properties文件的每个配置项的前缀、参数名、参数值生成对应的BeanDefinition。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo.application.name=dubbo-demo-provider1-application</span><br><span class="line">dubbo.application.logger=log4j</span><br></pre></td></tr></table></figure>

<p>前缀为”dubbo.application”的配置项，会生成一个ApplicationConfig类型的BeanDefinition，并且name和logger属性为对应的值。</p>
<p>再比如：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo.protocols.p1.name=dubbo</span><br><span class="line">dubbo.protocols.p1.port=<span class="number">20880</span></span><br><span class="line">dubbo.protocols.p1.host=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">dubbo.protocols.p2.name=dubbo</span><br><span class="line">dubbo.protocols.p2.port=<span class="number">20881</span></span><br><span class="line">dubbo.protocols.p2.host=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>比如前缀为”dubbo.protocols”的配置项，会生成<strong>两</strong>个ProtocolConfig类型的BeanDefinition，两个BeanDefinition的beanName分别为p1和p2。</p>
<p>并且还会针对生成的每个BeanDefinition生成一个和它一对一绑定的BeanPostProcessor，类型为DubboConfigBindingBeanPostProcessor.<strong>class</strong>。</p>
<h5 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h5><blockquote>
<p>整个类的代码注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; binding Bean registrar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行DubboConfigBindingRegistrar&quot;</span>);</span><br><span class="line"></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(</span><br><span class="line">                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding.class.getName()));</span><br><span class="line"></span><br><span class="line">        registerBeanDefinitions(attributes, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes attributes, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prefix = &quot;dubbo.application&quot;</span></span><br><span class="line">        String prefix = environment.resolvePlaceholders(attributes.getString(<span class="string">&quot;prefix&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// type = ApplicationConfig.class</span></span><br><span class="line">        Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass(<span class="string">&quot;type&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">&quot;multiple&quot;</span>);</span><br><span class="line"></span><br><span class="line">        registerDubboConfigBeans(prefix, configClass, multiple, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBeans</span><span class="params">(String prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> multiple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从properties文件中根据前缀拿对应的配置项，比如根据dubbo.application前缀，</span></span><br><span class="line">        <span class="comment">// 就可以拿到：</span></span><br><span class="line">        <span class="comment">// dubbo.application.name=dubbo-demo-provider-application</span></span><br><span class="line">        <span class="comment">// dubbo.application.logger=log4j</span></span><br><span class="line">        Map&lt;String, Object&gt; properties = getSubProperties(environment.getPropertySources(), prefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有相关的配置项，则不需要注册BeanDefinition</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(properties)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;There is no property for binding to dubbo config class [&quot;</span> + configClass.getName()</span><br><span class="line">                        + <span class="string">&quot;] within prefix [&quot;</span> + prefix + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据配置项生成beanNames，为什么会有多个？</span></span><br><span class="line">        <span class="comment">// 普通情况一个dubbo.application前缀对应一个ApplicationConfig类型的Bean</span></span><br><span class="line">        <span class="comment">// 特殊情况下，比如dubbo.protocols对应了：</span></span><br><span class="line"><span class="comment">//        dubbo.protocols.p1.name=dubbo</span></span><br><span class="line"><span class="comment">//        dubbo.protocols.p1.port=20880</span></span><br><span class="line"><span class="comment">//        dubbo.protocols.p1.host=0.0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        dubbo.protocols.p2.name=http</span></span><br><span class="line"><span class="comment">//        dubbo.protocols.p2.port=8082</span></span><br><span class="line"><span class="comment">//        dubbo.protocols.p2.host=0.0.0.0</span></span><br><span class="line">        <span class="comment">// 那么就需要对应两个ProtocolConfig类型的Bean，那么就需要两个beanName:p1和p2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就是multiple为true或false的区别，名字的区别，根据multiple用来判断是否从配置项中获取beanName</span></span><br><span class="line">        <span class="comment">// 如果multiple为false，则看有没有配置id属性，如果没有配置则自动生成一个beanName.</span></span><br><span class="line">        Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) :</span><br><span class="line">                Collections.singleton(resolveSingleBeanName(properties, configClass, registry));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为每个beanName,注册一个空的BeanDefinition</span></span><br><span class="line">            registerDubboConfigBean(beanName, configClass, registry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为每个bean注册一个DubboConfigBindingBeanPostProcessor的Bean后置处理器</span></span><br><span class="line">            registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册一个NamePropertyDefaultValueDubboConfigBeanCustomizer的bean</span></span><br><span class="line">        <span class="comment">// 用来把某个XxConfig所对应的beanName设置到name属性中去</span></span><br><span class="line">        registerDubboConfigBeanCustomizers(registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBean</span><span class="params">(String beanName, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(configClass);</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        registry.registerBeanDefinition(beanName, beanDefinition);   <span class="comment">// ApplicatinoConfig对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;The dubbo config bean definition [name : &quot;</span> + beanName + <span class="string">&quot;, class : &quot;</span> + configClass.getName() +</span><br><span class="line">                    <span class="string">&quot;] has been registered.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName, <span class="keyword">boolean</span> multiple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册一个DubboConfigBindingBeanPostProcessor的Bean</span></span><br><span class="line">        <span class="comment">// 每个XxConfig的Bean对应一个DubboConfigBindingBeanPostProcessor的Bean</span></span><br><span class="line">        <span class="comment">// 比如，一个ApplicationConfig对应一个DubboConfigBindingBeanPostProcessor，</span></span><br><span class="line">        <span class="comment">// 一个ProtocolConfig也会对应一个DubboConfigBindingBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 在构造DubboConfigBindingBeanPostProcessor的时候会指定构造方法的值，这样就可以区别开来了</span></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; processorClass = DubboConfigBindingBeanPostProcessor.class;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真实的前缀，比如dubbo.registries.r2</span></span><br><span class="line">        String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加两个构造方法参数值，所以会调用DubboConfigBindingBeanPostProcessor的两个参数的构造方法</span></span><br><span class="line">        builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"></span><br><span class="line">        registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;The BeanPostProcessor bean definition [&quot;</span> + processorClass.getName()</span><br><span class="line">                    + <span class="string">&quot;] for dubbo config bean [name : &quot;</span> + beanName + <span class="string">&quot;] has been registered.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBeanCustomizers</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        registerInfrastructureBean(registry, BEAN_NAME, NamePropertyDefaultValueDubboConfigBeanCustomizer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.environment = (ConfigurableEnvironment) environment;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">resolveMultipleBeanNames</span><span class="params">(Map&lt;String, Object&gt; properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; beanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如dubbo.protocols.p1.name=dubbo的propertyName为p1.name</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String propertyName : properties.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// propertyName为p1.name</span></span><br><span class="line">            <span class="keyword">int</span> index = propertyName.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 截取beanName名字为p1</span></span><br><span class="line">                String beanName = propertyName.substring(<span class="number">0</span>, index);</span><br><span class="line"></span><br><span class="line">                beanNames.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanNames;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">resolveSingleBeanName</span><span class="params">(Map&lt;String, Object&gt; properties, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置了dubbo.application.id=appl，那么appl就是beanName</span></span><br><span class="line">        String beanName = (String) properties.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果beanName为null，则会进入if分支，由spring自动生成一个beanName,比如org.apache.dubbo.config.ApplicationConfig#0</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            BeanDefinitionBuilder builder = rootBeanDefinition(configClass);</span><br><span class="line">            beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DubboConfigBindingBeanPostProcessor"><a href="#DubboConfigBindingBeanPostProcessor" class="headerlink" title="DubboConfigBindingBeanPostProcessor"></a>DubboConfigBindingBeanPostProcessor</h4><p>DubboConfigBindingBeanPostProcessor是一个BeanPostProcessor，在Spring启动过程中，会针对所有的Bean对象进行后置加工，但是在DubboConfigBindingBeanPostProcessor中有如下判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanName.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> AbstractConfig)</span><br></pre></td></tr></table></figure>

<p>所以DubboConfigBindingBeanPostProcessor并不会处理Spring容器中的所有Bean，它只会处理上文由Dubbo所生成的Bean对象。</p>
<p>并且，在afterPropertiesSet()方法中，会先创建一个DefaultDubboConfigBinder。</p>
<h5 id="代码注释-1"><a href="#代码注释-1" class="headerlink" title="代码注释"></a>代码注释</h5><blockquote>
<p>只留了关键性的代码注释，其余省略</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo Config Binding &#123;<span class="doctag">@link</span> BeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span></span></span><br><span class="line"><span class="class">        , <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The prefix of Configuration Properties</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binding Bean Name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DubboConfigBinder dubboConfigBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry beanDefinitionRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnknownFields = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreInvalidFields = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;DubboConfigBeanCustomizer&gt; configBeanCustomizers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix   the prefix of Configuration Properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the binding Bean Name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(prefix, <span class="string">&quot;The prefix of Configuration Properties must not be null&quot;</span>);</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;The name of bean must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">        <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.每个XxConfig对应一个BeanPostProcessor，所以每个DubboConfigBindingBeanPostProcessor只处理对应的beanName</span></span><br><span class="line"><span class="comment">	    2.阿里这里的代码写的很不好，没必要为每一个Bean都生成一个BeanPostProcessor，多余的加这个if判断，每一个Bean</span></span><br><span class="line"><span class="comment">         都会经过Dubbo生成的BeanPostProcessor，不停的if判断，直到找到自己的BeanPostProcessor。还好Dubbo后面的版本</span></span><br><span class="line"><span class="comment">         把这里改了。</span></span><br><span class="line"><span class="comment">        3.看过Spring源码的应该知道Spring的BeanPostProcessor是所有对象公用的，这种处理就比较好.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanName.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> AbstractConfig) &#123;</span><br><span class="line"></span><br><span class="line">            AbstractConfig dubboConfig = (AbstractConfig) bean;</span><br><span class="line">            <span class="comment">// 从properties文件中获取值，并设置到dubboConfig对象中</span></span><br><span class="line">            bind(prefix, dubboConfig);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置dubboConfig对象的name属性，设置为beanName</span></span><br><span class="line">            customize(beanName, dubboConfig);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(String prefix, AbstractConfig dubboConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        dubboConfigBinder.bind(prefix, dubboConfig);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;The properties of bean [name : &quot;</span> + beanName + <span class="string">&quot;] have been binding by prefix of &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;configuration properties : &quot;</span> + prefix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(String beanName, AbstractConfig dubboConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DubboConfigBeanCustomizer customizer : configBeanCustomizers) &#123;</span><br><span class="line">            customizer.customize(beanName, dubboConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AbstractConfig) &#123;</span><br><span class="line">            <span class="comment">// 添加别名，id属性的值为别名</span></span><br><span class="line"></span><br><span class="line">            String id = ((AbstractConfig) bean).getId();</span><br><span class="line">            <span class="keyword">if</span> (beanDefinitionRegistry != <span class="keyword">null</span> &amp;&amp; beanDefinitionRegistry <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">                DefaultListableBeanFactory factory = (DefaultListableBeanFactory) beanDefinitionRegistry;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isBlank(id) &amp;&amp; !factory.hasAlias(beanName, id)) &#123;</span><br><span class="line">                    beanDefinitionRegistry.registerAlias(beanName, id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里建议看看Spring源码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        initDubboConfigBinder();        <span class="comment">// 创建DefaultDubboConfigBinder</span></span><br><span class="line"></span><br><span class="line">        initConfigBeanCustomizers();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDubboConfigBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dubboConfigBinder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 先从Spring容器中获取DubboConfigBinder，默认获取不到</span></span><br><span class="line">                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ignored) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;DubboConfigBinder Bean can&#x27;t be found in ApplicationContext.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Use Default implementation</span></span><br><span class="line">                <span class="comment">// 生成一个默认的</span></span><br><span class="line">                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);</span><br><span class="line">        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initConfigBeanCustomizers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到之前创建了的NamePropertyDefaultValueDubboConfigBeanCustomizer</span></span><br><span class="line">        Collection&lt;DubboConfigBeanCustomizer&gt; configBeanCustomizers =</span><br><span class="line">                beansOfTypeIncludingAncestors(applicationContext, DubboConfigBeanCustomizer.class).values();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.configBeanCustomizers = <span class="keyword">new</span> ArrayList&lt;&gt;(configBeanCustomizers);</span><br><span class="line"></span><br><span class="line">        AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.configBeanCustomizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create &#123;<span class="doctag">@link</span> DubboConfigBinder&#125; instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DefaultDubboConfigBinder&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DubboConfigBinder <span class="title">createDubboConfigBinder</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        DefaultDubboConfigBinder defaultDubboConfigBinder = <span class="keyword">new</span> DefaultDubboConfigBinder();</span><br><span class="line">        defaultDubboConfigBinder.setEnvironment(environment);</span><br><span class="line">        <span class="keyword">return</span> defaultDubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanDefinitionRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionRegistry = registry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DefaultDubboConfigBinder"><a href="#DefaultDubboConfigBinder" class="headerlink" title="DefaultDubboConfigBinder"></a>DefaultDubboConfigBinder</h4><p>当某个AbstractConfig类型的Bean，在经过DubboConfigBindingBeanPostProcessor处理时，此时Bean对象中的属性是没有值的，会利用DefaultDubboConfigBinder进行赋值。底层就是利用Spring中的DataBinder技术，结合properties文件对对应的属性进行赋值。</p>
<p>对应一个AbstractConfig类型（针对的其实是子类，比如ApplicationConfig、RegistryConfig）的Bean，每个类都有一些属性，而properties文件是一个key-value对，所以实际上DataBinder就是将属性名和properties文件中的key进行匹配，如果匹配成功，则把value赋值给属性。具体DataBinder技术是如何工作的，请自行学习（不难）。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo.application.name=dubbo-demo-provider1-application</span><br><span class="line">dubbo.application.logger=log4j</span><br></pre></td></tr></table></figure>



<p>对于此配置，它对应ApplicationConfig对象（beanName是自动生成的），所以最终ApplicationConfig对象的name属性的值为“dubbo-demo-provider1-application”，logger属性的值为“log4j”。</p>
<p>对于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo.protocols.p1.name=dubbo</span><br><span class="line">dubbo.protocols.p1.port=<span class="number">20880</span></span><br><span class="line">dubbo.protocols.p1.host=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>



<p>它对应ProtocolConfig对象（beanName为p1）,所以最终ProtocolConfig对象的name属性的值为“dubbo”，port属性的值为20880，host属性的值为“0.0.0.0”。</p>
<p>这样就完成了对properties文件的解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDubboConfigBinder</span> <span class="keyword">extends</span> <span class="title">AbstractDubboConfigBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;C extends AbstractConfig&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(String prefix, C dubboConfig)</span> </span>&#123;</span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(dubboConfig);</span><br><span class="line">        <span class="comment">// Set ignored*</span></span><br><span class="line">        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());</span><br><span class="line">        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());</span><br><span class="line">        <span class="comment">// Get properties under specified prefix from PropertySources</span></span><br><span class="line">        <span class="comment">// getPropertySources()会拿到由@PropertySource注入进来的properties文件中的内容</span></span><br><span class="line">        <span class="comment">// 同时还包括当前java的所有环境变量，包括手动通过-D添加的配置</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; properties = getSubProperties(getPropertySources(), prefix);</span><br><span class="line">        <span class="comment">// Convert Map to MutablePropertyValues</span></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(properties);</span><br><span class="line">        <span class="comment">// Bind</span></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DubboConfigConfigurationRegistrar的主要作用就是对propties文件进行解析并根据不同的配置项项生成对应类型的Bean对象。</p>
<h3 id="DubboComponentScanRegistrar"><a href="#DubboComponentScanRegistrar" class="headerlink" title="DubboComponentScanRegistrar"></a>DubboComponentScanRegistrar</h3><p>DubboConfigConfigurationRegistrar的作用是向Spring容器中注册两个Bean:</p>
<ol>
<li> ServiceAnnotationBeanPostProcessor</li>
<li>ReferenceAnnotationBeanPostProcessor</li>
</ol>
<h4 id="代码注释-2"><a href="#代码注释-2" class="headerlink" title="代码注释"></a>代码注释</h4><blockquote>
<p>部分代码注释</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo &#123;<span class="doctag">@link</span> DubboComponentScan&#125; Bean Registrar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboComponentScan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReferenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行DubboComponentScanRegistrar&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到DubboComponentScan注解所定义的包路径，扫描该package下的类，识别这些类上</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册ServiceAnnotationBeanPostProcessor一个Bean</span></span><br><span class="line">        <span class="comment">// 实现了BeanDefinitionRegistryPostProcessor接口，所以在Spring启动时会调用postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">        <span class="comment">// 该方法会进行扫描，扫描@Service注解了的类，然后生成BeanDefinition（会生成两个，一个普通的bean，一个ServiceBean），后续的Spring周期中会生成Bean</span></span><br><span class="line">        <span class="comment">// 在ServiceBean中会监听ContextRefreshedEvent事件，一旦Spring启动完后，就会进行服务导出</span></span><br><span class="line">        registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册ReferenceAnnotationBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 实现了AnnotationInjectedBeanPostProcessor接口，继而实现了InstantiationAwareBeanPostProcessorAdapter接口</span></span><br><span class="line">        <span class="comment">// 所以Spring在启动时，在对属性进行注入时会调用AnnotationInjectedBeanPostProcessor接口中的postProcessPropertyValues方法</span></span><br><span class="line">        <span class="comment">// 在这个过程中会按照@Reference注解的信息去生成一个RefrenceBean对象</span></span><br><span class="line">        registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ServiceAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagesToScan packages to scan without resolving placeholders</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成一个RootBeanDefinition，对应的beanClass为ServiceAnnotationBeanPostProcessor.class</span></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);</span><br><span class="line">        <span class="comment">// 将包路径作为在构造ServiceAnnotationBeanPostProcessor时调用构造方法时的传入参数</span></span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor&#125; into &#123;<span class="doctag">@link</span> BeanFactory&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceAnnotationBeanPostProcessor</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register @Reference Annotation Bean Processor</span></span><br><span class="line">        <span class="comment">// 注册一个ReferenceAnnotationBeanPostProcessor做为bean，ReferenceAnnotationBeanPostProcessor是一个BeanPostProcessor</span></span><br><span class="line">        BeanRegistrar.registerInfrastructureBean(registry,</span><br><span class="line">                ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h4><blockquote>
<p>主要就是处理@Service注解</p>
</blockquote>
<p>ServiceAnnotationBeanPostProcessor是一个BeanDefinitionRegistryPostProcessor，是用来注册BeanDefinition的。这个类的名字起的不太好。</p>
<p>它的主要作用是扫描Dubbo的@Service注解，一旦扫描到某个@Service注解就把它以及被它注解的类当做一个Dubbo服务，进行<strong>服务导出</strong>。</p>
<h5 id="DubboClassPathBeanDefinitionScanner"><a href="#DubboClassPathBeanDefinitionScanner" class="headerlink" title="DubboClassPathBeanDefinitionScanner"></a>DubboClassPathBeanDefinitionScanner</h5><p>DubboClassPathBeanDefinitionScanner是所Dubbo自定义的扫描器，继承了Spring中的ClassPathBeanDefinitionScanner了。</p>
<p>DubboClassPathBeanDefinitionScanner相对于ClassPathBeanDefinitionScanner并没有做太多的改变，只是把useDefaultFilters设置为了false，主要是因为Dubbo中的@Service注解是Dubbo自定义的，在这个注解上并没有用@Component注解（因为Dubbo不是一定要结合Spring才能用），所以为了能利用Spring的扫描逻辑，需要把useDefaultFilters设置为false。</p>
<p>每扫描到一个@Service注解，就会得到一个BeanDefinition，这个BeanDefinition的beanClass属性就是具体的服务实现类。</p>
<p>但，如果仅仅只是这样，这只是得到了一个Spring中的Bean，对于Dubbo来说此时得到的Bean是一个<strong>服务</strong>，并且，还需要解析@Service注解的配置信息，因为这些都是服务的参数信息，所以在扫描完了之后，会针对所得到的每个BeanDefinition，都会<strong>额外</strong>的再生成一个<strong>ServiceBean</strong>类型的Bean对象。</p>
<h5 id="ServiceBean"><a href="#ServiceBean" class="headerlink" title="ServiceBean"></a>ServiceBean</h5><p>ServiceBean表示一个Dubbo服务，它有一些参数，比如：</p>
<ol>
<li> <strong>ref，表示服务的具体实现类</strong></li>
<li> <strong>interface，表示服务的接口</strong></li>
<li> <strong>parameters，表示服务的参数（@Service注解中所配置的信息）</strong></li>
<li> <strong>application，表示服务所属的应用</strong></li>
<li> <strong>protocols，表示服务所使用的协议</strong></li>
<li> <strong>registries，表示服务所要注册的注册中心</strong></li>
</ol>
<p><strong>所以在扫描到一个@Service注解后，其实会得到两个Bean:</strong></p>
<ol>
<li> 一个就是服务实现类本身一个Bean对象</li>
<li>一个就是对应的ServiceBean类型的一个Bean对象</li>
</ol>
<p>并且需要注意的是，ServiceBean实现了ApplicationListener接口，所以当Spring启动完成后会触发onApplicationEvent()方法的调用，而在这个方法内会调用<strong>export()<strong>，这个方法就是</strong>服务导出的入口方法</strong>。</p>
<h5 id="代码注释-3"><a href="#代码注释-3" class="headerlink" title="代码注释"></a>代码注释</h5><blockquote>
<p>部分代码注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Service&#125; Annotation</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor Bean Definition Registry Post Processor&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; packagesToScan;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(String... packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Arrays.asList(packagesToScan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Collection&lt;String&gt; packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> LinkedHashSet&lt;&gt;(packagesToScan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.packagesToScan = packagesToScan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="comment">// 扫描包，进行Bean注册</span></span><br><span class="line">            registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;packagesToScan is empty , ServiceBean registry will be ignored!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagesToScan The base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">                <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描被Service注解标注的类，先成为Spring里的bean，也就是dubbo服务的实现类</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service.class));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add the compatibility for legacy Dubbo&#x27;s <span class="doctag">@Service</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The issue : https://github.com/apache/dubbo/issues/4330</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 2.7.3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(com.alibaba.dubbo.config.annotation.Service.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">            <span class="comment">// 扫描Dubbo自定义的@Service注解</span></span><br><span class="line">            scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找被@Service注解的类的BeanDefinition（无论这个类有没有被@ComponentScan注解标注了）</span></span><br><span class="line">            <span class="comment">// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.</span></span><br><span class="line">            <span class="comment">// beanDefinitionHolders装的就是dubbo服务的实现类，存在了Spring容器里</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扫描到BeanDefinition开始处理它，准备生成ServiceBean</span></span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                    registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(beanDefinitionHolders.size() + <span class="string">&quot; annotated Dubbo&#x27;s @Service Components &#123; &quot;</span> +</span><br><span class="line">                            beanDefinitionHolders +</span><br><span class="line">                            <span class="string">&quot; &#125; were scanned under package[&quot;</span> + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;No Spring Bean annotating Dubbo&#x27;s @Service was found under package[&quot;</span></span><br><span class="line">                            + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ServiceBean&#125; from new annotated &#123;<span class="doctag">@link</span> Service&#125; &#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinitionHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scanner</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ServiceBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 服务实现类</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line">        <span class="comment">// @Service注解</span></span><br><span class="line">        Annotation service = findServiceAnnotation(beanClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The &#123;<span class="doctag">@link</span> AnnotationAttributes&#125; of <span class="doctag">@Service</span> annotation</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// @Service注解上的信息</span></span><br><span class="line">        AnnotationAttributes serviceAnnotationAttributes = getAnnotationAttributes(service, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务实现类对应的接口</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(serviceAnnotationAttributes, beanClass);</span><br><span class="line">        <span class="comment">// 服务实现类对应的bean的名字，比如：demoServiceImpl</span></span><br><span class="line">        String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个ServiceBean</span></span><br><span class="line">        AbstractBeanDefinition serviceBeanDefinition =</span><br><span class="line">                buildServiceBeanDefinition(service, serviceAnnotationAttributes, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ServiceBean Bean name</span></span><br><span class="line">        String beanName = generateServiceBeanName(serviceAnnotationAttributes, interfaceClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; <span class="comment">// check duplicated candidate bean</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把ServiceBean注册进去，对应的beanName为ServiceBean:org.apache.dubbo.demo.DemoService</span></span><br><span class="line">            registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;The BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                        <span class="string">&quot;] of ServiceBean has been registered with name : &quot;</span> + beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;The Duplicated BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                        <span class="string">&quot;] of ServiceBean[ bean name : &quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;] was be found , Did @DubboComponentScan scan to same package in many times?&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generates the bean name of &#123;<span class="doctag">@link</span> ServiceBean&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceAnnotationAttributes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass              the class of interface annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ServiceBean@interfaceClassName#annotatedServiceBeanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateServiceBeanName</span><span class="params">(AnnotationAttributes serviceAnnotationAttributes, Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">        ServiceBeanNameBuilder builder = create(interfaceClass, environment)</span><br><span class="line">                .group(serviceAnnotationAttributes.getString(<span class="string">&quot;group&quot;</span>))</span><br><span class="line">                .version(serviceAnnotationAttributes.getString(<span class="string">&quot;version&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the &#123;<span class="doctag">@link</span> AbstractBeanDefinition Bean Definition&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceAnnotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceAnnotationAttributes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedServiceBeanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">buildServiceBeanDefinition</span><span class="params">(Annotation serviceAnnotation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              AnnotationAttributes serviceAnnotationAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              Class&lt;?&gt; interfaceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String annotatedServiceBeanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成一个ServiceBean对应的BeanDefinition</span></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class);</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.先忽略这些比较特殊的属性，为什么要忽略呢？</span></span><br><span class="line"><span class="comment">        2.其它不忽略的属性，在@Service注解上写的是字符串形式，ServiceBean里也是字符串类型，所以可以直接赋值</span></span><br><span class="line"><span class="comment">        3.下面的这些特殊属性，比如protocol，在注解上写的是@Service(protocol=&quot;p1&quot;)这样的字符串，但是在ServiceBean里</span></span><br><span class="line"><span class="comment">        对应的是ProtocolConfig类型的属性，不可能把字符串赋值给这类型。所以先忽略，后面可以看到单独处理了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String[] ignoreAttributeNames = of(<span class="string">&quot;provider&quot;</span>, <span class="string">&quot;monitor&quot;</span>, <span class="string">&quot;application&quot;</span>, <span class="string">&quot;module&quot;</span>, <span class="string">&quot;registry&quot;</span>, <span class="string">&quot;protocol&quot;</span>,</span><br><span class="line">                <span class="string">&quot;interface&quot;</span>, <span class="string">&quot;interfaceName&quot;</span>, <span class="string">&quot;parameters&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把@Service注解中的参数值赋值给ServiceBean的属性</span></span><br><span class="line">        propertyValues.addPropertyValues(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(serviceAnnotation, environment, ignoreAttributeNames));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// References &quot;ref&quot; property to annotated-@Service Bean</span></span><br><span class="line">        <span class="comment">// ref属性赋值为另外一个bean, 对应的就是被@Service注解的服务实现类对应的bean</span></span><br><span class="line">        addPropertyReference(builder, <span class="string">&quot;ref&quot;</span>, annotatedServiceBeanName);</span><br><span class="line">        <span class="comment">// Set interface</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;interface&quot;</span>, interfaceClass.getName());</span><br><span class="line">        <span class="comment">// Convert parameters into map</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;parameters&quot;</span>, convertParameters(serviceAnnotationAttributes.getStringArray(<span class="string">&quot;parameters&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置了methods属性，则给ServiceBean对应的methods属性赋值</span></span><br><span class="line">        <span class="comment">// Add methods parameters</span></span><br><span class="line">        List&lt;MethodConfig&gt; methodConfigs = convertMethodConfigs(serviceAnnotationAttributes.get(<span class="string">&quot;methods&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!methodConfigs.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;methods&quot;</span>, methodConfigs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;<span class="doctag">@link</span> org.apache.dubbo.config.ProviderConfig&#125; Bean reference</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String providerConfigBeanName = serviceAnnotationAttributes.getString(<span class="string">&quot;provider&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(providerConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">&quot;provider&quot;</span>, providerConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;<span class="doctag">@link</span> org.apache.dubbo.config.MonitorConfig&#125; Bean reference</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String monitorConfigBeanName = serviceAnnotationAttributes.getString(<span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(monitorConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">&quot;monitor&quot;</span>, monitorConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;<span class="doctag">@link</span> org.apache.dubbo.config.ApplicationConfig&#125; Bean reference</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String applicationConfigBeanName = serviceAnnotationAttributes.getString(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(applicationConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">&quot;application&quot;</span>, applicationConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;<span class="doctag">@link</span> org.apache.dubbo.config.ModuleConfig&#125; Bean reference</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String moduleConfigBeanName = serviceAnnotationAttributes.getString(<span class="string">&quot;module&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(moduleConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">&quot;module&quot;</span>, moduleConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;<span class="doctag">@link</span> org.apache.dubbo.config.RegistryConfig&#125; Bean reference</span></span><br><span class="line"><span class="comment">         * 获取注解上配置的注册中心的beanName</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] registryConfigBeanNames = serviceAnnotationAttributes.getStringArray(<span class="string">&quot;registry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!registryRuntimeBeanReferences.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;registries&quot;</span>, registryRuntimeBeanReferences);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;<span class="doctag">@link</span> org.apache.dubbo.config.ProtocolConfig&#125; Bean reference</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] protocolConfigBeanNames = serviceAnnotationAttributes.getStringArray(<span class="string">&quot;protocol&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!protocolRuntimeBeanReferences.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;protocols&quot;</span>, protocolRuntimeBeanReferences);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ReferenceAnnotationBeanPostProcessor"><a href="#ReferenceAnnotationBeanPostProcessor" class="headerlink" title="ReferenceAnnotationBeanPostProcessor"></a>ReferenceAnnotationBeanPostProcessor</h4><blockquote>
<p>处理@Reference注解</p>
</blockquote>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>ReferenceAnnotationBeanPostProcessor是处理@Reference注解的。</p>
<p>ReferenceAnnotationBeanPostProcessor的父类是AnnotationInjectedBeanPostProcessor，是一个InstantiationAwareBeanPostProcessorAdapter，是一个BeanPostProcessor。</p>
<p>Spring在对Bean进行依赖注入时会调用AnnotationInjectedBeanPostProcessor的postProcessPropertyValues()方法来给某个Bean按照ReferenceAnnotationBeanPostProcessor的逻辑进行依赖注入。</p>
<p>在注入之前会查找注入点，被@Reference注解的属性或方法都是注入点。</p>
<p>针对某个Bean找到所有注入点之后，就会进行注入了，注入就是给属性或给set方法赋值，但是在赋值之前得先得到一个值，此时就会调用ReferenceAnnotationBeanPostProcessor的<strong>doGetInjectedBean()<strong>方法来得到一个对象，而这个对象的构造就比较复杂了，因为对于Dubbo来说，注入给某个属性的应该是当前这个</strong>属性所对应的服务接口的代理对象</strong>。</p>
<p>但是在生成这个代理对象之前，还要考虑问题：</p>
<ol>
<li> 当前所需要引入的这个服务，是不是在本地就存在(就是当前项目)？不存在则要把按Dubbo的逻辑生成一个代理对象</li>
<li>当前所需要引入的这个服务，是不是已经被引入过了（是不是已经生成过代理对象了），如果是应该是不用再重复去生成了。</li>
</ol>
<p><strong>首先如何判断当前所引入的服务是本地的一个服务（就是当前应用自己所提供的服务）。</strong></p>
<p>我们前面提到，Dubbo通过@Service来提供一个服务，并且会生成两个Bean：</p>
<ol>
<li> 一个服务实现类本身Bean</li>
<li> 一个ServiceBean类型的Bean，这个Bean的名字是这么生成的：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateServiceBeanName</span><span class="params">(AnnotationAttributes serviceAnnotationAttributes, Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">	ServiceBeanNameBuilder builder = create(interfaceClass, environment)</span><br><span class="line">                .group(serviceAnnotationAttributes.getString(<span class="string">&quot;group&quot;</span>))</span><br><span class="line">                .version(serviceAnnotationAttributes.getString(<span class="string">&quot;version&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>是通过接口类型+group+version来作为ServiceBean类型Bean的名字的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceBean:org.apache.dubbo.demo.DemoService:group:version</span><br></pre></td></tr></table></figure>



<p>所以现在对于服务引入，也应该提前根据@Reference注解中的信息和属性接口类型去判断一下当前Spring容器中是否存在对应的ServiceBean对象，如果存在则直接取出ServiceBean对象的ref属性所对应的对象，作为要注入的结果。</p>
<p><strong>然后如何判断当前所引入的这个服务是否已经被引入过了****（是不是已经生成过代理对象了）。</strong></p>
<p>这就需要在第一次引入某个服务后（生成代理对象后）进行缓存（记录一下）。Dubbo中是这么做的:</p>
<ol>
<li> 首先根据@Reference注解的所有信息+属性接口类型生成一个<strong>字符串</strong></li>
<li> 然后@Reference注解的所有信息+属性接口类型生成一个ReferenceBean对象（<strong>ReferenceBean对象中的get方法可以得到一个Dubbo生成的代理对象，可以理解为服务引入的入口方法</strong>）</li>
<li>把字符串作为beanName，ReferenceBean对象作为bean注册到Spring容器中，同时也会放入<strong>referenceBeanCache</strong>中。</li>
</ol>
<p>有了这些逻辑，@Reference注解服务引入的过程是这样的：</p>
<ol>
<li><p> 得到当前所引入服务对应的ServiceBean的beanName（源码中叫referencedBeanName）</p>
</li>
<li><p> 根据@Reference注解的所有信息+属性接口类型得到一个referenceBeanName</p>
</li>
<li><p> 根据referenceBeanName从<strong>referenceBeanCach</strong>e获取对应的ReferenceBean，如果没有则创建一个ReferenceBean</p>
</li>
<li><p>根据referencedBeanName（ServiceBean的beanName）判断Spring容器中是否存在该bean，如果存在则给ref属性所对应的bean取一个别名，别名为referenceBeanName。</p>
<ol>
<li> 如果Spring容器中不存在referencedBeanName对应的bean，则判断容器中是否存在referenceBeanName所对应的Bean，如果不存在则将创建出来的ReferenceBean注册到Spring容器中（<strong>此处这么做就支持了可以通过@Autowired注解也可以使用服务了，****ReferenceBean是一个FactoryBean</strong>）</li>
</ol>
</li>
<li><p> 如果referencedBeanName存在对应的Bean，则额外生成一个代理对象，代理对象的InvocationHandler会缓存在<strong>localReferenceBeanInvocationHandlerCache中，这样如果引入的是同一个服务，并且这个服务在本地，</strong></p>
</li>
<li><p> 如果referencedBeanName不存在对应的Bean，则直接调用ReferenceBean的get()方法得到一个代理对象</p>
</li>
</ol>
<h5 id="AnnotationInjectedBeanPostProcessor代码注释"><a href="#AnnotationInjectedBeanPostProcessor代码注释" class="headerlink" title="AnnotationInjectedBeanPostProcessor代码注释"></a>AnnotationInjectedBeanPostProcessor代码注释</h5><blockquote>
<p>这个类是Spring的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationInjectedBeanPostProcessor</span><span class="params">(Class&lt;? extends Annotation&gt;... annotationTypes)</span> </span>&#123;</span><br><span class="line">       Assert.notEmpty(annotationTypes, <span class="string">&quot;The argument of annotations&#x27; types must not empty&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.annotationTypes = annotationTypes;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找需要注入的属性（被@Reference标注的Field），也就是寻找注入点</span></span><br><span class="line">       InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           metadata.inject(bean, beanName, pvs);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ex;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of @&quot;</span> + getAnnotationType().getSimpleName()</span><br><span class="line">                   + <span class="string">&quot; dependencies is failed&quot;</span>, ex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findInjectionMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">       String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">       <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">       AnnotationInjectedBeanPostProcessor.AnnotatedInjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">       <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">               metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">               <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       metadata.clear(pvs);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       metadata = buildAnnotatedMetadata(clazz);</span><br><span class="line">                       <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to introspect object class [&quot;</span> + clazz.getName() +</span><br><span class="line">                               <span class="string">&quot;] for annotation metadata: could not find class that it depends on&quot;</span>, err);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> metadata;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnnotationInjectedBeanPostProcessor.<span class="function">AnnotatedInjectionMetadata <span class="title">buildAnnotatedMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 哪些Filed上有@Reference注解</span></span><br><span class="line">       Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; fieldElements = findFieldAnnotationMetadata(beanClass);</span><br><span class="line">       <span class="comment">// 哪些方法上有@Reference注解</span></span><br><span class="line">       Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedMethodElement&gt; methodElements = findAnnotatedMethodMetadata(beanClass);</span><br><span class="line">       <span class="comment">// 返回的是Dubbo定义的AnnotatedInjectionMetadata，接下来就会使用这个类去进行属性注入</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> AnnotationInjectedBeanPostProcessor.AnnotatedInjectionMetadata(beanClass, fieldElements, methodElements);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Annotation Annotated&#125; &#123;<span class="doctag">@link</span> InjectionMetadata&#125; implementation</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedInjectionMetadata</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; fieldElements;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedMethodElement&gt; methodElements;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedInjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; fieldElements,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedMethodElement&gt; methodElements)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(targetClass, combine(fieldElements, methodElements));</span><br><span class="line">           <span class="keyword">this</span>.fieldElements = fieldElements;</span><br><span class="line">           <span class="keyword">this</span>.methodElements = methodElements;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedFieldElement&gt; getFieldElements() &#123;</span><br><span class="line">           <span class="keyword">return</span> fieldElements;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> Collection&lt;AnnotationInjectedBeanPostProcessor.AnnotatedMethodElement&gt; getMethodElements() &#123;</span><br><span class="line">           <span class="keyword">return</span> methodElements;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Annotation Annotated&#125; &#123;<span class="doctag">@link</span> Method&#125; &#123;<span class="doctag">@link</span> InjectionMetadata.InjectedElement&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedMethodElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> AnnotationAttributes attributes;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> Object object;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="title">AnnotatedMethodElement</span><span class="params">(Method method, PropertyDescriptor pd, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(method, pd);</span><br><span class="line">           <span class="keyword">this</span>.method = method;</span><br><span class="line">           <span class="keyword">this</span>.attributes = attributes;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// set方法对应的属性的类型</span></span><br><span class="line">           Class&lt;?&gt; injectedType = pd.getPropertyType();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 从Spring容器中获取一个Bean（注意，这个方法内部会生成Bean而且会缓存，就像Spring中的getBean一样）</span></span><br><span class="line">           Object injectedObject = getInjectedObject(attributes, bean, beanName, injectedType, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">           ReflectionUtils.makeAccessible(method);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 调用set方法</span></span><br><span class="line">           method.invoke(bean, injectedObject);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> Annotation Annotated&#125; &#123;<span class="doctag">@link</span> Field&#125; &#123;<span class="doctag">@link</span> InjectionMetadata.InjectedElement&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedFieldElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Field field;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> AnnotationAttributes attributes;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> Object bean;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="title">AnnotatedFieldElement</span><span class="params">(Field field, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(field, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">this</span>.field = field;</span><br><span class="line">           <span class="keyword">this</span>.attributes = attributes;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">           <span class="comment">// 给bean对象进行属性赋值</span></span><br><span class="line"></span><br><span class="line">           Class&lt;?&gt; injectedType = field.getType();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取对象，然后进行注入</span></span><br><span class="line">           Object injectedObject = getInjectedObject(attributes, bean, beanName, injectedType, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">           ReflectionUtils.makeAccessible(field);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 字段赋值，injectedObject就是值</span></span><br><span class="line">           field.set(bean, injectedObject);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Object <span class="title">getInjectedObject</span><span class="params">(AnnotationAttributes attributes, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// ServiceBean:org.apache.dubbo.demo.DemoService#source=private org.apache.dubbo.demo.DemoService org.apache.dubbo.demo.consumer.comp.DemoServiceComponent.demoService#attributes=&#123;parameters=[Ljava.lang.String;@42e25b0b&#125;</span></span><br><span class="line">       <span class="comment">// 哪个Service应用了哪个类型的服务，通过什么方式引入的</span></span><br><span class="line">       <span class="comment">// cacheKey很鸡肋，属性名不一样的时候，cacheKey不一样，导致不能缓存， 在一个Service中@Reference两次同一个服务缓存不到</span></span><br><span class="line">       String cacheKey = buildInjectedObjectCacheKey(attributes, bean, beanName, injectedType, injectedElement);</span><br><span class="line">      </span><br><span class="line">	</span><br><span class="line">       Object injectedObject = injectedObjectsCache.get(cacheKey);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (injectedObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// // 这里会调用子类的方法生成Bean，这里的子类指的就是ReferenceAnnotationBeanPostProcessor</span></span><br><span class="line">           injectedObject = doGetInjectedBean(attributes, bean, beanName, injectedType, injectedElement);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Customized inject-object if necessary</span></span><br><span class="line">           injectedObjectsCache.putIfAbsent(cacheKey, injectedObject);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> injectedObject;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="ReferenceAnnotationBeanPostProcessor代码注释"><a href="#ReferenceAnnotationBeanPostProcessor代码注释" class="headerlink" title="ReferenceAnnotationBeanPostProcessor代码注释"></a>ReferenceAnnotationBeanPostProcessor代码注释</h5><blockquote>
<p>部分注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor&#125; implementation</span></span><br><span class="line"><span class="comment"> * that Consumer service &#123;<span class="doctag">@link</span> Reference&#125; annotated fields</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bean name of &#123;<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">&quot;referenceAnnotationBeanPostProcessor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = Integer.getInteger(BEAN_NAME + <span class="string">&quot;.cache.size&quot;</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ReferenceBean&lt;?&gt;&gt; referenceBeanCache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt; localReferenceBeanInvocationHandlerCache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedFieldReferenceBeanCache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedMethodReferenceBeanCache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * To support the legacy annotation that is <span class="doctag">@com</span>.alibaba.dubbo.config.annotation.Reference since 2.7.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">////调用AnnotationInjectedBeanPostProcessor的构造</span></span><br><span class="line">        <span class="keyword">super</span>(Reference.class, com.alibaba.dubbo.config.annotation.Reference.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets all beans of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null read-only &#123;<span class="doctag">@link</span> Collection&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ReferenceBean&lt;?&gt;&gt; getReferenceBeans() &#123;</span><br><span class="line">        <span class="keyword">return</span> referenceBeanCache.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get &#123;<span class="doctag">@link</span> ReferenceBean&#125; &#123;<span class="doctag">@link</span> Map&#125; in injected field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null &#123;<span class="doctag">@link</span> Map&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedFieldReferenceBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(injectedFieldReferenceBeanCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get &#123;<span class="doctag">@link</span> ReferenceBean&#125; &#123;<span class="doctag">@link</span> Map&#125; in injected method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null &#123;<span class="doctag">@link</span> Map&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedMethodReferenceBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(injectedMethodReferenceBeanCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法得到的对象会赋值给@ReferenceBean注解的属性</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(AnnotationAttributes attributes, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按ServiceBean的beanName生成规则来生成referencedBeanName， 规则为ServiceBean:interfaceClassName:version:group</span></span><br><span class="line">        String referencedBeanName = buildReferencedBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.相当于根据@Reference注解的信息(包括注解括号里的参数)按照toString的逻辑，生成referenceBeanName，这个东西是作为缓存的key</span></span><br><span class="line"><span class="comment">          实际上是进行了一些字符串的转换啥的，不用关心</span></span><br><span class="line"><span class="comment">        2.注意referencedBeanName和referenceBeanName的区别【一个有d字母，一个没有】。referencedBeanName是ServiceBean的</span></span><br><span class="line"><span class="comment">        名字。referenceBeanName是ReferenceBean的名字</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String referenceBeanName = getReferenceBeanName(attributes, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个ReferenceBean对象</span></span><br><span class="line">        ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把referenceBean添加到Spring容器中去</span></span><br><span class="line">        registerReferenceBean(referencedBeanName, referenceBean, attributes, injectedType);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//缓存注入点，不重要</span></span><br><span class="line">        cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个代理对象，Service中的属性被注入的就是这个代理对象</span></span><br><span class="line">        <span class="comment">// 内部会调用referenceBean.get();</span></span><br><span class="line">        <span class="keyword">return</span> getOrCreateProxy(referencedBeanName, referenceBeanName, referenceBean, injectedType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register an instance of &#123;<span class="doctag">@link</span> ReferenceBean&#125; as a Spring Bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName The name of bean that annotated Dubbo&#x27;s &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125; in the Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean      the instance of &#123;<span class="doctag">@link</span> ReferenceBean&#125; is about to register into the Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes         the &#123;<span class="doctag">@link</span> AnnotationAttributes attributes&#125; of &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass     the &#123;<span class="doctag">@link</span> Class class&#125; of Service interface</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceBean</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AnnotationAttributes attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是referenceBeanName</span></span><br><span class="line">        String beanName = getReferenceBeanName(attributes, interfaceClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前Spring容器中是否存在referencedBeanName</span></span><br><span class="line">        <span class="keyword">if</span> (existsServiceBean(referencedBeanName)) &#123; <span class="comment">// If @Service bean is local one</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Get  the <span class="doctag">@Service</span>&#x27;s BeanDefinition from &#123;<span class="doctag">@link</span> BeanFactory&#125;</span></span><br><span class="line"><span class="comment">             * Refer to &#123;<span class="doctag">@link</span> ServiceAnnotationBeanPostProcessor#buildServiceBeanDefinition&#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            AbstractBeanDefinition beanDefinition = (AbstractBeanDefinition) beanFactory.getBeanDefinition(referencedBeanName);</span><br><span class="line">            RuntimeBeanReference runtimeBeanReference = (RuntimeBeanReference) beanDefinition.getPropertyValues().get(<span class="string">&quot;ref&quot;</span>); <span class="comment">// ServiceBean --- ref</span></span><br><span class="line">            <span class="comment">// The name of bean annotated @Service</span></span><br><span class="line">            String serviceBeanName = runtimeBeanReference.getBeanName(); <span class="comment">// DemoServiceImpl对应的beanName</span></span><br><span class="line">            <span class="comment">// register Alias rather than a new bean name, in order to reduce duplicated beans</span></span><br><span class="line">            <span class="comment">// DemoServiceImpl多了一个别名</span></span><br><span class="line">            beanFactory.registerAlias(serviceBeanName, beanName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Remote @Service Bean</span></span><br><span class="line">            <span class="keyword">if</span> (!beanFactory.containsBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1.放入Spring容器里的应该是DemoService的实现类的代理对象，但是这里放的却是referenceBean类型对象</span></span><br><span class="line"><span class="comment">                2.referenceBean的父类有个get()可以直接获取到代理对象，那这里为啥不放呢？其实是为了支持@Autowire注解</span></span><br><span class="line"><span class="comment">                3.首先ReferenceBean实现了Spring的FactoryBean接口,FactoryBean获取对象时是这样的调用顺序</span></span><br><span class="line"><span class="comment">                	FactoryBean.getObject()  ==&gt;  getObject().get()  ==&gt;最终调子类ReferenceBean#get()</span></span><br><span class="line"><span class="comment">                 刚好给@Autowire注解注入了代理对象</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                beanFactory.registerSingleton(beanName, referenceBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the bean name of &#123;<span class="doctag">@link</span> ReferenceBean&#125; if &#123;<span class="doctag">@link</span> Reference#id() id attribute&#125; is present,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@link</span> #generateReferenceBeanName(AnnotationAttributes, Class) generate&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes     the &#123;<span class="doctag">@link</span> AnnotationAttributes attributes&#125; of &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass the &#123;<span class="doctag">@link</span> Class class&#125; of Service interface</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getReferenceBeanName</span><span class="params">(AnnotationAttributes attributes, Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// id attribute appears since 2.7.3</span></span><br><span class="line">        String beanName = getAttribute(attributes, <span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// beanName为null时会进入if判断</span></span><br><span class="line">        <span class="keyword">if</span> (!hasText(beanName)) &#123;</span><br><span class="line">            beanName = generateReferenceBeanName(attributes, interfaceClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the bean name of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes     the &#123;<span class="doctag">@link</span> AnnotationAttributes attributes&#125; of &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass the &#123;<span class="doctag">@link</span> Class class&#125; of Service interface</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateReferenceBeanName</span><span class="params">(AnnotationAttributes attributes, Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">        StringBuilder beanNameBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;@Reference&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!attributes.isEmpty()) &#123;</span><br><span class="line">            beanNameBuilder.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : attributes.entrySet()) &#123;</span><br><span class="line">                beanNameBuilder.append(entry.getKey())</span><br><span class="line">                        .append(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">                        .append(entry.getValue())</span><br><span class="line">                        .append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// replace the latest &quot;,&quot; to be &quot;)&quot;</span></span><br><span class="line">            beanNameBuilder.setCharAt(beanNameBuilder.lastIndexOf(<span class="string">&quot;,&quot;</span>), <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beanNameBuilder.append(<span class="string">&quot; &quot;</span>).append(interfaceClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanNameBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">existsServiceBean</span><span class="params">(String referencedBeanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.containsBean(referencedBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get or Create a proxy of &#123;<span class="doctag">@link</span> ReferenceBean&#125; for the specified the type of Dubbo service interface</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName   The name of bean that annotated Dubbo&#x27;s &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125; in the Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBeanName    the bean name of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean        the instance of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceInterfaceType the type of Dubbo service interface</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getOrCreateProxy</span><span class="params">(String referencedBeanName, String referenceBeanName, ReferenceBean referenceBean, Class&lt;?&gt; serviceInterfaceType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.引入的服务在Spirng容器里有，说明是本项目的bean，按理来说应该直接把DemoService的实现类赋给@Reference注解标注的属性</span></span><br><span class="line"><span class="comment">        2.但实际上不是，@Reference实际上最后赋值的是一个代理对象，因为除开需要执行DemoService的实现类里的方法，@Reference</span></span><br><span class="line"><span class="comment">        注解标注的属性还需要实现其它很多逻辑，实现这些增强逻辑之后最终才执行的DemoService的实现类里的方法。如果直接赋值</span></span><br><span class="line"><span class="comment">        DemoServiceImpl，那么Dubbo里面的很多逻辑就走不到了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (existsServiceBean(referencedBeanName)) &#123; <span class="comment">// If the local @Service Bean exists, build a proxy of ReferenceBean</span></span><br><span class="line">            <span class="comment">//wrapInvocationHandler最后也会调用referenceBean.get()，其实和下面的else一样</span></span><br><span class="line">            <span class="keyword">return</span> newProxyInstance(getClassLoader(), <span class="keyword">new</span> Class[]&#123;serviceInterfaceType&#125;,</span><br><span class="line">                    wrapInvocationHandler(referenceBeanName, referenceBean));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                    <span class="comment">// ReferenceBean should be initialized and get immediately</span></span><br><span class="line">            <span class="comment">// 重点，最终从这里赋值给@Reference注解标注的属性</span></span><br><span class="line">            <span class="keyword">return</span> referenceBean.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wrap an instance of &#123;<span class="doctag">@link</span> InvocationHandler&#125; that is used to get the proxy of &#123;<span class="doctag">@link</span> ReferenceBean&#125; after</span></span><br><span class="line"><span class="comment">     * the specified local referenced bean that annotated &#123;<span class="doctag">@link</span> <span class="doctag">@Service</span>&#125; exported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBeanName the bean name of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean     the instance of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> InvocationHandler <span class="title">wrapInvocationHandler</span><span class="params">(String referenceBeanName, ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localReferenceBeanInvocationHandlerCache.computeIfAbsent(referenceBeanName, name -&gt;</span><br><span class="line">                <span class="keyword">new</span> ReferenceBeanInvocationHandler(referenceBean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReferenceBean referenceBean;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanInvocationHandler</span><span class="params">(ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.referenceBean = referenceBean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Object result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123; <span class="comment">// If the bean is not initialized, invoke init()</span></span><br><span class="line">                    <span class="comment">// issue: https://github.com/apache/dubbo/issues/3429</span></span><br><span class="line">                    init();</span><br><span class="line">                &#125;</span><br><span class="line">                result = method.invoke(bean, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="comment">// re-throws the actual Exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.bean = referenceBean.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">buildInjectedObjectCacheKey</span><span class="params">(AnnotationAttributes attributes, Object bean, String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Class&lt;?&gt; injectedType, InjectionMetadata.InjectedElement injectedElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildReferencedBeanName(attributes, injectedType) +</span><br><span class="line">                <span class="string">&quot;#source=&quot;</span> + (injectedElement.getMember()) +</span><br><span class="line">                <span class="string">&quot;#attributes=&quot;</span> + AnnotationUtils.resolvePlaceholders(attributes, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes           the attributes of &#123;<span class="doctag">@link</span> Reference <span class="doctag">@Reference</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceInterfaceType the type of Dubbo&#x27;s service interface</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The name of bean that annotated Dubbo&#x27;s &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125; in local Spring &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildReferencedBeanName</span><span class="params">(AnnotationAttributes attributes, Class&lt;?&gt; serviceInterfaceType)</span> </span>&#123;</span><br><span class="line">        ServiceBeanNameBuilder serviceBeanNameBuilder = create(attributes, serviceInterfaceType, getEnvironment());</span><br><span class="line">        <span class="keyword">return</span> serviceBeanNameBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ReferenceBean <span class="title">buildReferenceBeanIfAbsent</span><span class="params">(String referenceBeanName, AnnotationAttributes attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     Class&lt;?&gt; referencedType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.key就是@Reference注解最终生成的字符串,value却不是简单的代理对象</span></span><br><span class="line"><span class="comment">        2.一个ServiceBean表示一个Dubbo服务，ReferenceBean表示引用的哪个dubbo服务</span></span><br><span class="line"><span class="comment">        3.所以ReferenceBean不是简单的代理对象，他保存了诸如超时时间,轮询参数等等这些东西</span></span><br><span class="line"><span class="comment">        【和ServcieBean很类似,ServcieBean也保存了这些东西】</span></span><br><span class="line"><span class="comment">        4.ReferenceBean的父类ReferenceConfig#get()最终返回代理对象</span></span><br><span class="line"><span class="comment">        5.ServiceBean和ReferenceBean思想基本上是一样的</span></span><br><span class="line"><span class="comment">        6.ReferenceBean最终会放入缓存，赋值给@Reference注解所标注的属性的依然是代理对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ReferenceBean&lt;?&gt; referenceBean = referenceBeanCache.get(referenceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (referenceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成了一个ReferenceBean对象，attributes是@Reference注解的参数值</span></span><br><span class="line">            ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder</span><br><span class="line">                    .create(attributes, applicationContext)</span><br><span class="line">                    .interfaceClass(referencedType);</span><br><span class="line">            referenceBean = beanBuilder.build();</span><br><span class="line"></span><br><span class="line">            referenceBeanCache.put(referenceBeanName, referenceBean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!referencedType.isAssignableFrom(referenceBean.getInterfaceClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;reference bean name &quot;</span> + referenceBeanName + <span class="string">&quot; has been duplicated, but interfaceClass &quot;</span> +</span><br><span class="line">                    referenceBean.getInterfaceClass().getName() + <span class="string">&quot; cannot be assigned to &quot;</span> + referencedType.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> referenceBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheInjectedReferenceBean</span><span class="params">(ReferenceBean referenceBean,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            InjectionMetadata.InjectedElement injectedElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (injectedElement.getMember() <span class="keyword">instanceof</span> Field) &#123;</span><br><span class="line">            injectedFieldReferenceBeanCache.put(injectedElement, referenceBean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectedElement.getMember() <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">            injectedMethodReferenceBeanCache.put(injectedElement, referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ServiceBeanExportedEvent) &#123;</span><br><span class="line">            onServiceBeanExportEvent((ServiceBeanExportedEvent) event);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            onContextRefreshedEvent((ContextRefreshedEvent) event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onServiceBeanExportEvent</span><span class="params">(ServiceBeanExportedEvent event)</span> </span>&#123;</span><br><span class="line">        ServiceBean serviceBean = event.getServiceBean();</span><br><span class="line">        initReferenceBeanInvocationHandler(serviceBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initReferenceBeanInvocationHandler</span><span class="params">(ServiceBean serviceBean)</span> </span>&#123;</span><br><span class="line">        String serviceBeanName = serviceBean.getBeanName();</span><br><span class="line">        <span class="comment">// Remove ServiceBean when it&#x27;s exported</span></span><br><span class="line">        ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.remove(serviceBeanName);</span><br><span class="line">        <span class="comment">// Initialize</span></span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="keyword">this</span>.referenceBeanCache.clear();</span><br><span class="line">        <span class="keyword">this</span>.localReferenceBeanInvocationHandlerCache.clear();</span><br><span class="line">        <span class="keyword">this</span>.injectedFieldReferenceBeanCache.clear();</span><br><span class="line">        <span class="keyword">this</span>.injectedMethodReferenceBeanCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">youthlql</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://imlql.cn/post/796f395d.html">https://imlql.cn/post/796f395d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://imlql.cn" target="_blank">风祈的时光录</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dubbo/">Dubbo</a><a class="post-meta__tags" href="/tags/rpc/">rpc</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://unpkg.zhimg.com/youthlql@1.0.8/blog/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="https://unpkg.zhimg.com/youthlql@1.0.8/blog/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://unpkg.zhimg.com/youthlql@1.0.8/blog/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="https://unpkg.zhimg.com/youthlql@1.0.8/blog/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/48141866.html"><img class="prev-cover" src="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析</div></div></a></div><div class="next-post pull-right"><a href="/post/1a003b7b.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/youthlql/youthlql/img/spring.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring常用注解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/84653c9d.html" title="07.Dubbo源码系列V1-Dubbo第七节-服务调用源码解析"><img class="cover" src="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-09</div><div class="title">07.Dubbo源码系列V1-Dubbo第七节-服务调用源码解析</div></div></a></div><div><a href="/post/dbcfef47.html" title="03.Dubbo源码系列V1-Dubbo第三节-可扩展机制SPI源码解析"><img class="cover" src="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-12</div><div class="title">03.Dubbo源码系列V1-Dubbo第三节-可扩展机制SPI源码解析</div></div></a></div><div><a href="/post/d3c530c4.html" title="01&02.Dubbo源码系列V1-Dubbo第一二节-基本应用与高级应用"><img class="cover" src="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-11</div><div class="title">01&02.Dubbo源码系列V1-Dubbo第一二节-基本应用与高级应用</div></div></a></div><div><a href="/post/bda15919.html" title="06.Dubbo源码系列V1-Dubbo第六节-服务引入源码解析"><img class="cover" src="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-08</div><div class="title">06.Dubbo源码系列V1-Dubbo第六节-服务引入源码解析</div></div></a></div><div><a href="/post/48141866.html" title="05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析"><img class="cover" src="https://gitee.com/youthlql/randombg/raw/master/logo/dubbo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-06</div><div class="title">05.Dubbo源码系列V1-Dubbo第五节-服务导出源码解析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-Spring%E4%B8%8EDubbo%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">第四节: Spring与Dubbo整合原理与源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86-Service"><span class="toc-text">处理@Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86Properties%E6%96%87%E4%BB%B6"><span class="toc-text">处理Properties文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">实例解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnableDubbo"><span class="toc-text">@EnableDubbo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DubboConfigConfigurationRegistrar"><span class="toc-text">DubboConfigConfigurationRegistrar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-text">流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DubboConfigBindingRegistrar"><span class="toc-text">DubboConfigBindingRegistrar</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A4%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-text">此类总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><span class="toc-text">代码注释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DubboConfigBindingBeanPostProcessor"><span class="toc-text">DubboConfigBindingBeanPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-1"><span class="toc-text">代码注释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DefaultDubboConfigBinder"><span class="toc-text">DefaultDubboConfigBinder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DubboComponentScanRegistrar"><span class="toc-text">DubboComponentScanRegistrar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-2"><span class="toc-text">代码注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServiceAnnotationBeanPostProcessor"><span class="toc-text">ServiceAnnotationBeanPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DubboClassPathBeanDefinitionScanner"><span class="toc-text">DubboClassPathBeanDefinitionScanner</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ServiceBean"><span class="toc-text">ServiceBean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-3"><span class="toc-text">代码注释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReferenceAnnotationBeanPostProcessor"><span class="toc-text">ReferenceAnnotationBeanPostProcessor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AnnotationInjectedBeanPostProcessor%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><span class="toc-text">AnnotationInjectedBeanPostProcessor代码注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReferenceAnnotationBeanPostProcessor%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><span class="toc-text">ReferenceAnnotationBeanPostProcessor代码注释</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By youthlql</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener" class="one-pan-link-mark"><img style="position:relative;top:-3px; " src="https://gitee.com/youthlql/randombg/raw/master/logo/upyun_logo2.png" align="absmiddle" width="60px" height="30px">提供加速服务</a> <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://cdn.jsdelivr.net/npm/kang-static/Hexo/img/icp.png"><span>鄂ICP备19028890号-3</span></a><br><script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279775059'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279775059%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'my-twikoo-6gxmrz0dcba76a39',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'my-twikoo-6gxmrz0dcba76a39',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>